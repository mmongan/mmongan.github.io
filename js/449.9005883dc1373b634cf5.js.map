{"version":3,"file":"js/449.9005883dc1373b634cf5.js","mappings":"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","sources":["webpack://babylonjs-typescript-webpack-template/./dev/core/src/Materials/Textures/baseTexture.polynomial.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Misc/environmentTextureTools.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Materials/Textures/Loaders/envTextureLoader.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Misc/HighDynamicRange/cubemapToSphericalPolynomial.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Misc/dumpTools.ts"],"sourcesContent":["import type { Nullable } from \"../../types\";\r\nimport { CubeMapToSphericalPolynomialTools } from \"../../Misc/HighDynamicRange/cubemapToSphericalPolynomial\";\r\nimport type { SphericalPolynomial } from \"../../Maths/sphericalPolynomial\";\r\nimport { BaseTexture } from \"./baseTexture\";\r\n\r\ndeclare module \"./baseTexture\" {\r\n    export interface BaseTexture {\r\n        /**\r\n         * Get the polynomial representation of the texture data.\r\n         * This is mainly use as a fast way to recover IBL Diffuse irradiance data.\r\n         * @see https://learnopengl.com/PBR/IBL/Diffuse-irradiance\r\n         */\r\n        sphericalPolynomial: Nullable<SphericalPolynomial>;\r\n\r\n        /**\r\n         * Force recomputation of spherical polynomials.\r\n         * Can be useful if you generate a cubemap multiple times (from a probe for eg) and you need the proper polynomials each time\r\n         */\r\n        forceSphericalPolynomialsRecompute(): void;\r\n    }\r\n}\r\n\r\nBaseTexture.prototype.forceSphericalPolynomialsRecompute = function (): void {\r\n    if (this._texture) {\r\n        this._texture._sphericalPolynomial = null;\r\n        this._texture._sphericalPolynomialPromise = null;\r\n        this._texture._sphericalPolynomialComputed = false;\r\n    }\r\n};\r\n\r\nObject.defineProperty(BaseTexture.prototype, \"sphericalPolynomial\", {\r\n    get: function (this: BaseTexture) {\r\n        if (this._texture) {\r\n            if (this._texture._sphericalPolynomial || this._texture._sphericalPolynomialComputed) {\r\n                return this._texture._sphericalPolynomial;\r\n            }\r\n\r\n            if (this._texture.isReady) {\r\n                if (!this._texture._sphericalPolynomialPromise) {\r\n                    this._texture._sphericalPolynomialPromise = CubeMapToSphericalPolynomialTools.ConvertCubeMapTextureToSphericalPolynomial(this);\r\n                    if (this._texture._sphericalPolynomialPromise === null) {\r\n                        this._texture._sphericalPolynomialComputed = true;\r\n                    } else {\r\n                        this._texture._sphericalPolynomialPromise.then((sphericalPolynomial) => {\r\n                            this._texture!._sphericalPolynomial = sphericalPolynomial;\r\n                            this._texture!._sphericalPolynomialComputed = true;\r\n                        });\r\n                    }\r\n                }\r\n\r\n                return null;\r\n            }\r\n        }\r\n\r\n        return null;\r\n    },\r\n    set: function (this: BaseTexture, value: Nullable<SphericalPolynomial>) {\r\n        if (this._texture) {\r\n            this._texture._sphericalPolynomial = value;\r\n        }\r\n    },\r\n    enumerable: true,\r\n    configurable: true,\r\n});\r\n","/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { Nullable } from \"../types\";\r\nimport { Tools } from \"./tools\";\r\nimport { Vector3 } from \"../Maths/math.vector\";\r\nimport { ILog2 } from \"../Maths/math.scalar.functions\";\r\nimport { SphericalPolynomial } from \"../Maths/sphericalPolynomial\";\r\nimport { InternalTexture, InternalTextureSource } from \"../Materials/Textures/internalTexture\";\r\nimport { BaseTexture } from \"../Materials/Textures/baseTexture\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { Scene } from \"../scene\";\r\nimport { PostProcess } from \"../PostProcesses/postProcess\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport { RGBDTextureTools } from \"./rgbdTextureTools\";\r\nimport { DumpDataAsync } from \"../Misc/dumpTools\";\r\nimport { ShaderLanguage } from \"core/Materials\";\r\n\r\nimport type { RenderTargetWrapper } from \"../Engines/renderTargetWrapper\";\r\nimport type { Engine, WebGPUEngine } from \"core/Engines\";\r\n\r\nimport \"../Materials/Textures/baseTexture.polynomial\";\r\n\r\nconst DefaultEnvironmentTextureImageType = \"image/png\";\r\nconst CurrentVersion = 2;\r\n\r\n/**\r\n * Raw texture data and descriptor sufficient for WebGL texture upload\r\n */\r\nexport type EnvironmentTextureInfo = EnvironmentTextureInfoV1 | EnvironmentTextureInfoV2;\r\n\r\n/**\r\n * v1 of EnvironmentTextureInfo\r\n */\r\ninterface EnvironmentTextureInfoV1 {\r\n    /**\r\n     * Version of the environment map\r\n     */\r\n    version: 1;\r\n\r\n    /**\r\n     * Width of image\r\n     */\r\n    width: number;\r\n\r\n    /**\r\n     * Irradiance information stored in the file.\r\n     */\r\n    irradiance: Nullable<EnvironmentTextureIrradianceInfoV1>;\r\n\r\n    /**\r\n     * Specular information stored in the file.\r\n     */\r\n    specular: EnvironmentTextureSpecularInfoV1;\r\n}\r\n\r\n/**\r\n * v2 of EnvironmentTextureInfo\r\n */\r\ninterface EnvironmentTextureInfoV2 {\r\n    /**\r\n     * Version of the environment map\r\n     */\r\n    version: 2;\r\n\r\n    /**\r\n     * Width of image\r\n     */\r\n    width: number;\r\n\r\n    /**\r\n     * Irradiance information stored in the file.\r\n     */\r\n    irradiance: Nullable<EnvironmentTextureIrradianceInfoV1>;\r\n\r\n    /**\r\n     * Specular information stored in the file.\r\n     */\r\n    specular: EnvironmentTextureSpecularInfoV1;\r\n\r\n    /**\r\n     * The mime type used to encode the image data.\r\n     */\r\n    imageType: string;\r\n\r\n    /**\r\n     * Defines where the specular Payload is located. It is a runtime value only not stored in the file.\r\n     */\r\n    binaryDataPosition?: number;\r\n}\r\n\r\n/**\r\n * Defines One Image in the file. It requires only the position in the file\r\n * as well as the length.\r\n */\r\ninterface BufferImageData {\r\n    /**\r\n     * Length of the image data.\r\n     */\r\n    length: number;\r\n    /**\r\n     * Position of the data from the null terminator delimiting the end of the JSON.\r\n     */\r\n    position: number;\r\n}\r\n\r\n/**\r\n * Defines the diffuse data enclosed in the file.\r\n * This corresponds to the version 1 of the data.\r\n */\r\nexport interface EnvironmentTextureIrradianceTextureInfoV1 {\r\n    /**\r\n     * Size of the texture faces.\r\n     */\r\n    size: number;\r\n    /**\r\n     * This contains all the images data needed to reconstruct the cubemap.\r\n     */\r\n    faces: Array<BufferImageData>;\r\n}\r\n\r\n/**\r\n * Defines the specular data enclosed in the file.\r\n * This corresponds to the version 1 of the data.\r\n */\r\nexport interface EnvironmentTextureSpecularInfoV1 {\r\n    /**\r\n     * This contains all the images data needed to reconstruct the cubemap.\r\n     */\r\n    mipmaps: Array<BufferImageData>;\r\n\r\n    /**\r\n     * Defines the scale applied to environment texture. This manages the range of LOD level used for IBL according to the roughness.\r\n     */\r\n    lodGenerationScale: number;\r\n}\r\n\r\n/**\r\n * Defines the required storage to save the environment irradiance information.\r\n */\r\ninterface EnvironmentTextureIrradianceInfoV1 {\r\n    x: Array<number>;\r\n    y: Array<number>;\r\n    z: Array<number>;\r\n\r\n    xx: Array<number>;\r\n    yy: Array<number>;\r\n    zz: Array<number>;\r\n\r\n    yz: Array<number>;\r\n    zx: Array<number>;\r\n    xy: Array<number>;\r\n\r\n    irradianceTexture?: EnvironmentTextureIrradianceTextureInfoV1 | undefined;\r\n}\r\n\r\n/**\r\n * Options for creating environment textures\r\n */\r\nexport interface CreateEnvTextureOptions {\r\n    /**\r\n     * The mime type of encoded images.\r\n     */\r\n    imageType?: string;\r\n\r\n    /**\r\n     * the image quality of encoded WebP images.\r\n     */\r\n    imageQuality?: number;\r\n\r\n    /**\r\n     * Disables the generation of irradiance texture even if present on the source.\r\n     */\r\n    disableIrradianceTexture?: boolean;\r\n}\r\n\r\n/**\r\n * Magic number identifying the env file.\r\n */\r\nconst MagicBytes = [0x86, 0x16, 0x87, 0x96, 0xf6, 0xd6, 0x96, 0x36];\r\n\r\n/**\r\n * Gets the environment info from an env file.\r\n * @param data The array buffer containing the .env bytes.\r\n * @returns the environment file info (the json header) if successfully parsed, normalized to the latest supported version.\r\n */\r\nexport function GetEnvInfo(data: ArrayBufferView): Nullable<EnvironmentTextureInfoV2> {\r\n    const dataView = new DataView(data.buffer, data.byteOffset, data.byteLength);\r\n    let pos = 0;\r\n\r\n    for (let i = 0; i < MagicBytes.length; i++) {\r\n        if (dataView.getUint8(pos++) !== MagicBytes[i]) {\r\n            Logger.Error(\"Not a babylon environment map\");\r\n            return null;\r\n        }\r\n    }\r\n\r\n    // Read json manifest - collect characters up to null terminator\r\n    let manifestString = \"\";\r\n    let charCode = 0x00;\r\n    while ((charCode = dataView.getUint8(pos++))) {\r\n        manifestString += String.fromCharCode(charCode);\r\n    }\r\n\r\n    let manifest: EnvironmentTextureInfo = JSON.parse(manifestString);\r\n    manifest = normalizeEnvInfo(manifest);\r\n    // Extend the header with the position of the payload.\r\n    manifest.binaryDataPosition = pos;\r\n\r\n    if (manifest.specular) {\r\n        // Fallback to 0.8 exactly if lodGenerationScale is not defined for backward compatibility.\r\n        manifest.specular.lodGenerationScale = manifest.specular.lodGenerationScale || 0.8;\r\n    }\r\n\r\n    return manifest;\r\n}\r\n\r\n/**\r\n * Normalizes any supported version of the environment file info to the latest version\r\n * @param info environment file info on any supported version\r\n * @returns environment file info in the latest supported version\r\n * @private\r\n */\r\nexport function normalizeEnvInfo(info: EnvironmentTextureInfo): EnvironmentTextureInfoV2 {\r\n    if (info.version > CurrentVersion) {\r\n        throw new Error(`Unsupported babylon environment map version \"${info.version}\". Latest supported version is \"${CurrentVersion}\".`);\r\n    }\r\n\r\n    if (info.version === 2) {\r\n        return info;\r\n    }\r\n\r\n    // Migrate a v1 info to v2\r\n    info = { ...info, version: 2, imageType: DefaultEnvironmentTextureImageType };\r\n\r\n    return info;\r\n}\r\n\r\n/**\r\n * Creates an environment texture from a loaded cube texture.\r\n * @param texture defines the cube texture to convert in env file\r\n * @param options options for the conversion process\r\n * @param options.imageType the mime type for the encoded images, with support for \"image/png\" (default) and \"image/webp\"\r\n * @param options.imageQuality the image quality of encoded WebP images.\r\n * @returns a promise containing the environment data if successful.\r\n */\r\nexport async function CreateEnvTextureAsync(texture: BaseTexture, options: CreateEnvTextureOptions = {}): Promise<ArrayBuffer> {\r\n    const internalTexture = texture.getInternalTexture();\r\n    if (!internalTexture) {\r\n        return Promise.reject(\"The cube texture is invalid.\");\r\n    }\r\n\r\n    const engine = internalTexture.getEngine();\r\n\r\n    if (\r\n        texture.textureType !== Constants.TEXTURETYPE_HALF_FLOAT &&\r\n        texture.textureType !== Constants.TEXTURETYPE_FLOAT &&\r\n        texture.textureType !== Constants.TEXTURETYPE_UNSIGNED_BYTE &&\r\n        texture.textureType !== Constants.TEXTURETYPE_UNSIGNED_BYTE &&\r\n        texture.textureType !== Constants.TEXTURETYPE_UNSIGNED_INTEGER &&\r\n        texture.textureType !== -1\r\n    ) {\r\n        return Promise.reject(\"The cube texture should allow HDR (Full Float or Half Float).\");\r\n    }\r\n\r\n    let textureType = Constants.TEXTURETYPE_FLOAT;\r\n    if (!engine.getCaps().textureFloatRender) {\r\n        textureType = Constants.TEXTURETYPE_HALF_FLOAT;\r\n        if (!engine.getCaps().textureHalfFloatRender) {\r\n            return Promise.reject(\"Env texture can only be created when the browser supports half float or full float rendering.\");\r\n        }\r\n    }\r\n\r\n    // sphericalPolynomial is lazy loaded so simply accessing it should trigger the computation.\r\n    texture.sphericalPolynomial;\r\n\r\n    // Lets keep track of the polynomial promise so we can wait for it to be ready before generating the pixels.\r\n    const sphericalPolynomialPromise = texture.getInternalTexture()?._sphericalPolynomialPromise;\r\n\r\n    const cubeWidth = internalTexture.width;\r\n    const hostingScene = new Scene(engine);\r\n    const specularTextures: { [key: number]: ArrayBuffer } = {};\r\n    const diffuseTextures: { [key: number]: ArrayBuffer } = {};\r\n\r\n    // As we are going to readPixels the faces of the cube, make sure the drawing/update commands for the cube texture are fully sent to the GPU in case it is drawn for the first time in this very frame!\r\n    engine.flushFramebuffer();\r\n\r\n    const imageType = options.imageType ?? DefaultEnvironmentTextureImageType;\r\n\r\n    // Read and collect all mipmaps data from the cube.\r\n    const mipmapsCount = ILog2(internalTexture.width);\r\n    for (let i = 0; i <= mipmapsCount; i++) {\r\n        const faceWidth = Math.pow(2, mipmapsCount - i);\r\n\r\n        // All faces of the cube.\r\n        for (let face = 0; face < 6; face++) {\r\n            specularTextures[i * 6 + face] = await _getTextureEncodedData(hostingScene, texture, textureType, face, i, faceWidth, imageType, options.imageQuality);\r\n        }\r\n    }\r\n\r\n    // Read and collect all irradiance data from the cube.\r\n    const irradianceTexture = options.disableIrradianceTexture ? null : texture.irradianceTexture;\r\n    if (irradianceTexture) {\r\n        const faceWidth = irradianceTexture.getSize().width;\r\n\r\n        // All faces of the cube.\r\n        for (let face = 0; face < 6; face++) {\r\n            diffuseTextures[face] = await _getTextureEncodedData(hostingScene, irradianceTexture, textureType, face, 0, faceWidth, imageType, options.imageQuality);\r\n        }\r\n    }\r\n\r\n    // We can delete the hosting scene keeping track of all the creation objects\r\n    hostingScene.dispose();\r\n\r\n    // Ensure completion of the polynomial creation promise.\r\n    if (sphericalPolynomialPromise) {\r\n        await sphericalPolynomialPromise;\r\n    }\r\n\r\n    // Creates the json header for the env texture\r\n    const info: EnvironmentTextureInfo = {\r\n        version: CurrentVersion,\r\n        width: cubeWidth,\r\n        imageType,\r\n        irradiance: _CreateEnvTextureIrradiance(texture),\r\n        specular: {\r\n            mipmaps: [],\r\n            lodGenerationScale: texture.lodGenerationScale,\r\n        },\r\n    };\r\n\r\n    // Sets the specular image data information\r\n    let position = 0;\r\n    for (let i = 0; i <= mipmapsCount; i++) {\r\n        for (let face = 0; face < 6; face++) {\r\n            const byteLength = specularTextures[i * 6 + face].byteLength;\r\n            info.specular.mipmaps.push({\r\n                length: byteLength,\r\n                position: position,\r\n            });\r\n            position += byteLength;\r\n        }\r\n    }\r\n\r\n    // Sets the irradiance image data information\r\n    if (irradianceTexture) {\r\n        info.irradiance = info.irradiance || {\r\n            x: [0, 0, 0],\r\n            xx: [0, 0, 0],\r\n            y: [0, 0, 0],\r\n            yy: [0, 0, 0],\r\n            z: [0, 0, 0],\r\n            zz: [0, 0, 0],\r\n            yz: [0, 0, 0],\r\n            zx: [0, 0, 0],\r\n            xy: [0, 0, 0],\r\n        };\r\n        info.irradiance.irradianceTexture = {\r\n            size: irradianceTexture.getSize().width,\r\n            faces: [],\r\n        };\r\n\r\n        for (let face = 0; face < 6; face++) {\r\n            const byteLength = diffuseTextures[face].byteLength;\r\n            info.irradiance.irradianceTexture.faces.push({\r\n                length: byteLength,\r\n                position: position,\r\n            });\r\n            position += byteLength;\r\n        }\r\n    }\r\n\r\n    // Encode the JSON as an array buffer\r\n    const infoString = JSON.stringify(info);\r\n    const infoBuffer = new ArrayBuffer(infoString.length + 1);\r\n    const infoView = new Uint8Array(infoBuffer); // Limited to ascii subset matching unicode.\r\n    for (let i = 0, strLen = infoString.length; i < strLen; i++) {\r\n        infoView[i] = infoString.charCodeAt(i);\r\n    }\r\n    // Ends up with a null terminator for easier parsing\r\n    infoView[infoString.length] = 0x00;\r\n\r\n    // Computes the final required size and creates the storage\r\n    const totalSize = MagicBytes.length + position + infoBuffer.byteLength;\r\n    const finalBuffer = new ArrayBuffer(totalSize);\r\n    const finalBufferView = new Uint8Array(finalBuffer);\r\n    const dataView = new DataView(finalBuffer);\r\n\r\n    // Copy the magic bytes identifying the file in\r\n    let pos = 0;\r\n    for (let i = 0; i < MagicBytes.length; i++) {\r\n        dataView.setUint8(pos++, MagicBytes[i]);\r\n    }\r\n\r\n    // Add the json info\r\n    finalBufferView.set(new Uint8Array(infoBuffer), pos);\r\n    pos += infoBuffer.byteLength;\r\n\r\n    // Finally inserts the radiance texture data\r\n    for (let i = 0; i <= mipmapsCount; i++) {\r\n        for (let face = 0; face < 6; face++) {\r\n            const dataBuffer = specularTextures[i * 6 + face];\r\n            finalBufferView.set(new Uint8Array(dataBuffer), pos);\r\n            pos += dataBuffer.byteLength;\r\n        }\r\n    }\r\n\r\n    // Finally inserts the irradiance texture data\r\n    if (irradianceTexture) {\r\n        for (let face = 0; face < 6; face++) {\r\n            const dataBuffer = diffuseTextures[face];\r\n            finalBufferView.set(new Uint8Array(dataBuffer), pos);\r\n            pos += dataBuffer.byteLength;\r\n        }\r\n    }\r\n\r\n    // Voila\r\n    return finalBuffer;\r\n}\r\n\r\n/**\r\n * Get the texture encoded data from the current texture\r\n * @internal\r\n */\r\nasync function _getTextureEncodedData(\r\n    hostingScene: Scene,\r\n    texture: BaseTexture,\r\n    textureType: number,\r\n    face: number,\r\n    i: number,\r\n    size: number,\r\n    imageType: string,\r\n    imageQuality?: number\r\n) {\r\n    let faceData = await texture.readPixels(face, i, undefined, false);\r\n    if (faceData && faceData.byteLength === (faceData as Uint8Array).length) {\r\n        const faceDataFloat = new Float32Array(faceData!.byteLength * 4);\r\n        for (let i = 0; i < faceData.byteLength; i++) {\r\n            faceDataFloat[i] = (faceData as Uint8Array)[i] / 255;\r\n            // Gamma to linear\r\n            faceDataFloat[i] = Math.pow(faceDataFloat[i], 2.2);\r\n        }\r\n        faceData = faceDataFloat;\r\n    } else if (faceData && texture.gammaSpace) {\r\n        const floatData = faceData as Float32Array;\r\n        for (let i = 0; i < floatData.length; i++) {\r\n            // Gamma to linear\r\n            floatData[i] = Math.pow(floatData[i], 2.2);\r\n        }\r\n    }\r\n\r\n    const engine = hostingScene.getEngine();\r\n    const tempTexture = engine.createRawTexture(faceData, size, size, Constants.TEXTUREFORMAT_RGBA, false, true, Constants.TEXTURE_NEAREST_SAMPLINGMODE, null, textureType);\r\n\r\n    await RGBDTextureTools.EncodeTextureToRGBD(tempTexture, hostingScene, textureType);\r\n\r\n    const rgbdEncodedData = await engine._readTexturePixels(tempTexture, size, size);\r\n\r\n    const imageEncodedData = await DumpDataAsync(size, size, rgbdEncodedData, imageType, undefined, false, true, imageQuality);\r\n\r\n    tempTexture.dispose();\r\n\r\n    return imageEncodedData as ArrayBuffer;\r\n}\r\n\r\n/**\r\n * Creates a JSON representation of the spherical data.\r\n * @param texture defines the texture containing the polynomials\r\n * @returns the JSON representation of the spherical info\r\n */\r\nfunction _CreateEnvTextureIrradiance(texture: BaseTexture): Nullable<EnvironmentTextureIrradianceInfoV1> {\r\n    const polynmials = texture.sphericalPolynomial;\r\n    if (polynmials == null) {\r\n        return null;\r\n    }\r\n\r\n    return {\r\n        x: [polynmials.x.x, polynmials.x.y, polynmials.x.z],\r\n        y: [polynmials.y.x, polynmials.y.y, polynmials.y.z],\r\n        z: [polynmials.z.x, polynmials.z.y, polynmials.z.z],\r\n\r\n        xx: [polynmials.xx.x, polynmials.xx.y, polynmials.xx.z],\r\n        yy: [polynmials.yy.x, polynmials.yy.y, polynmials.yy.z],\r\n        zz: [polynmials.zz.x, polynmials.zz.y, polynmials.zz.z],\r\n\r\n        yz: [polynmials.yz.x, polynmials.yz.y, polynmials.yz.z],\r\n        zx: [polynmials.zx.x, polynmials.zx.y, polynmials.zx.z],\r\n        xy: [polynmials.xy.x, polynmials.xy.y, polynmials.xy.z],\r\n    };\r\n}\r\n\r\n/**\r\n * Creates the ArrayBufferViews used for initializing environment texture image data.\r\n * @param data the image data\r\n * @param info parameters that determine what views will be created for accessing the underlying buffer\r\n * @returns the views described by info providing access to the underlying buffer\r\n */\r\nexport function CreateRadianceImageDataArrayBufferViews(data: ArrayBufferView, info: EnvironmentTextureInfo): Array<Array<ArrayBufferView>> {\r\n    info = normalizeEnvInfo(info);\r\n\r\n    const specularInfo = info.specular;\r\n\r\n    // Double checks the enclosed info\r\n    let mipmapsCount = Math.log2(info.width);\r\n    mipmapsCount = Math.round(mipmapsCount) + 1;\r\n    if (specularInfo.mipmaps.length !== 6 * mipmapsCount) {\r\n        throw new Error(`Unsupported specular mipmaps number \"${specularInfo.mipmaps.length}\"`);\r\n    }\r\n\r\n    const imageData = new Array<Array<ArrayBufferView>>(mipmapsCount);\r\n    for (let i = 0; i < mipmapsCount; i++) {\r\n        imageData[i] = new Array<ArrayBufferView>(6);\r\n        for (let face = 0; face < 6; face++) {\r\n            const imageInfo = specularInfo.mipmaps[i * 6 + face];\r\n            imageData[i][face] = new Uint8Array(data.buffer, data.byteOffset + info.binaryDataPosition! + imageInfo.position, imageInfo.length);\r\n        }\r\n    }\r\n\r\n    return imageData;\r\n}\r\n\r\n/**\r\n * Creates the ArrayBufferViews used for initializing environment texture image data.\r\n * @param data the image data\r\n * @param info parameters that determine what views will be created for accessing the underlying buffer\r\n * @returns the views described by info providing access to the underlying buffer\r\n */\r\nexport function CreateIrradianceImageDataArrayBufferViews(data: ArrayBufferView, info: EnvironmentTextureInfo): Array<ArrayBufferView> {\r\n    info = normalizeEnvInfo(info);\r\n\r\n    const imageData = new Array<ArrayBufferView>(6);\r\n\r\n    const irradianceTexture = info.irradiance?.irradianceTexture;\r\n    if (irradianceTexture) {\r\n        if (irradianceTexture.faces.length !== 6) {\r\n            throw new Error(`Incorrect irradiance texture faces number \"${irradianceTexture.faces.length}\"`);\r\n        }\r\n\r\n        for (let face = 0; face < 6; face++) {\r\n            const imageInfo = irradianceTexture.faces[face];\r\n            imageData[face] = new Uint8Array(data.buffer, data.byteOffset + info.binaryDataPosition! + imageInfo.position, imageInfo.length);\r\n        }\r\n    }\r\n\r\n    return imageData;\r\n}\r\n\r\n/**\r\n * Uploads the texture info contained in the env file to the GPU.\r\n * @param texture defines the internal texture to upload to\r\n * @param data defines the data to load\r\n * @param info defines the texture info retrieved through the GetEnvInfo method\r\n * @returns a promise\r\n */\r\nexport function UploadEnvLevelsAsync(texture: InternalTexture, data: ArrayBufferView, info: EnvironmentTextureInfo): Promise<void[]> {\r\n    info = normalizeEnvInfo(info);\r\n\r\n    const specularInfo = info.specular as EnvironmentTextureSpecularInfoV1;\r\n    if (!specularInfo) {\r\n        // Nothing else parsed so far\r\n        return Promise.resolve([]);\r\n    }\r\n\r\n    texture._lodGenerationScale = specularInfo.lodGenerationScale;\r\n\r\n    const promises: Promise<void>[] = [];\r\n\r\n    const radianceImageData = CreateRadianceImageDataArrayBufferViews(data, info);\r\n    promises.push(UploadRadianceLevelsAsync(texture, radianceImageData, info.imageType));\r\n\r\n    const irradianceTexture = info.irradiance?.irradianceTexture;\r\n    if (irradianceTexture) {\r\n        const irradianceImageData = CreateIrradianceImageDataArrayBufferViews(data, info);\r\n        promises.push(UploadIrradianceLevelsAsync(texture, irradianceImageData, irradianceTexture.size, info.imageType));\r\n    }\r\n\r\n    return Promise.all(promises);\r\n}\r\n\r\nfunction _OnImageReadyAsync(\r\n    image: HTMLImageElement | ImageBitmap,\r\n    engine: Engine | WebGPUEngine,\r\n    expandTexture: boolean,\r\n    rgbdPostProcess: Nullable<PostProcess>,\r\n    url: string,\r\n    face: number,\r\n    i: number,\r\n    generateNonLODTextures: boolean,\r\n    lodTextures: Nullable<{ [lod: number]: BaseTexture }>,\r\n    cubeRtt: Nullable<RenderTargetWrapper>,\r\n    texture: InternalTexture\r\n): Promise<void> {\r\n    return new Promise((resolve, reject) => {\r\n        if (expandTexture) {\r\n            const tempTexture = engine.createTexture(\r\n                null,\r\n                true,\r\n                true,\r\n                null,\r\n                Constants.TEXTURE_NEAREST_SAMPLINGMODE,\r\n                null,\r\n                (message) => {\r\n                    reject(message);\r\n                },\r\n                image\r\n            );\r\n\r\n            rgbdPostProcess?.onEffectCreatedObservable.addOnce((effect) => {\r\n                effect.executeWhenCompiled(() => {\r\n                    // Uncompress the data to a RTT\r\n                    rgbdPostProcess!.externalTextureSamplerBinding = true;\r\n                    rgbdPostProcess!.onApply = (effect) => {\r\n                        effect._bindTexture(\"textureSampler\", tempTexture);\r\n                        effect.setFloat2(\"scale\", 1, engine._features.needsInvertingBitmap && image instanceof ImageBitmap ? -1 : 1);\r\n                    };\r\n\r\n                    if (!engine.scenes.length) {\r\n                        return;\r\n                    }\r\n\r\n                    engine.scenes[0].postProcessManager.directRender([rgbdPostProcess!], cubeRtt, true, face, i);\r\n\r\n                    // Cleanup\r\n                    engine.restoreDefaultFramebuffer();\r\n                    tempTexture.dispose();\r\n                    URL.revokeObjectURL(url);\r\n                    resolve();\r\n                });\r\n            });\r\n        } else {\r\n            engine._uploadImageToTexture(texture, image, face, i);\r\n\r\n            // Upload the face to the non lod texture support\r\n            if (generateNonLODTextures) {\r\n                const lodTexture = lodTextures![i];\r\n                if (lodTexture) {\r\n                    engine._uploadImageToTexture(lodTexture._texture!, image, face, 0);\r\n                }\r\n            }\r\n            resolve();\r\n        }\r\n    });\r\n}\r\n\r\n/**\r\n * Uploads the levels of image data to the GPU.\r\n * @param texture defines the internal texture to upload to\r\n * @param imageData defines the array buffer views of image data [mipmap][face]\r\n * @param imageType the mime type of the image data\r\n * @returns a promise\r\n */\r\nexport async function UploadRadianceLevelsAsync(texture: InternalTexture, imageData: ArrayBufferView[][], imageType: string = DefaultEnvironmentTextureImageType): Promise<void> {\r\n    const engine = texture.getEngine() as Engine;\r\n    texture.format = Constants.TEXTUREFORMAT_RGBA;\r\n    texture.type = Constants.TEXTURETYPE_UNSIGNED_BYTE;\r\n    texture.generateMipMaps = true;\r\n    texture._cachedAnisotropicFilteringLevel = null;\r\n    engine.updateTextureSamplingMode(Constants.TEXTURE_TRILINEAR_SAMPLINGMODE, texture);\r\n\r\n    await _UploadLevelsAsync(texture, imageData, true, imageType);\r\n\r\n    // Flag internal texture as ready in case they are in use.\r\n    texture.isReady = true;\r\n}\r\n\r\n/**\r\n * Uploads the levels of image data to the GPU.\r\n * @param mainTexture defines the internal texture to upload to\r\n * @param imageData defines the array buffer views of image data [mipmap][face]\r\n * @param size defines the size of the texture faces\r\n * @param imageType the mime type of the image data\r\n * @returns a promise\r\n */\r\nexport async function UploadIrradianceLevelsAsync(\r\n    mainTexture: InternalTexture,\r\n    imageData: ArrayBufferView[],\r\n    size: number,\r\n    imageType: string = DefaultEnvironmentTextureImageType\r\n): Promise<void> {\r\n    // Gets everything ready.\r\n    const engine = mainTexture.getEngine() as Engine;\r\n    const texture = new InternalTexture(engine, InternalTextureSource.RenderTarget);\r\n    const baseTexture = new BaseTexture(engine, texture);\r\n    mainTexture._irradianceTexture = baseTexture;\r\n\r\n    texture.isCube = true;\r\n    texture.format = Constants.TEXTUREFORMAT_RGBA;\r\n    texture.type = Constants.TEXTURETYPE_UNSIGNED_BYTE;\r\n    texture.generateMipMaps = true;\r\n    texture._cachedAnisotropicFilteringLevel = null;\r\n    texture.generateMipMaps = true;\r\n    texture.width = size;\r\n    texture.height = size;\r\n    engine.updateTextureSamplingMode(Constants.TEXTURE_TRILINEAR_SAMPLINGMODE, texture);\r\n\r\n    await _UploadLevelsAsync(texture, [imageData], false, imageType);\r\n\r\n    engine.generateMipMapsForCubemap(texture);\r\n\r\n    // Flag internal texture as ready in case they are in use.\r\n    texture.isReady = true;\r\n}\r\n\r\n/**\r\n * Uploads the levels of image data to the GPU.\r\n * @param texture defines the internal texture to upload to\r\n * @param imageData defines the array buffer views of image data [mipmap][face]\r\n * @param canGenerateNonLODTextures defines whether or not to generate non lod textures\r\n * @param imageType the mime type of the image data\r\n * @returns a promise\r\n */\r\nasync function _UploadLevelsAsync(\r\n    texture: InternalTexture,\r\n    imageData: ArrayBufferView[][],\r\n    canGenerateNonLODTextures: boolean,\r\n    imageType: string = DefaultEnvironmentTextureImageType\r\n) {\r\n    if (!Tools.IsExponentOfTwo(texture.width)) {\r\n        throw new Error(\"Texture size must be a power of two\");\r\n    }\r\n\r\n    const mipmapsCount = ILog2(texture.width) + 1;\r\n\r\n    // Gets everything ready.\r\n    const engine = texture.getEngine() as Engine;\r\n    let expandTexture = false;\r\n    let generateNonLODTextures = false;\r\n    let rgbdPostProcess: Nullable<PostProcess> = null;\r\n    let cubeRtt: Nullable<RenderTargetWrapper> = null;\r\n    let lodTextures: Nullable<{ [lod: number]: BaseTexture }> = null;\r\n    const caps = engine.getCaps();\r\n\r\n    if (!caps.textureLOD) {\r\n        expandTexture = false;\r\n        generateNonLODTextures = canGenerateNonLODTextures;\r\n    } else if (!engine._features.supportRenderAndCopyToLodForFloatTextures) {\r\n        expandTexture = false;\r\n    }\r\n    // If half float available we can uncompress the texture\r\n    else if (caps.textureHalfFloatRender && caps.textureHalfFloatLinearFiltering) {\r\n        expandTexture = true;\r\n        texture.type = Constants.TEXTURETYPE_HALF_FLOAT;\r\n    }\r\n    // If full float available we can uncompress the texture\r\n    else if (caps.textureFloatRender && caps.textureFloatLinearFiltering) {\r\n        expandTexture = true;\r\n        texture.type = Constants.TEXTURETYPE_FLOAT;\r\n    }\r\n\r\n    // Expand the texture if possible\r\n    let shaderLanguage = ShaderLanguage.GLSL;\r\n    if (expandTexture) {\r\n        if (engine.isWebGPU) {\r\n            shaderLanguage = ShaderLanguage.WGSL;\r\n            await import(\"../ShadersWGSL/rgbdDecode.fragment\");\r\n        } else {\r\n            await import(\"../Shaders/rgbdDecode.fragment\");\r\n        }\r\n\r\n        // Simply run through the decode PP\r\n        rgbdPostProcess = new PostProcess(\r\n            \"rgbdDecode\",\r\n            \"rgbdDecode\",\r\n            null,\r\n            null,\r\n            1,\r\n            null,\r\n            Constants.TEXTURE_TRILINEAR_SAMPLINGMODE,\r\n            engine,\r\n            false,\r\n            undefined,\r\n            texture.type,\r\n            undefined,\r\n            null,\r\n            false,\r\n            undefined,\r\n            shaderLanguage\r\n        );\r\n\r\n        texture._isRGBD = false;\r\n        texture.invertY = false;\r\n        cubeRtt = engine.createRenderTargetCubeTexture(texture.width, {\r\n            generateDepthBuffer: false,\r\n            generateMipMaps: true,\r\n            generateStencilBuffer: false,\r\n            samplingMode: Constants.TEXTURE_TRILINEAR_SAMPLINGMODE,\r\n            type: texture.type,\r\n            format: Constants.TEXTUREFORMAT_RGBA,\r\n        });\r\n    } else {\r\n        texture._isRGBD = true;\r\n        texture.invertY = true;\r\n\r\n        // In case of missing support, applies the same patch than DDS files.\r\n        if (generateNonLODTextures) {\r\n            const mipSlices = 3;\r\n            lodTextures = {};\r\n            const scale = texture._lodGenerationScale;\r\n            const offset = texture._lodGenerationOffset;\r\n\r\n            for (let i = 0; i < mipSlices; i++) {\r\n                //compute LOD from even spacing in smoothness (matching shader calculation)\r\n                const smoothness = i / (mipSlices - 1);\r\n                const roughness = 1 - smoothness;\r\n\r\n                const minLODIndex = offset; // roughness = 0\r\n                const maxLODIndex = (mipmapsCount - 1) * scale + offset; // roughness = 1 (mipmaps start from 0)\r\n\r\n                const lodIndex = minLODIndex + (maxLODIndex - minLODIndex) * roughness;\r\n                const mipmapIndex = Math.round(Math.min(Math.max(lodIndex, 0), maxLODIndex));\r\n\r\n                //compute LOD from even spacing in smoothness (matching shader calculation)\r\n                const glTextureFromLod = new InternalTexture(engine, InternalTextureSource.Temp);\r\n                glTextureFromLod.isCube = true;\r\n                glTextureFromLod.invertY = true;\r\n                glTextureFromLod.generateMipMaps = false;\r\n                engine.updateTextureSamplingMode(Constants.TEXTURE_LINEAR_LINEAR, glTextureFromLod);\r\n\r\n                // Wrap in a base texture for easy binding.\r\n                const lodTexture = new BaseTexture(null);\r\n                lodTexture._isCube = true;\r\n                lodTexture._texture = glTextureFromLod;\r\n                lodTextures![mipmapIndex] = lodTexture;\r\n\r\n                switch (i) {\r\n                    case 0:\r\n                        texture._lodTextureLow = lodTexture;\r\n                        break;\r\n                    case 1:\r\n                        texture._lodTextureMid = lodTexture;\r\n                        break;\r\n                    case 2:\r\n                        texture._lodTextureHigh = lodTexture;\r\n                        break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    const promises: Promise<void>[] = [];\r\n    // All mipmaps up to provided number of images\r\n    for (let i = 0; i < imageData.length; i++) {\r\n        // All faces\r\n        for (let face = 0; face < 6; face++) {\r\n            // Constructs an image element from image data\r\n            const bytes = imageData[i][face];\r\n            const blob = new Blob([bytes], { type: imageType });\r\n            const url = URL.createObjectURL(blob);\r\n            let promise: Promise<void>;\r\n\r\n            if (engine._features.forceBitmapOverHTMLImageElement) {\r\n                promise = engine.createImageBitmap(blob, { premultiplyAlpha: \"none\" }).then((img) => {\r\n                    return _OnImageReadyAsync(img, engine, expandTexture, rgbdPostProcess, url, face, i, generateNonLODTextures, lodTextures, cubeRtt, texture);\r\n                });\r\n            } else {\r\n                const image = new Image();\r\n                image.src = url;\r\n\r\n                // Enqueue promise to upload to the texture.\r\n                promise = new Promise<void>((resolve, reject) => {\r\n                    image.onload = () => {\r\n                        _OnImageReadyAsync(image, engine, expandTexture, rgbdPostProcess, url, face, i, generateNonLODTextures, lodTextures, cubeRtt, texture)\r\n                            .then(() => resolve())\r\n                            .catch((reason) => {\r\n                                reject(reason);\r\n                            });\r\n                    };\r\n                    image.onerror = (error) => {\r\n                        reject(error);\r\n                    };\r\n                });\r\n            }\r\n            promises.push(promise);\r\n        }\r\n    }\r\n\r\n    await Promise.all(promises);\r\n\r\n    // Fill remaining mipmaps with black textures.\r\n    if (imageData.length < mipmapsCount) {\r\n        let data: ArrayBufferView;\r\n        const size = Math.pow(2, mipmapsCount - 1 - imageData.length);\r\n        const dataLength = size * size * 4;\r\n        switch (texture.type) {\r\n            case Constants.TEXTURETYPE_UNSIGNED_BYTE: {\r\n                data = new Uint8Array(dataLength);\r\n                break;\r\n            }\r\n            case Constants.TEXTURETYPE_HALF_FLOAT: {\r\n                data = new Uint16Array(dataLength);\r\n                break;\r\n            }\r\n            case Constants.TEXTURETYPE_FLOAT: {\r\n                data = new Float32Array(dataLength);\r\n                break;\r\n            }\r\n        }\r\n        for (let i = imageData.length; i < mipmapsCount; i++) {\r\n            for (let face = 0; face < 6; face++) {\r\n                engine._uploadArrayBufferViewToTexture(cubeRtt?.texture || texture, data!, face, i);\r\n            }\r\n        }\r\n    }\r\n\r\n    // Release temp RTT.\r\n    if (cubeRtt) {\r\n        const irradiance = texture._irradianceTexture;\r\n        texture._irradianceTexture = null;\r\n        engine._releaseTexture(texture);\r\n        cubeRtt._swapAndDie(texture);\r\n        texture._irradianceTexture = irradiance;\r\n    }\r\n    // Release temp Post Process.\r\n    if (rgbdPostProcess) {\r\n        rgbdPostProcess.dispose();\r\n    }\r\n    // Flag internal texture as ready in case they are in use.\r\n    if (generateNonLODTextures) {\r\n        if (texture._lodTextureHigh && texture._lodTextureHigh._texture) {\r\n            texture._lodTextureHigh._texture.isReady = true;\r\n        }\r\n        if (texture._lodTextureMid && texture._lodTextureMid._texture) {\r\n            texture._lodTextureMid._texture.isReady = true;\r\n        }\r\n        if (texture._lodTextureLow && texture._lodTextureLow._texture) {\r\n            texture._lodTextureLow._texture.isReady = true;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Uploads spherical polynomials information to the texture.\r\n * @param texture defines the texture we are trying to upload the information to\r\n * @param info defines the environment texture info retrieved through the GetEnvInfo method\r\n */\r\nexport function UploadEnvSpherical(texture: InternalTexture, info: EnvironmentTextureInfo): void {\r\n    info = normalizeEnvInfo(info);\r\n\r\n    const irradianceInfo = info.irradiance as EnvironmentTextureIrradianceInfoV1;\r\n    if (!irradianceInfo) {\r\n        return;\r\n    }\r\n\r\n    const sp = new SphericalPolynomial();\r\n    Vector3.FromArrayToRef(irradianceInfo.x, 0, sp.x);\r\n    Vector3.FromArrayToRef(irradianceInfo.y, 0, sp.y);\r\n    Vector3.FromArrayToRef(irradianceInfo.z, 0, sp.z);\r\n    Vector3.FromArrayToRef(irradianceInfo.xx, 0, sp.xx);\r\n    Vector3.FromArrayToRef(irradianceInfo.yy, 0, sp.yy);\r\n    Vector3.FromArrayToRef(irradianceInfo.zz, 0, sp.zz);\r\n    Vector3.FromArrayToRef(irradianceInfo.yz, 0, sp.yz);\r\n    Vector3.FromArrayToRef(irradianceInfo.zx, 0, sp.zx);\r\n    Vector3.FromArrayToRef(irradianceInfo.xy, 0, sp.xy);\r\n    texture._sphericalPolynomial = sp;\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function _UpdateRGBDAsync(\r\n    internalTexture: InternalTexture,\r\n    data: ArrayBufferView[][],\r\n    sphericalPolynomial: Nullable<SphericalPolynomial>,\r\n    lodScale: number,\r\n    lodOffset: number\r\n): Promise<InternalTexture> {\r\n    const proxy = internalTexture\r\n        .getEngine()\r\n        .createRawCubeTexture(\r\n            null,\r\n            internalTexture.width,\r\n            internalTexture.format,\r\n            internalTexture.type,\r\n            internalTexture.generateMipMaps,\r\n            internalTexture.invertY,\r\n            internalTexture.samplingMode,\r\n            internalTexture._compression\r\n        );\r\n    const proxyPromise = UploadRadianceLevelsAsync(proxy, data).then(() => internalTexture);\r\n    internalTexture.onRebuildCallback = (_internalTexture) => {\r\n        return {\r\n            proxy: proxyPromise,\r\n            isReady: true,\r\n            isAsync: true,\r\n        };\r\n    };\r\n    internalTexture._source = InternalTextureSource.CubeRawRGBD;\r\n    internalTexture._bufferViewArrayArray = data;\r\n    internalTexture._lodGenerationScale = lodScale;\r\n    internalTexture._lodGenerationOffset = lodOffset;\r\n    internalTexture._sphericalPolynomial = sphericalPolynomial;\r\n\r\n    return UploadRadianceLevelsAsync(internalTexture, data).then(() => {\r\n        internalTexture.isReady = true;\r\n        return internalTexture;\r\n    });\r\n}\r\n\r\n/**\r\n * Sets of helpers addressing the serialization and deserialization of environment texture\r\n * stored in a BabylonJS env file.\r\n * Those files are usually stored as .env files.\r\n */\r\nexport const EnvironmentTextureTools = {\r\n    /**\r\n     * Gets the environment info from an env file.\r\n     * @param data The array buffer containing the .env bytes.\r\n     * @returns the environment file info (the json header) if successfully parsed, normalized to the latest supported version.\r\n     */\r\n    GetEnvInfo,\r\n\r\n    /**\r\n     * Creates an environment texture from a loaded cube texture.\r\n     * @param texture defines the cube texture to convert in env file\r\n     * @param options options for the conversion process\r\n     * @param options.imageType the mime type for the encoded images, with support for \"image/png\" (default) and \"image/webp\"\r\n     * @param options.imageQuality the image quality of encoded WebP images.\r\n     * @returns a promise containing the environment data if successful.\r\n     */\r\n    CreateEnvTextureAsync,\r\n\r\n    /**\r\n     * Creates the ArrayBufferViews used for initializing environment texture image data.\r\n     * @param data the image data\r\n     * @param info parameters that determine what views will be created for accessing the underlying buffer\r\n     * @returns the views described by info providing access to the underlying buffer\r\n     */\r\n    CreateRadianceImageDataArrayBufferViews,\r\n\r\n    /**\r\n     * Creates the ArrayBufferViews used for initializing environment texture image data.\r\n     * @param data the image data\r\n     * @param info parameters that determine what views will be created for accessing the underlying buffer\r\n     * @returns the views described by info providing access to the underlying buffer\r\n     */\r\n    CreateIrradianceImageDataArrayBufferViews,\r\n\r\n    /**\r\n     * Uploads the texture info contained in the env file to the GPU.\r\n     * @param texture defines the internal texture to upload to\r\n     * @param data defines the data to load\r\n     * @param info defines the texture info retrieved through the GetEnvInfo method\r\n     * @returns a promise\r\n     */\r\n    UploadEnvLevelsAsync,\r\n\r\n    /**\r\n     * Uploads the levels of image data to the GPU.\r\n     * @param texture defines the internal texture to upload to\r\n     * @param imageData defines the array buffer views of image data [mipmap][face]\r\n     * @param imageType the mime type of the image data\r\n     * @returns a promise\r\n     */\r\n    UploadRadianceLevelsAsync,\r\n\r\n    /**\r\n     * Uploads the levels of image data to the GPU.\r\n     * @param texture defines the internal texture to upload to\r\n     * @param imageData defines the array buffer views of image data [mipmap][face]\r\n     * @param imageType the mime type of the image data\r\n     * @returns a promise\r\n     */\r\n    UploadIrradianceLevelsAsync,\r\n\r\n    /**\r\n     * Uploads spherical polynomials information to the texture.\r\n     * @param texture defines the texture we are trying to upload the information to\r\n     * @param info defines the environment texture info retrieved through the GetEnvInfo method\r\n     */\r\n    UploadEnvSpherical,\r\n};\r\n","import { GetEnvInfo, UploadEnvLevelsAsync, UploadEnvSpherical } from \"../../../Misc/environmentTextureTools\";\r\nimport type { Nullable } from \"../../../types\";\r\nimport type { InternalTexture } from \"../../../Materials/Textures/internalTexture\";\r\nimport type { IInternalTextureLoader } from \"./internalTextureLoader\";\r\n\r\n/**\r\n * Implementation of the ENV Texture Loader.\r\n * @internal\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class _ENVTextureLoader implements IInternalTextureLoader {\r\n    /**\r\n     * Defines whether the loader supports cascade loading the different faces.\r\n     */\r\n    public readonly supportCascades = false;\r\n\r\n    /**\r\n     * Uploads the cube texture data to the WebGL texture. It has already been bound.\r\n     * @param data contains the texture data\r\n     * @param texture defines the BabylonJS internal texture\r\n     * @param createPolynomials will be true if polynomials have been requested\r\n     * @param onLoad defines the callback to trigger once the texture is ready\r\n     * @param onError defines the callback to trigger in case of error\r\n     */\r\n    public loadCubeData(\r\n        data: ArrayBufferView | ArrayBufferView[],\r\n        texture: InternalTexture,\r\n        createPolynomials: boolean,\r\n        onLoad: Nullable<(data?: any) => void>,\r\n        onError: Nullable<(message?: string, exception?: any) => void>\r\n    ): void {\r\n        if (Array.isArray(data)) {\r\n            return;\r\n        }\r\n\r\n        const info = GetEnvInfo(data);\r\n        if (info) {\r\n            texture.width = info.width;\r\n            texture.height = info.width;\r\n\r\n            try {\r\n                UploadEnvSpherical(texture, info);\r\n                UploadEnvLevelsAsync(texture, data, info).then(\r\n                    () => {\r\n                        texture.isReady = true;\r\n                        texture.onLoadedObservable.notifyObservers(texture);\r\n                        texture.onLoadedObservable.clear();\r\n                        if (onLoad) {\r\n                            onLoad();\r\n                        }\r\n                    },\r\n                    (reason) => {\r\n                        onError?.(\"Can not upload environment levels\", reason);\r\n                    }\r\n                );\r\n            } catch (e) {\r\n                onError?.(\"Can not upload environment file\", e);\r\n            }\r\n        } else if (onError) {\r\n            onError(\"Can not parse the environment file\", null);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Uploads the 2D texture data to the WebGL texture. It has already been bound once in the callback.\r\n     */\r\n    public loadData(): void {\r\n        // eslint-disable-next-line no-throw-literal\r\n        throw \".env not supported in 2d.\";\r\n    }\r\n}\r\n","import { Vector3 } from \"../../Maths/math.vector\";\r\nimport { Clamp } from \"../../Maths/math.scalar.functions\";\r\nimport { SphericalPolynomial, SphericalHarmonics } from \"../../Maths/sphericalPolynomial\";\r\nimport type { BaseTexture } from \"../../Materials/Textures/baseTexture\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { Constants } from \"../../Engines/constants\";\r\nimport type { CubeMapInfo } from \"./panoramaToCubemap\";\r\nimport { ToLinearSpace } from \"../../Maths/math.constants\";\r\nimport { Color3 } from \"../../Maths/math.color\";\r\n\r\nclass FileFaceOrientation {\r\n    public name: string;\r\n    public worldAxisForNormal: Vector3; // the world axis corresponding to the normal to the face\r\n    public worldAxisForFileX: Vector3; // the world axis corresponding to texture right x-axis in file\r\n    public worldAxisForFileY: Vector3; // the world axis corresponding to texture down y-axis in file\r\n\r\n    public constructor(name: string, worldAxisForNormal: Vector3, worldAxisForFileX: Vector3, worldAxisForFileY: Vector3) {\r\n        this.name = name;\r\n        this.worldAxisForNormal = worldAxisForNormal;\r\n        this.worldAxisForFileX = worldAxisForFileX;\r\n        this.worldAxisForFileY = worldAxisForFileY;\r\n    }\r\n}\r\n\r\n/**\r\n * Helper class dealing with the extraction of spherical polynomial dataArray\r\n * from a cube map.\r\n */\r\nexport class CubeMapToSphericalPolynomialTools {\r\n    private static _FileFaces: FileFaceOrientation[] = [\r\n        new FileFaceOrientation(\"right\", new Vector3(1, 0, 0), new Vector3(0, 0, -1), new Vector3(0, -1, 0)), // +X east\r\n        new FileFaceOrientation(\"left\", new Vector3(-1, 0, 0), new Vector3(0, 0, 1), new Vector3(0, -1, 0)), // -X west\r\n        new FileFaceOrientation(\"up\", new Vector3(0, 1, 0), new Vector3(1, 0, 0), new Vector3(0, 0, 1)), // +Y north\r\n        new FileFaceOrientation(\"down\", new Vector3(0, -1, 0), new Vector3(1, 0, 0), new Vector3(0, 0, -1)), // -Y south\r\n        new FileFaceOrientation(\"front\", new Vector3(0, 0, 1), new Vector3(1, 0, 0), new Vector3(0, -1, 0)), // +Z top\r\n        new FileFaceOrientation(\"back\", new Vector3(0, 0, -1), new Vector3(-1, 0, 0), new Vector3(0, -1, 0)), // -Z bottom\r\n    ];\r\n\r\n    /** @internal */\r\n    public static MAX_HDRI_VALUE = 4096;\r\n    /** @internal */\r\n    public static PRESERVE_CLAMPED_COLORS = false;\r\n\r\n    /**\r\n     * Converts a texture to the according Spherical Polynomial data.\r\n     * This extracts the first 3 orders only as they are the only one used in the lighting.\r\n     *\r\n     * @param texture The texture to extract the information from.\r\n     * @returns The Spherical Polynomial data.\r\n     */\r\n    public static ConvertCubeMapTextureToSphericalPolynomial(texture: BaseTexture): Nullable<Promise<SphericalPolynomial>> {\r\n        if (!texture.isCube) {\r\n            // Only supports cube Textures currently.\r\n            return null;\r\n        }\r\n\r\n        texture.getScene()?.getEngine().flushFramebuffer();\r\n\r\n        const size = texture.getSize().width;\r\n        const rightPromise = texture.readPixels(0, undefined, undefined, false);\r\n        const leftPromise = texture.readPixels(1, undefined, undefined, false);\r\n\r\n        let upPromise: Nullable<Promise<ArrayBufferView>>;\r\n        let downPromise: Nullable<Promise<ArrayBufferView>>;\r\n        if (texture.isRenderTarget) {\r\n            upPromise = texture.readPixels(3, undefined, undefined, false);\r\n            downPromise = texture.readPixels(2, undefined, undefined, false);\r\n        } else {\r\n            upPromise = texture.readPixels(2, undefined, undefined, false);\r\n            downPromise = texture.readPixels(3, undefined, undefined, false);\r\n        }\r\n\r\n        const frontPromise = texture.readPixels(4, undefined, undefined, false);\r\n        const backPromise = texture.readPixels(5, undefined, undefined, false);\r\n\r\n        const gammaSpace = texture.gammaSpace;\r\n        // Always read as RGBA.\r\n        const format = Constants.TEXTUREFORMAT_RGBA;\r\n        let type = Constants.TEXTURETYPE_UNSIGNED_BYTE;\r\n        if (texture.textureType == Constants.TEXTURETYPE_FLOAT || texture.textureType == Constants.TEXTURETYPE_HALF_FLOAT) {\r\n            type = Constants.TEXTURETYPE_FLOAT;\r\n        }\r\n\r\n        return new Promise((resolve) => {\r\n            Promise.all([leftPromise, rightPromise, upPromise, downPromise, frontPromise, backPromise]).then(([left, right, up, down, front, back]) => {\r\n                const cubeInfo: CubeMapInfo = {\r\n                    size,\r\n                    right,\r\n                    left,\r\n                    up,\r\n                    down,\r\n                    front,\r\n                    back,\r\n                    format,\r\n                    type,\r\n                    gammaSpace,\r\n                };\r\n\r\n                resolve(this.ConvertCubeMapToSphericalPolynomial(cubeInfo));\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Compute the area on the unit sphere of the rectangle defined by (x,y) and the origin\r\n     * See https://www.rorydriscoll.com/2012/01/15/cubemap-texel-solid-angle/\r\n     * @param x\r\n     * @param y\r\n     * @returns the area\r\n     */\r\n    private static _AreaElement(x: number, y: number): number {\r\n        return Math.atan2(x * y, Math.sqrt(x * x + y * y + 1));\r\n    }\r\n\r\n    /**\r\n     * Converts a cubemap to the according Spherical Polynomial data.\r\n     * This extracts the first 3 orders only as they are the only one used in the lighting.\r\n     *\r\n     * @param cubeInfo The Cube map to extract the information from.\r\n     * @returns The Spherical Polynomial data.\r\n     */\r\n    public static ConvertCubeMapToSphericalPolynomial(cubeInfo: CubeMapInfo): SphericalPolynomial {\r\n        const sphericalHarmonics = new SphericalHarmonics();\r\n        let totalSolidAngle = 0.0;\r\n\r\n        // The (u,v) range is [-1,+1], so the distance between each texel is 2/Size.\r\n        const du = 2.0 / cubeInfo.size;\r\n        const dv = du;\r\n\r\n        const halfTexel = 0.5 * du;\r\n\r\n        // The (u,v) of the first texel is half a texel from the corner (-1,-1).\r\n        const minUV = halfTexel - 1.0;\r\n\r\n        for (let faceIndex = 0; faceIndex < 6; faceIndex++) {\r\n            const fileFace = this._FileFaces[faceIndex];\r\n            const dataArray = (<any>cubeInfo)[fileFace.name];\r\n            let v = minUV;\r\n\r\n            // TODO: we could perform the summation directly into a SphericalPolynomial (SP), which is more efficient than SphericalHarmonic (SH).\r\n            // This is possible because during the summation we do not need the SH-specific properties, e.g. orthogonality.\r\n            // Because SP is still linear, so summation is fine in that basis.\r\n            const stride = cubeInfo.format === Constants.TEXTUREFORMAT_RGBA ? 4 : 3;\r\n            for (let y = 0; y < cubeInfo.size; y++) {\r\n                let u = minUV;\r\n\r\n                for (let x = 0; x < cubeInfo.size; x++) {\r\n                    // World direction (not normalised)\r\n                    const worldDirection = fileFace.worldAxisForFileX.scale(u).add(fileFace.worldAxisForFileY.scale(v)).add(fileFace.worldAxisForNormal);\r\n                    worldDirection.normalize();\r\n\r\n                    const deltaSolidAngle =\r\n                        this._AreaElement(u - halfTexel, v - halfTexel) -\r\n                        this._AreaElement(u - halfTexel, v + halfTexel) -\r\n                        this._AreaElement(u + halfTexel, v - halfTexel) +\r\n                        this._AreaElement(u + halfTexel, v + halfTexel);\r\n\r\n                    let r = dataArray[y * cubeInfo.size * stride + x * stride + 0];\r\n                    let g = dataArray[y * cubeInfo.size * stride + x * stride + 1];\r\n                    let b = dataArray[y * cubeInfo.size * stride + x * stride + 2];\r\n\r\n                    // Prevent NaN harmonics with extreme HDRI data.\r\n                    if (isNaN(r)) {\r\n                        r = 0;\r\n                    }\r\n                    if (isNaN(g)) {\r\n                        g = 0;\r\n                    }\r\n                    if (isNaN(b)) {\r\n                        b = 0;\r\n                    }\r\n\r\n                    // Handle Integer types.\r\n                    if (cubeInfo.type === Constants.TEXTURETYPE_UNSIGNED_BYTE) {\r\n                        r /= 255;\r\n                        g /= 255;\r\n                        b /= 255;\r\n                    }\r\n\r\n                    // Handle Gamma space textures.\r\n                    if (cubeInfo.gammaSpace) {\r\n                        r = Math.pow(Clamp(r), ToLinearSpace);\r\n                        g = Math.pow(Clamp(g), ToLinearSpace);\r\n                        b = Math.pow(Clamp(b), ToLinearSpace);\r\n                    }\r\n\r\n                    // Prevent to explode in case of really high dynamic ranges.\r\n                    // sh 3 would not be enough to accurately represent it.\r\n                    const max = this.MAX_HDRI_VALUE;\r\n                    if (this.PRESERVE_CLAMPED_COLORS) {\r\n                        const currentMax = Math.max(r, g, b);\r\n                        if (currentMax > max) {\r\n                            const factor = max / currentMax;\r\n                            r *= factor;\r\n                            g *= factor;\r\n                            b *= factor;\r\n                        }\r\n                    } else {\r\n                        r = Clamp(r, 0, max);\r\n                        g = Clamp(g, 0, max);\r\n                        b = Clamp(b, 0, max);\r\n                    }\r\n\r\n                    const color = new Color3(r, g, b);\r\n\r\n                    sphericalHarmonics.addLight(worldDirection, color, deltaSolidAngle);\r\n\r\n                    totalSolidAngle += deltaSolidAngle;\r\n\r\n                    u += du;\r\n                }\r\n\r\n                v += dv;\r\n            }\r\n        }\r\n\r\n        // Solid angle for entire sphere is 4*pi\r\n        const sphereSolidAngle = 4.0 * Math.PI;\r\n\r\n        // Adjust the solid angle to allow for how many faces we processed.\r\n        const facesProcessed = 6.0;\r\n        const expectedSolidAngle = (sphereSolidAngle * facesProcessed) / 6.0;\r\n\r\n        // Adjust the harmonics so that the accumulated solid angle matches the expected solid angle.\r\n        // This is needed because the numerical integration over the cube uses a\r\n        // small angle approximation of solid angle for each texel (see deltaSolidAngle),\r\n        // and also to compensate for accumulative error due to float precision in the summation.\r\n        const correctionFactor = expectedSolidAngle / totalSolidAngle;\r\n        sphericalHarmonics.scaleInPlace(correctionFactor);\r\n\r\n        sphericalHarmonics.convertIncidentRadianceToIrradiance();\r\n        sphericalHarmonics.convertIrradianceToLambertianRadiance();\r\n\r\n        return SphericalPolynomial.FromHarmonics(sphericalHarmonics);\r\n    }\r\n}\r\n","/* eslint-disable @typescript-eslint/no-unused-vars */\r\nimport { _WarnImport } from \"./devTools\";\r\n\r\nimport type { ThinEngine } from \"../Engines/thinEngine\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { EffectRenderer, EffectWrapper } from \"../Materials/effectRenderer\";\r\nimport { Tools } from \"./tools\";\r\nimport type { Nullable } from \"../types\";\r\nimport { Clamp } from \"../Maths/math.scalar.functions\";\r\nimport type { AbstractEngine } from \"../Engines/abstractEngine\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\n\r\ntype DumpToolsEngine = {\r\n    canvas: HTMLCanvasElement | OffscreenCanvas;\r\n    engine: ThinEngine;\r\n    renderer: EffectRenderer;\r\n    wrapper: EffectWrapper;\r\n};\r\n\r\nlet _dumpToolsEngine: Nullable<DumpToolsEngine>;\r\n\r\nlet _enginePromise: Promise<DumpToolsEngine> | null = null;\r\n\r\nasync function _CreateDumpRenderer(): Promise<DumpToolsEngine> {\r\n    if (!_enginePromise) {\r\n        _enginePromise = new Promise((resolve, reject) => {\r\n            let canvas: HTMLCanvasElement | OffscreenCanvas;\r\n            let engine: Nullable<ThinEngine> = null;\r\n            const options = {\r\n                preserveDrawingBuffer: true,\r\n                depth: false,\r\n                stencil: false,\r\n                alpha: true,\r\n                premultipliedAlpha: false,\r\n                antialias: false,\r\n                failIfMajorPerformanceCaveat: false,\r\n            };\r\n            import(\"../Engines/thinEngine\")\r\n                .then(({ ThinEngine: thinEngineClass }) => {\r\n                    const engineInstanceCount = EngineStore.Instances.length;\r\n                    try {\r\n                        canvas = new OffscreenCanvas(100, 100); // will be resized later\r\n                        engine = new thinEngineClass(canvas, false, options);\r\n                    } catch (e) {\r\n                        if (engineInstanceCount < EngineStore.Instances.length) {\r\n                            // The engine was created by another instance, let's use it\r\n                            EngineStore.Instances.pop()?.dispose();\r\n                        }\r\n                        // The browser either does not support OffscreenCanvas or WebGL context in OffscreenCanvas, fallback on a regular canvas\r\n                        canvas = document.createElement(\"canvas\");\r\n                        engine = new thinEngineClass(canvas, false, options);\r\n                    }\r\n                    // remove this engine from the list of instances to avoid using it for other purposes\r\n                    EngineStore.Instances.pop();\r\n                    // However, make sure to dispose it when no other engines are left\r\n                    EngineStore.OnEnginesDisposedObservable.add((e) => {\r\n                        // guaranteed to run when no other instances are left\r\n                        // only dispose if it's not the current engine\r\n                        if (engine && e !== engine && !engine.isDisposed && EngineStore.Instances.length === 0) {\r\n                            // Dump the engine and the associated resources\r\n                            Dispose();\r\n                        }\r\n                    });\r\n                    engine.getCaps().parallelShaderCompile = undefined;\r\n                    const renderer = new EffectRenderer(engine);\r\n                    import(\"../Shaders/pass.fragment\").then(({ passPixelShader }) => {\r\n                        if (!engine) {\r\n                            reject(\"Engine is not defined\");\r\n                            return;\r\n                        }\r\n                        const wrapper = new EffectWrapper({\r\n                            engine,\r\n                            name: passPixelShader.name,\r\n                            fragmentShader: passPixelShader.shader,\r\n                            samplerNames: [\"textureSampler\"],\r\n                        });\r\n                        _dumpToolsEngine = {\r\n                            canvas,\r\n                            engine,\r\n                            renderer,\r\n                            wrapper,\r\n                        };\r\n                        resolve(_dumpToolsEngine);\r\n                    });\r\n                })\r\n                .catch(reject);\r\n        });\r\n    }\r\n    return await _enginePromise;\r\n}\r\n\r\n/**\r\n * Dumps the current bound framebuffer\r\n * @param width defines the rendering width\r\n * @param height defines the rendering height\r\n * @param engine defines the hosting engine\r\n * @param successCallback defines the callback triggered once the data are available\r\n * @param mimeType defines the mime type of the result\r\n * @param fileName defines the filename to download. If present, the result will automatically be downloaded\r\n * @param quality The quality of the image if lossy mimeType is used (e.g. image/jpeg, image/webp). See {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob | HTMLCanvasElement.toBlob()}'s `quality` parameter.\r\n * @returns a void promise\r\n */\r\nexport async function DumpFramebuffer(\r\n    width: number,\r\n    height: number,\r\n    engine: AbstractEngine,\r\n    successCallback?: (data: string) => void,\r\n    mimeType = \"image/png\",\r\n    fileName?: string,\r\n    quality?: number\r\n) {\r\n    // Read the contents of the framebuffer\r\n    const bufferView = await engine.readPixels(0, 0, width, height);\r\n\r\n    const data = new Uint8Array(bufferView.buffer);\r\n\r\n    DumpData(width, height, data, successCallback as (data: string | ArrayBuffer) => void, mimeType, fileName, true, undefined, quality);\r\n}\r\n\r\n/**\r\n * Dumps an array buffer\r\n * @param width defines the rendering width\r\n * @param height defines the rendering height\r\n * @param data the data array\r\n * @param mimeType defines the mime type of the result\r\n * @param fileName defines the filename to download. If present, the result will automatically be downloaded\r\n * @param invertY true to invert the picture in the Y dimension\r\n * @param toArrayBuffer true to convert the data to an ArrayBuffer (encoded as `mimeType`) instead of a base64 string\r\n * @param quality The quality of the image if lossy mimeType is used (e.g. image/jpeg, image/webp). See {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob | HTMLCanvasElement.toBlob()}'s `quality` parameter.\r\n * @returns a promise that resolve to the final data\r\n */\r\nexport function DumpDataAsync(\r\n    width: number,\r\n    height: number,\r\n    data: ArrayBufferView,\r\n    mimeType = \"image/png\",\r\n    fileName?: string,\r\n    invertY = false,\r\n    toArrayBuffer = false,\r\n    quality?: number\r\n): Promise<string | ArrayBuffer> {\r\n    return new Promise((resolve) => {\r\n        DumpData(width, height, data, (result) => resolve(result), mimeType, fileName, invertY, toArrayBuffer, quality);\r\n    });\r\n}\r\n\r\n/**\r\n * Dumps an array buffer\r\n * @param width defines the rendering width\r\n * @param height defines the rendering height\r\n * @param data the data array\r\n * @param successCallback defines the callback triggered once the data are available\r\n * @param mimeType defines the mime type of the result\r\n * @param fileName defines the filename to download. If present, the result will automatically be downloaded\r\n * @param invertY true to invert the picture in the Y dimension\r\n * @param toArrayBuffer true to convert the data to an ArrayBuffer (encoded as `mimeType`) instead of a base64 string\r\n * @param quality The quality of the image if lossy mimeType is used (e.g. image/jpeg, image/webp). See {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob | HTMLCanvasElement.toBlob()}'s `quality` parameter.\r\n */\r\nexport function DumpData(\r\n    width: number,\r\n    height: number,\r\n    data: ArrayBufferView,\r\n    successCallback?: (data: string | ArrayBuffer) => void,\r\n    mimeType = \"image/png\",\r\n    fileName?: string,\r\n    invertY = false,\r\n    toArrayBuffer = false,\r\n    quality?: number\r\n): void {\r\n    _CreateDumpRenderer().then((renderer) => {\r\n        renderer.engine.setSize(width, height, true);\r\n\r\n        // Convert if data are float32\r\n        if (data instanceof Float32Array) {\r\n            const data2 = new Uint8Array(data.length);\r\n            let n = data.length;\r\n            while (n--) {\r\n                const v = data[n];\r\n                data2[n] = Math.round(Clamp(v) * 255);\r\n            }\r\n            data = data2;\r\n        }\r\n\r\n        // Create the image\r\n        const texture = renderer.engine.createRawTexture(data, width, height, Constants.TEXTUREFORMAT_RGBA, false, !invertY, Constants.TEXTURE_NEAREST_NEAREST);\r\n\r\n        renderer.renderer.setViewport();\r\n        renderer.renderer.applyEffectWrapper(renderer.wrapper);\r\n        renderer.wrapper.effect._bindTexture(\"textureSampler\", texture);\r\n        renderer.renderer.draw();\r\n\r\n        if (toArrayBuffer) {\r\n            Tools.ToBlob(\r\n                renderer.canvas,\r\n                (blob) => {\r\n                    const fileReader = new FileReader();\r\n                    fileReader.onload = (event: any) => {\r\n                        const arrayBuffer = event.target!.result as ArrayBuffer;\r\n                        if (successCallback) {\r\n                            successCallback(arrayBuffer);\r\n                        }\r\n                    };\r\n                    fileReader.readAsArrayBuffer(blob!);\r\n                },\r\n                mimeType,\r\n                quality\r\n            );\r\n        } else {\r\n            Tools.EncodeScreenshotCanvasData(renderer.canvas, successCallback, mimeType, fileName, quality);\r\n        }\r\n\r\n        texture.dispose();\r\n    });\r\n}\r\n\r\n/**\r\n * Dispose the dump tools associated resources\r\n */\r\nexport function Dispose() {\r\n    if (_dumpToolsEngine) {\r\n        _dumpToolsEngine.wrapper.dispose();\r\n        _dumpToolsEngine.renderer.dispose();\r\n        _dumpToolsEngine.engine.dispose();\r\n    } else {\r\n        // in cases where the engine is not yet created, we need to wait for it to dispose it\r\n        _enginePromise?.then((dumpToolsEngine) => {\r\n            dumpToolsEngine.wrapper.dispose();\r\n            dumpToolsEngine.renderer.dispose();\r\n            dumpToolsEngine.engine.dispose();\r\n        });\r\n    }\r\n    _enginePromise = null;\r\n    _dumpToolsEngine = null;\r\n}\r\n\r\n/**\r\n * Object containing a set of static utilities functions to dump data from a canvas\r\n * @deprecated use functions\r\n */\r\nexport const DumpTools = {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    DumpData,\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    DumpDataAsync,\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    DumpFramebuffer,\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    Dispose,\r\n};\r\n\r\n/**\r\n * This will be executed automatically for UMD and es5.\r\n * If esm dev wants the side effects to execute they will have to run it manually\r\n * Once we build native modules those need to be exported.\r\n * @internal\r\n */\r\nconst initSideEffects = () => {\r\n    // References the dependencies.\r\n    Tools.DumpData = DumpData;\r\n    Tools.DumpDataAsync = DumpDataAsync;\r\n    Tools.DumpFramebuffer = DumpFramebuffer;\r\n};\r\n\r\ninitSideEffects();\r\n"],"names":["prototype","forceSphericalPolynomialsRecompute","this","_texture","_sphericalPolynomial","_sphericalPolynomialPromise","_sphericalPolynomialComputed","Object","defineProperty","get","isReady","ConvertCubeMapTextureToSphericalPolynomial","then","sphericalPolynomial","set","value","enumerable","configurable","DefaultEnvironmentTextureImageType","MagicBytes","normalizeEnvInfo","info","version","Error","imageType","UploadEnvLevelsAsync","texture","data","specularInfo","specular","Promise","resolve","_lodGenerationScale","lodGenerationScale","promises","radianceImageData","mipmapsCount","Math","log2","width","round","mipmaps","length","imageData","Array","i","face","imageInfo","Uint8Array","buffer","byteOffset","binaryDataPosition","position","CreateRadianceImageDataArrayBufferViews","push","async","engine","getEngine","format","type","generateMipMaps","_cachedAnisotropicFilteringLevel","updateTextureSamplingMode","_UploadLevelsAsync","UploadRadianceLevelsAsync","irradianceTexture","irradiance","irradianceImageData","faces","CreateIrradianceImageDataArrayBufferViews","mainTexture","size","baseTexture","_irradianceTexture","isCube","height","generateMipMapsForCubemap","UploadIrradianceLevelsAsync","all","_OnImageReadyAsync","image","expandTexture","rgbdPostProcess","url","generateNonLODTextures","lodTextures","cubeRtt","reject","tempTexture","createTexture","message","onEffectCreatedObservable","addOnce","effect","executeWhenCompiled","externalTextureSamplerBinding","onApply","_bindTexture","setFloat2","_features","needsInvertingBitmap","ImageBitmap","scenes","postProcessManager","directRender","restoreDefaultFramebuffer","dispose","URL","revokeObjectURL","_uploadImageToTexture","lodTexture","canGenerateNonLODTextures","IsExponentOfTwo","caps","getCaps","textureLOD","supportRenderAndCopyToLodForFloatTextures","textureHalfFloatRender","textureHalfFloatLinearFiltering","textureFloatRender","textureFloatLinearFiltering","shaderLanguage","isWebGPU","_isRGBD","invertY","createRenderTargetCubeTexture","generateDepthBuffer","generateStencilBuffer","samplingMode","mipSlices","scale","offset","_lodGenerationOffset","maxLODIndex","lodIndex","mipmapIndex","min","max","glTextureFromLod","_isCube","_lodTextureLow","_lodTextureMid","_lodTextureHigh","bytes","blob","Blob","createObjectURL","promise","forceBitmapOverHTMLImageElement","createImageBitmap","premultiplyAlpha","img","Image","src","onload","catch","reason","onerror","error","pow","dataLength","Uint16Array","Float32Array","_uploadArrayBufferViewToTexture","_releaseTexture","_swapAndDie","_ENVTextureLoader","supportCascades","loadCubeData","createPolynomials","onLoad","onError","isArray","dataView","DataView","byteLength","pos","getUint8","manifestString","charCode","String","fromCharCode","manifest","JSON","parse","GetEnvInfo","irradianceInfo","sp","FromArrayToRef","x","y","z","xx","yy","zz","yz","zx","xy","UploadEnvSpherical","onLoadedObservable","notifyObservers","clear","e","loadData","FileFaceOrientation","name","worldAxisForNormal","worldAxisForFileX","worldAxisForFileY","CubeMapToSphericalPolynomialTools","getScene","flushFramebuffer","getSize","rightPromise","readPixels","undefined","leftPromise","upPromise","downPromise","isRenderTarget","frontPromise","backPromise","gammaSpace","textureType","left","right","up","down","front","back","cubeInfo","ConvertCubeMapToSphericalPolynomial","_AreaElement","atan2","sqrt","sphericalHarmonics","totalSolidAngle","du","dv","halfTexel","minUV","faceIndex","fileFace","_FileFaces","dataArray","v","stride","u","worldDirection","add","normalize","deltaSolidAngle","r","g","b","isNaN","MAX_HDRI_VALUE","PRESERVE_CLAMPED_COLORS","currentMax","factor","color","addLight","correctionFactor","PI","scaleInPlace","convertIncidentRadianceToIrradiance","convertIrradianceToLambertianRadiance","FromHarmonics","_dumpToolsEngine","_enginePromise","DumpFramebuffer","successCallback","mimeType","fileName","quality","bufferView","DumpData","DumpDataAsync","toArrayBuffer","result","canvas","options","preserveDrawingBuffer","depth","stencil","alpha","premultipliedAlpha","antialias","failIfMajorPerformanceCaveat","ThinEngine","thinEngineClass","engineInstanceCount","Instances","OffscreenCanvas","pop","document","createElement","OnEnginesDisposedObservable","isDisposed","Dispose","parallelShaderCompile","renderer","passPixelShader","wrapper","fragmentShader","shader","samplerNames","_CreateDumpRenderer","setSize","data2","n","createRawTexture","setViewport","applyEffectWrapper","draw","ToBlob","fileReader","FileReader","event","arrayBuffer","target","readAsArrayBuffer","EncodeScreenshotCanvasData","dumpToolsEngine","DumpTools"],"sourceRoot":""}