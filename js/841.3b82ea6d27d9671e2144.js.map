{"version":3,"file":"js/841.3b82ea6d27d9671e2144.js","mappings":"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","sources":["webpack://babylonjs-typescript-webpack-template/./dev/core/src/Misc/tga.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Materials/Textures/Loaders/tgaTextureLoader.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { InternalTexture } from \"../Materials/Textures/internalTexture\";\r\nimport { Logger } from \"../Misc/logger\";\r\n\r\n//private static _TYPE_NO_DATA = 0;\r\nconst _TYPE_INDEXED = 1;\r\nconst _TYPE_RGB = 2;\r\nconst _TYPE_GREY = 3;\r\nconst _TYPE_RLE_INDEXED = 9;\r\nconst _TYPE_RLE_RGB = 10;\r\nconst _TYPE_RLE_GREY = 11;\r\nconst _ORIGIN_MASK = 0x30;\r\nconst _ORIGIN_SHIFT = 0x04;\r\nconst _ORIGIN_BL = 0x00;\r\nconst _ORIGIN_BR = 0x01;\r\nconst _ORIGIN_UL = 0x02;\r\nconst _ORIGIN_UR = 0x03;\r\n\r\n/**\r\n * Gets the header of a TGA file\r\n * @param data defines the TGA data\r\n * @returns the header\r\n */\r\nexport function GetTGAHeader(data: Uint8Array): any {\r\n    let offset = 0;\r\n\r\n    const header = {\r\n        id_length: data[offset++],\r\n        colormap_type: data[offset++],\r\n        image_type: data[offset++],\r\n        colormap_index: data[offset++] | (data[offset++] << 8),\r\n        colormap_length: data[offset++] | (data[offset++] << 8),\r\n        colormap_size: data[offset++],\r\n        origin: [data[offset++] | (data[offset++] << 8), data[offset++] | (data[offset++] << 8)],\r\n        width: data[offset++] | (data[offset++] << 8),\r\n        height: data[offset++] | (data[offset++] << 8),\r\n        pixel_size: data[offset++],\r\n        flags: data[offset++],\r\n    };\r\n\r\n    return header;\r\n}\r\n\r\n/**\r\n * Uploads TGA content to a Babylon Texture\r\n * @internal\r\n */\r\nexport function UploadContent(texture: InternalTexture, data: Uint8Array): void {\r\n    // Not enough data to contain header ?\r\n    if (data.length < 19) {\r\n        Logger.Error(\"Unable to load TGA file - Not enough data to contain header\");\r\n        return;\r\n    }\r\n\r\n    // Read Header\r\n    let offset = 18;\r\n    const header = GetTGAHeader(data);\r\n\r\n    // Assume it's a valid Targa file.\r\n    if (header.id_length + offset > data.length) {\r\n        Logger.Error(\"Unable to load TGA file - Not enough data\");\r\n        return;\r\n    }\r\n\r\n    // Skip not needed data\r\n    offset += header.id_length;\r\n\r\n    let use_rle = false;\r\n    let use_pal = false;\r\n    let use_grey = false;\r\n\r\n    // Get some informations.\r\n    switch (header.image_type) {\r\n        case _TYPE_RLE_INDEXED:\r\n            use_rle = true;\r\n        // eslint-disable-next-line no-fallthrough\r\n        case _TYPE_INDEXED:\r\n            use_pal = true;\r\n            break;\r\n\r\n        case _TYPE_RLE_RGB:\r\n            use_rle = true;\r\n        // eslint-disable-next-line no-fallthrough\r\n        case _TYPE_RGB:\r\n            // use_rgb = true;\r\n            break;\r\n\r\n        case _TYPE_RLE_GREY:\r\n            use_rle = true;\r\n        // eslint-disable-next-line no-fallthrough\r\n        case _TYPE_GREY:\r\n            use_grey = true;\r\n            break;\r\n    }\r\n\r\n    let pixel_data;\r\n\r\n    // var numAlphaBits = header.flags & 0xf;\r\n    const pixel_size = header.pixel_size >> 3;\r\n    const pixel_total = header.width * header.height * pixel_size;\r\n\r\n    // Read palettes\r\n    let palettes;\r\n\r\n    if (use_pal) {\r\n        palettes = data.subarray(offset, (offset += header.colormap_length * (header.colormap_size >> 3)));\r\n    }\r\n\r\n    // Read LRE\r\n    if (use_rle) {\r\n        pixel_data = new Uint8Array(pixel_total);\r\n\r\n        let c, count, i;\r\n        let localOffset = 0;\r\n        const pixels = new Uint8Array(pixel_size);\r\n\r\n        while (offset < pixel_total && localOffset < pixel_total) {\r\n            c = data[offset++];\r\n            count = (c & 0x7f) + 1;\r\n\r\n            // RLE pixels\r\n            if (c & 0x80) {\r\n                // Bind pixel tmp array\r\n                for (i = 0; i < pixel_size; ++i) {\r\n                    pixels[i] = data[offset++];\r\n                }\r\n\r\n                // Copy pixel array\r\n                for (i = 0; i < count; ++i) {\r\n                    pixel_data.set(pixels, localOffset + i * pixel_size);\r\n                }\r\n\r\n                localOffset += pixel_size * count;\r\n            }\r\n            // Raw pixels\r\n            else {\r\n                count *= pixel_size;\r\n                for (i = 0; i < count; ++i) {\r\n                    pixel_data[localOffset + i] = data[offset++];\r\n                }\r\n                localOffset += count;\r\n            }\r\n        }\r\n    }\r\n    // RAW Pixels\r\n    else {\r\n        pixel_data = data.subarray(offset, (offset += use_pal ? header.width * header.height : pixel_total));\r\n    }\r\n\r\n    // Load to texture\r\n    let x_start, y_start, x_step, y_step, y_end, x_end;\r\n\r\n    switch ((header.flags & _ORIGIN_MASK) >> _ORIGIN_SHIFT) {\r\n        default:\r\n        case _ORIGIN_UL:\r\n            x_start = 0;\r\n            x_step = 1;\r\n            x_end = header.width;\r\n            y_start = 0;\r\n            y_step = 1;\r\n            y_end = header.height;\r\n            break;\r\n\r\n        case _ORIGIN_BL:\r\n            x_start = 0;\r\n            x_step = 1;\r\n            x_end = header.width;\r\n            y_start = header.height - 1;\r\n            y_step = -1;\r\n            y_end = -1;\r\n            break;\r\n\r\n        case _ORIGIN_UR:\r\n            x_start = header.width - 1;\r\n            x_step = -1;\r\n            x_end = -1;\r\n            y_start = 0;\r\n            y_step = 1;\r\n            y_end = header.height;\r\n            break;\r\n\r\n        case _ORIGIN_BR:\r\n            x_start = header.width - 1;\r\n            x_step = -1;\r\n            x_end = -1;\r\n            y_start = header.height - 1;\r\n            y_step = -1;\r\n            y_end = -1;\r\n            break;\r\n    }\r\n\r\n    // Load the specify method\r\n    const func = \"_getImageData\" + (use_grey ? \"Grey\" : \"\") + header.pixel_size + \"bits\";\r\n    const imageData = (<any>TGATools)[func](header, palettes, pixel_data, y_start, y_step, y_end, x_start, x_step, x_end);\r\n\r\n    const engine = texture.getEngine();\r\n    engine._uploadDataToTextureDirectly(texture, imageData);\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nfunction _getImageData8bits(\r\n    header: any,\r\n    palettes: Uint8Array,\r\n    pixel_data: Uint8Array,\r\n    y_start: number,\r\n    y_step: number,\r\n    y_end: number,\r\n    x_start: number,\r\n    x_step: number,\r\n    x_end: number\r\n): Uint8Array {\r\n    const image = pixel_data,\r\n        colormap = palettes;\r\n    const width = header.width,\r\n        height = header.height;\r\n    let color,\r\n        i = 0,\r\n        x,\r\n        y;\r\n\r\n    const imageData = new Uint8Array(width * height * 4);\r\n\r\n    for (y = y_start; y !== y_end; y += y_step) {\r\n        for (x = x_start; x !== x_end; x += x_step, i++) {\r\n            color = image[i];\r\n            imageData[(x + width * y) * 4 + 3] = 255;\r\n            imageData[(x + width * y) * 4 + 2] = colormap[color * 3 + 0];\r\n            imageData[(x + width * y) * 4 + 1] = colormap[color * 3 + 1];\r\n            imageData[(x + width * y) * 4 + 0] = colormap[color * 3 + 2];\r\n        }\r\n    }\r\n\r\n    return imageData;\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nfunction _getImageData16bits(\r\n    header: any,\r\n    palettes: Uint8Array,\r\n    pixel_data: Uint8Array,\r\n    y_start: number,\r\n    y_step: number,\r\n    y_end: number,\r\n    x_start: number,\r\n    x_step: number,\r\n    x_end: number\r\n): Uint8Array {\r\n    const image = pixel_data;\r\n    const width = header.width,\r\n        height = header.height;\r\n    let color,\r\n        i = 0,\r\n        x,\r\n        y;\r\n\r\n    const imageData = new Uint8Array(width * height * 4);\r\n\r\n    for (y = y_start; y !== y_end; y += y_step) {\r\n        for (x = x_start; x !== x_end; x += x_step, i += 2) {\r\n            color = image[i + 0] + (image[i + 1] << 8); // Inversed ?\r\n            const r = ((((color & 0x7c00) >> 10) * 255) / 0x1f) | 0;\r\n            const g = ((((color & 0x03e0) >> 5) * 255) / 0x1f) | 0;\r\n            const b = (((color & 0x001f) * 255) / 0x1f) | 0;\r\n\r\n            imageData[(x + width * y) * 4 + 0] = r;\r\n            imageData[(x + width * y) * 4 + 1] = g;\r\n            imageData[(x + width * y) * 4 + 2] = b;\r\n            imageData[(x + width * y) * 4 + 3] = color & 0x8000 ? 0 : 255;\r\n        }\r\n    }\r\n\r\n    return imageData;\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nfunction _getImageData24bits(\r\n    header: any,\r\n    palettes: Uint8Array,\r\n    pixel_data: Uint8Array,\r\n    y_start: number,\r\n    y_step: number,\r\n    y_end: number,\r\n    x_start: number,\r\n    x_step: number,\r\n    x_end: number\r\n): Uint8Array {\r\n    const image = pixel_data;\r\n    const width = header.width,\r\n        height = header.height;\r\n    let i = 0,\r\n        x,\r\n        y;\r\n\r\n    const imageData = new Uint8Array(width * height * 4);\r\n\r\n    for (y = y_start; y !== y_end; y += y_step) {\r\n        for (x = x_start; x !== x_end; x += x_step, i += 3) {\r\n            imageData[(x + width * y) * 4 + 3] = 255;\r\n            imageData[(x + width * y) * 4 + 2] = image[i + 0];\r\n            imageData[(x + width * y) * 4 + 1] = image[i + 1];\r\n            imageData[(x + width * y) * 4 + 0] = image[i + 2];\r\n        }\r\n    }\r\n\r\n    return imageData;\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nfunction _getImageData32bits(\r\n    header: any,\r\n    palettes: Uint8Array,\r\n    pixel_data: Uint8Array,\r\n    y_start: number,\r\n    y_step: number,\r\n    y_end: number,\r\n    x_start: number,\r\n    x_step: number,\r\n    x_end: number\r\n): Uint8Array {\r\n    const image = pixel_data;\r\n    const width = header.width,\r\n        height = header.height;\r\n    let i = 0,\r\n        x,\r\n        y;\r\n\r\n    const imageData = new Uint8Array(width * height * 4);\r\n\r\n    for (y = y_start; y !== y_end; y += y_step) {\r\n        for (x = x_start; x !== x_end; x += x_step, i += 4) {\r\n            imageData[(x + width * y) * 4 + 2] = image[i + 0];\r\n            imageData[(x + width * y) * 4 + 1] = image[i + 1];\r\n            imageData[(x + width * y) * 4 + 0] = image[i + 2];\r\n            imageData[(x + width * y) * 4 + 3] = image[i + 3];\r\n        }\r\n    }\r\n\r\n    return imageData;\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nfunction _getImageDataGrey8bits(\r\n    header: any,\r\n    palettes: Uint8Array,\r\n    pixel_data: Uint8Array,\r\n    y_start: number,\r\n    y_step: number,\r\n    y_end: number,\r\n    x_start: number,\r\n    x_step: number,\r\n    x_end: number\r\n): Uint8Array {\r\n    const image = pixel_data;\r\n    const width = header.width,\r\n        height = header.height;\r\n    let color,\r\n        i = 0,\r\n        x,\r\n        y;\r\n\r\n    const imageData = new Uint8Array(width * height * 4);\r\n\r\n    for (y = y_start; y !== y_end; y += y_step) {\r\n        for (x = x_start; x !== x_end; x += x_step, i++) {\r\n            color = image[i];\r\n            imageData[(x + width * y) * 4 + 0] = color;\r\n            imageData[(x + width * y) * 4 + 1] = color;\r\n            imageData[(x + width * y) * 4 + 2] = color;\r\n            imageData[(x + width * y) * 4 + 3] = 255;\r\n        }\r\n    }\r\n\r\n    return imageData;\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nfunction _getImageDataGrey16bits(\r\n    header: any,\r\n    palettes: Uint8Array,\r\n    pixel_data: Uint8Array,\r\n    y_start: number,\r\n    y_step: number,\r\n    y_end: number,\r\n    x_start: number,\r\n    x_step: number,\r\n    x_end: number\r\n): Uint8Array {\r\n    const image = pixel_data;\r\n    const width = header.width,\r\n        height = header.height;\r\n    let i = 0,\r\n        x,\r\n        y;\r\n\r\n    const imageData = new Uint8Array(width * height * 4);\r\n\r\n    for (y = y_start; y !== y_end; y += y_step) {\r\n        for (x = x_start; x !== x_end; x += x_step, i += 2) {\r\n            imageData[(x + width * y) * 4 + 0] = image[i + 0];\r\n            imageData[(x + width * y) * 4 + 1] = image[i + 0];\r\n            imageData[(x + width * y) * 4 + 2] = image[i + 0];\r\n            imageData[(x + width * y) * 4 + 3] = image[i + 1];\r\n        }\r\n    }\r\n\r\n    return imageData;\r\n}\r\n\r\n/**\r\n * Based on jsTGALoader - Javascript loader for TGA file\r\n * By Vincent Thibault\r\n * @see http://blog.robrowser.com/javascript-tga-loader.html\r\n */\r\nexport const TGATools = {\r\n    /**\r\n     * Gets the header of a TGA file\r\n     * @param data defines the TGA data\r\n     * @returns the header\r\n     */\r\n    GetTGAHeader,\r\n\r\n    /**\r\n     * Uploads TGA content to a Babylon Texture\r\n     * @internal\r\n     */\r\n    UploadContent,\r\n\r\n    /** @internal */\r\n    _getImageData8bits,\r\n\r\n    /** @internal */\r\n    _getImageData16bits,\r\n    /** @internal */\r\n    _getImageData24bits,\r\n\r\n    /** @internal */\r\n    _getImageData32bits,\r\n\r\n    /** @internal */\r\n    _getImageDataGrey8bits,\r\n    /** @internal */\r\n    _getImageDataGrey16bits,\r\n};\r\n","import { GetTGAHeader, UploadContent } from \"../../../Misc/tga\";\r\nimport type { InternalTexture } from \"../../../Materials/Textures/internalTexture\";\r\nimport type { IInternalTextureLoader } from \"./internalTextureLoader\";\r\n\r\n/**\r\n * Implementation of the TGA Texture Loader.\r\n * @internal\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class _TGATextureLoader implements IInternalTextureLoader {\r\n    /**\r\n     * Defines whether the loader supports cascade loading the different faces.\r\n     */\r\n    public readonly supportCascades = false;\r\n\r\n    /**\r\n     * Uploads the cube texture data to the WebGL texture. It has already been bound.\r\n     */\r\n    public loadCubeData(): void {\r\n        // eslint-disable-next-line no-throw-literal\r\n        throw \".env not supported in Cube.\";\r\n    }\r\n\r\n    /**\r\n     * Uploads the 2D texture data to the WebGL texture. It has already been bound once in the callback.\r\n     * @param data contains the texture data\r\n     * @param texture defines the BabylonJS internal texture\r\n     * @param callback defines the method to call once ready to upload\r\n     */\r\n    public loadData(\r\n        data: ArrayBufferView,\r\n        texture: InternalTexture,\r\n        callback: (width: number, height: number, loadMipmap: boolean, isCompressed: boolean, done: () => void) => void\r\n    ): void {\r\n        const bytes = new Uint8Array(data.buffer, data.byteOffset, data.byteLength);\r\n\r\n        const header = GetTGAHeader(bytes);\r\n        callback(header.width, header.height, texture.generateMipMaps, false, () => {\r\n            UploadContent(texture, bytes);\r\n        });\r\n    }\r\n}\r\n"],"names":["GetTGAHeader","data","offset","id_length","colormap_type","image_type","colormap_index","colormap_length","colormap_size","origin","width","height","pixel_size","flags","UploadContent","texture","length","Error","header","pixel_data","use_rle","use_pal","use_grey","pixel_total","palettes","x_start","y_start","x_step","y_step","y_end","x_end","subarray","c","count","i","Uint8Array","localOffset","pixels","set","func","imageData","TGATools","getEngine","_uploadDataToTextureDirectly","_getImageData8bits","image","colormap","color","x","y","_getImageData16bits","r","g","b","_getImageData24bits","_getImageData32bits","_getImageDataGrey8bits","_getImageDataGrey16bits","_TGATextureLoader","supportCascades","loadCubeData","loadData","callback","bytes","buffer","byteOffset","byteLength","generateMipMaps"],"sourceRoot":""}