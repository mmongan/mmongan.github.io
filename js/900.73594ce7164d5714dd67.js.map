{"version":3,"file":"js/900.73594ce7164d5714dd67.js","mappings":"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","sources":["webpack://babylonjs-typescript-webpack-template/./dev/core/src/Misc/dumpTools.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-unused-vars */\r\nimport { _WarnImport } from \"./devTools\";\r\n\r\nimport type { ThinEngine } from \"../Engines/thinEngine\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { EffectRenderer, EffectWrapper } from \"../Materials/effectRenderer\";\r\nimport { Tools } from \"./tools\";\r\nimport type { Nullable } from \"../types\";\r\nimport { Clamp } from \"../Maths/math.scalar.functions\";\r\nimport type { AbstractEngine } from \"../Engines/abstractEngine\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\n\r\ntype DumpToolsEngine = {\r\n    canvas: HTMLCanvasElement | OffscreenCanvas;\r\n    engine: ThinEngine;\r\n    renderer: EffectRenderer;\r\n    wrapper: EffectWrapper;\r\n};\r\n\r\nlet _dumpToolsEngine: Nullable<DumpToolsEngine>;\r\n\r\nlet _enginePromise: Promise<DumpToolsEngine> | null = null;\r\n\r\nasync function _CreateDumpRenderer(): Promise<DumpToolsEngine> {\r\n    if (!_enginePromise) {\r\n        _enginePromise = new Promise((resolve, reject) => {\r\n            let canvas: HTMLCanvasElement | OffscreenCanvas;\r\n            let engine: Nullable<ThinEngine> = null;\r\n            const options = {\r\n                preserveDrawingBuffer: true,\r\n                depth: false,\r\n                stencil: false,\r\n                alpha: true,\r\n                premultipliedAlpha: false,\r\n                antialias: false,\r\n                failIfMajorPerformanceCaveat: false,\r\n            };\r\n            import(\"../Engines/thinEngine\")\r\n                .then(({ ThinEngine: thinEngineClass }) => {\r\n                    const engineInstanceCount = EngineStore.Instances.length;\r\n                    try {\r\n                        canvas = new OffscreenCanvas(100, 100); // will be resized later\r\n                        engine = new thinEngineClass(canvas, false, options);\r\n                    } catch (e) {\r\n                        if (engineInstanceCount < EngineStore.Instances.length) {\r\n                            // The engine was created by another instance, let's use it\r\n                            EngineStore.Instances.pop()?.dispose();\r\n                        }\r\n                        // The browser either does not support OffscreenCanvas or WebGL context in OffscreenCanvas, fallback on a regular canvas\r\n                        canvas = document.createElement(\"canvas\");\r\n                        engine = new thinEngineClass(canvas, false, options);\r\n                    }\r\n                    // remove this engine from the list of instances to avoid using it for other purposes\r\n                    EngineStore.Instances.pop();\r\n                    // However, make sure to dispose it when no other engines are left\r\n                    EngineStore.OnEnginesDisposedObservable.add((e) => {\r\n                        // guaranteed to run when no other instances are left\r\n                        // only dispose if it's not the current engine\r\n                        if (engine && e !== engine && !engine.isDisposed && EngineStore.Instances.length === 0) {\r\n                            // Dump the engine and the associated resources\r\n                            Dispose();\r\n                        }\r\n                    });\r\n                    engine.getCaps().parallelShaderCompile = undefined;\r\n                    const renderer = new EffectRenderer(engine);\r\n                    import(\"../Shaders/pass.fragment\").then(({ passPixelShader }) => {\r\n                        if (!engine) {\r\n                            reject(\"Engine is not defined\");\r\n                            return;\r\n                        }\r\n                        const wrapper = new EffectWrapper({\r\n                            engine,\r\n                            name: passPixelShader.name,\r\n                            fragmentShader: passPixelShader.shader,\r\n                            samplerNames: [\"textureSampler\"],\r\n                        });\r\n                        _dumpToolsEngine = {\r\n                            canvas,\r\n                            engine,\r\n                            renderer,\r\n                            wrapper,\r\n                        };\r\n                        resolve(_dumpToolsEngine);\r\n                    });\r\n                })\r\n                .catch(reject);\r\n        });\r\n    }\r\n    return await _enginePromise;\r\n}\r\n\r\n/**\r\n * Dumps the current bound framebuffer\r\n * @param width defines the rendering width\r\n * @param height defines the rendering height\r\n * @param engine defines the hosting engine\r\n * @param successCallback defines the callback triggered once the data are available\r\n * @param mimeType defines the mime type of the result\r\n * @param fileName defines the filename to download. If present, the result will automatically be downloaded\r\n * @param quality The quality of the image if lossy mimeType is used (e.g. image/jpeg, image/webp). See {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob | HTMLCanvasElement.toBlob()}'s `quality` parameter.\r\n * @returns a void promise\r\n */\r\nexport async function DumpFramebuffer(\r\n    width: number,\r\n    height: number,\r\n    engine: AbstractEngine,\r\n    successCallback?: (data: string) => void,\r\n    mimeType = \"image/png\",\r\n    fileName?: string,\r\n    quality?: number\r\n) {\r\n    // Read the contents of the framebuffer\r\n    const bufferView = await engine.readPixels(0, 0, width, height);\r\n\r\n    const data = new Uint8Array(bufferView.buffer);\r\n\r\n    DumpData(width, height, data, successCallback as (data: string | ArrayBuffer) => void, mimeType, fileName, true, undefined, quality);\r\n}\r\n\r\n/**\r\n * Dumps an array buffer\r\n * @param width defines the rendering width\r\n * @param height defines the rendering height\r\n * @param data the data array\r\n * @param mimeType defines the mime type of the result\r\n * @param fileName defines the filename to download. If present, the result will automatically be downloaded\r\n * @param invertY true to invert the picture in the Y dimension\r\n * @param toArrayBuffer true to convert the data to an ArrayBuffer (encoded as `mimeType`) instead of a base64 string\r\n * @param quality The quality of the image if lossy mimeType is used (e.g. image/jpeg, image/webp). See {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob | HTMLCanvasElement.toBlob()}'s `quality` parameter.\r\n * @returns a promise that resolve to the final data\r\n */\r\nexport function DumpDataAsync(\r\n    width: number,\r\n    height: number,\r\n    data: ArrayBufferView,\r\n    mimeType = \"image/png\",\r\n    fileName?: string,\r\n    invertY = false,\r\n    toArrayBuffer = false,\r\n    quality?: number\r\n): Promise<string | ArrayBuffer> {\r\n    return new Promise((resolve) => {\r\n        DumpData(width, height, data, (result) => resolve(result), mimeType, fileName, invertY, toArrayBuffer, quality);\r\n    });\r\n}\r\n\r\n/**\r\n * Dumps an array buffer\r\n * @param width defines the rendering width\r\n * @param height defines the rendering height\r\n * @param data the data array\r\n * @param successCallback defines the callback triggered once the data are available\r\n * @param mimeType defines the mime type of the result\r\n * @param fileName defines the filename to download. If present, the result will automatically be downloaded\r\n * @param invertY true to invert the picture in the Y dimension\r\n * @param toArrayBuffer true to convert the data to an ArrayBuffer (encoded as `mimeType`) instead of a base64 string\r\n * @param quality The quality of the image if lossy mimeType is used (e.g. image/jpeg, image/webp). See {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob | HTMLCanvasElement.toBlob()}'s `quality` parameter.\r\n */\r\nexport function DumpData(\r\n    width: number,\r\n    height: number,\r\n    data: ArrayBufferView,\r\n    successCallback?: (data: string | ArrayBuffer) => void,\r\n    mimeType = \"image/png\",\r\n    fileName?: string,\r\n    invertY = false,\r\n    toArrayBuffer = false,\r\n    quality?: number\r\n): void {\r\n    _CreateDumpRenderer().then((renderer) => {\r\n        renderer.engine.setSize(width, height, true);\r\n\r\n        // Convert if data are float32\r\n        if (data instanceof Float32Array) {\r\n            const data2 = new Uint8Array(data.length);\r\n            let n = data.length;\r\n            while (n--) {\r\n                const v = data[n];\r\n                data2[n] = Math.round(Clamp(v) * 255);\r\n            }\r\n            data = data2;\r\n        }\r\n\r\n        // Create the image\r\n        const texture = renderer.engine.createRawTexture(data, width, height, Constants.TEXTUREFORMAT_RGBA, false, !invertY, Constants.TEXTURE_NEAREST_NEAREST);\r\n\r\n        renderer.renderer.setViewport();\r\n        renderer.renderer.applyEffectWrapper(renderer.wrapper);\r\n        renderer.wrapper.effect._bindTexture(\"textureSampler\", texture);\r\n        renderer.renderer.draw();\r\n\r\n        if (toArrayBuffer) {\r\n            Tools.ToBlob(\r\n                renderer.canvas,\r\n                (blob) => {\r\n                    const fileReader = new FileReader();\r\n                    fileReader.onload = (event: any) => {\r\n                        const arrayBuffer = event.target!.result as ArrayBuffer;\r\n                        if (successCallback) {\r\n                            successCallback(arrayBuffer);\r\n                        }\r\n                    };\r\n                    fileReader.readAsArrayBuffer(blob!);\r\n                },\r\n                mimeType,\r\n                quality\r\n            );\r\n        } else {\r\n            Tools.EncodeScreenshotCanvasData(renderer.canvas, successCallback, mimeType, fileName, quality);\r\n        }\r\n\r\n        texture.dispose();\r\n    });\r\n}\r\n\r\n/**\r\n * Dispose the dump tools associated resources\r\n */\r\nexport function Dispose() {\r\n    if (_dumpToolsEngine) {\r\n        _dumpToolsEngine.wrapper.dispose();\r\n        _dumpToolsEngine.renderer.dispose();\r\n        _dumpToolsEngine.engine.dispose();\r\n    } else {\r\n        // in cases where the engine is not yet created, we need to wait for it to dispose it\r\n        _enginePromise?.then((dumpToolsEngine) => {\r\n            dumpToolsEngine.wrapper.dispose();\r\n            dumpToolsEngine.renderer.dispose();\r\n            dumpToolsEngine.engine.dispose();\r\n        });\r\n    }\r\n    _enginePromise = null;\r\n    _dumpToolsEngine = null;\r\n}\r\n\r\n/**\r\n * Object containing a set of static utilities functions to dump data from a canvas\r\n * @deprecated use functions\r\n */\r\nexport const DumpTools = {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    DumpData,\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    DumpDataAsync,\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    DumpFramebuffer,\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    Dispose,\r\n};\r\n\r\n/**\r\n * This will be executed automatically for UMD and es5.\r\n * If esm dev wants the side effects to execute they will have to run it manually\r\n * Once we build native modules those need to be exported.\r\n * @internal\r\n */\r\nconst initSideEffects = () => {\r\n    // References the dependencies.\r\n    Tools.DumpData = DumpData;\r\n    Tools.DumpDataAsync = DumpDataAsync;\r\n    Tools.DumpFramebuffer = DumpFramebuffer;\r\n};\r\n\r\ninitSideEffects();\r\n"],"names":["_dumpToolsEngine","_enginePromise","async","DumpFramebuffer","width","height","engine","successCallback","mimeType","fileName","quality","bufferView","readPixels","DumpData","Uint8Array","buffer","undefined","DumpDataAsync","data","invertY","toArrayBuffer","Promise","resolve","result","reject","canvas","options","preserveDrawingBuffer","depth","stencil","alpha","premultipliedAlpha","antialias","failIfMajorPerformanceCaveat","then","ThinEngine","thinEngineClass","engineInstanceCount","Instances","length","OffscreenCanvas","e","pop","dispose","document","createElement","OnEnginesDisposedObservable","add","isDisposed","Dispose","getCaps","parallelShaderCompile","renderer","passPixelShader","wrapper","name","fragmentShader","shader","samplerNames","catch","_CreateDumpRenderer","setSize","Float32Array","data2","n","v","Math","round","texture","createRawTexture","setViewport","applyEffectWrapper","effect","_bindTexture","draw","ToBlob","blob","fileReader","FileReader","onload","event","arrayBuffer","target","readAsArrayBuffer","EncodeScreenshotCanvasData","dumpToolsEngine","DumpTools"],"sourceRoot":""}