{"version":3,"file":"js/38.77624be5506fd80f04e3.js","mappings":"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","sources":["webpack://babylonjs-typescript-webpack-template/./dev/core/src/Misc/khronosTextureContainer.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Misc/workerPool.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Materials/Textures/ktx2decoderTypes.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Misc/khronosTextureContainer2Worker.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Misc/khronosTextureContainer2.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Materials/Textures/Loaders/ktxTextureLoader.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/naming-convention */\r\nimport { Logger } from \"../Misc/logger\";\r\nimport type { InternalTexture } from \"../Materials/Textures/internalTexture\";\r\n\r\n/**\r\n * for description see https://www.khronos.org/opengles/sdk/tools/KTX/\r\n * for file layout see https://www.khronos.org/opengles/sdk/tools/KTX/file_format_spec/\r\n */\r\nexport class KhronosTextureContainer {\r\n    private static HEADER_LEN = 12 + 13 * 4; // identifier + header elements (not including key value meta-data pairs)\r\n\r\n    // load types\r\n    private static COMPRESSED_2D = 0; // uses a gl.compressedTexImage2D()\r\n    private static COMPRESSED_3D = 1; // uses a gl.compressedTexImage3D()\r\n    private static TEX_2D = 2; // uses a gl.texImage2D()\r\n    private static TEX_3D = 3; // uses a gl.texImage3D()\r\n\r\n    // elements of the header\r\n    /**\r\n     * Gets the openGL type\r\n     */\r\n    public glType: number;\r\n    /**\r\n     * Gets the openGL type size\r\n     */\r\n    public glTypeSize: number;\r\n    /**\r\n     * Gets the openGL format\r\n     */\r\n    public glFormat: number;\r\n    /**\r\n     * Gets the openGL internal format\r\n     */\r\n    public glInternalFormat: number;\r\n    /**\r\n     * Gets the base internal format\r\n     */\r\n    public glBaseInternalFormat: number;\r\n    /**\r\n     * Gets image width in pixel\r\n     */\r\n    public pixelWidth: number;\r\n    /**\r\n     * Gets image height in pixel\r\n     */\r\n    public pixelHeight: number;\r\n    /**\r\n     * Gets image depth in pixels\r\n     */\r\n    public pixelDepth: number;\r\n    /**\r\n     * Gets the number of array elements\r\n     */\r\n    public numberOfArrayElements: number;\r\n    /**\r\n     * Gets the number of faces\r\n     */\r\n    public numberOfFaces: number;\r\n    /**\r\n     * Gets the number of mipmap levels\r\n     */\r\n    public numberOfMipmapLevels: number;\r\n    /**\r\n     * Gets the bytes of key value data\r\n     */\r\n    public bytesOfKeyValueData: number;\r\n    /**\r\n     * Gets the load type\r\n     */\r\n    public loadType: number;\r\n    /**\r\n     * If the container has been made invalid (eg. constructor failed to correctly load array buffer)\r\n     */\r\n    public isInvalid = false;\r\n\r\n    /**\r\n     * Creates a new KhronosTextureContainer\r\n     * @param data contents of the KTX container file\r\n     * @param facesExpected should be either 1 or 6, based whether a cube texture or or\r\n     */\r\n    public constructor(\r\n        /** contents of the KTX container file */\r\n        public data: ArrayBufferView,\r\n        facesExpected: number\r\n    ) {\r\n        if (!KhronosTextureContainer.IsValid(data)) {\r\n            this.isInvalid = true;\r\n            Logger.Error(\"texture missing KTX identifier\");\r\n            return;\r\n        }\r\n\r\n        // load the reset of the header in native 32 bit uint\r\n        const dataSize = Uint32Array.BYTES_PER_ELEMENT;\r\n        const headerDataView = new DataView(this.data.buffer, this.data.byteOffset + 12, 13 * dataSize);\r\n        const endianness = headerDataView.getUint32(0, true);\r\n        const littleEndian = endianness === 0x04030201;\r\n\r\n        this.glType = headerDataView.getUint32(1 * dataSize, littleEndian); // must be 0 for compressed textures\r\n        this.glTypeSize = headerDataView.getUint32(2 * dataSize, littleEndian); // must be 1 for compressed textures\r\n        this.glFormat = headerDataView.getUint32(3 * dataSize, littleEndian); // must be 0 for compressed textures\r\n        this.glInternalFormat = headerDataView.getUint32(4 * dataSize, littleEndian); // the value of arg passed to gl.compressedTexImage2D(,,x,,,,)\r\n        this.glBaseInternalFormat = headerDataView.getUint32(5 * dataSize, littleEndian); // specify GL_RGB, GL_RGBA, GL_ALPHA, etc (un-compressed only)\r\n        this.pixelWidth = headerDataView.getUint32(6 * dataSize, littleEndian); // level 0 value of arg passed to gl.compressedTexImage2D(,,,x,,,)\r\n        this.pixelHeight = headerDataView.getUint32(7 * dataSize, littleEndian); // level 0 value of arg passed to gl.compressedTexImage2D(,,,,x,,)\r\n        this.pixelDepth = headerDataView.getUint32(8 * dataSize, littleEndian); // level 0 value of arg passed to gl.compressedTexImage3D(,,,,,x,,)\r\n        this.numberOfArrayElements = headerDataView.getUint32(9 * dataSize, littleEndian); // used for texture arrays\r\n        this.numberOfFaces = headerDataView.getUint32(10 * dataSize, littleEndian); // used for cubemap textures, should either be 1 or 6\r\n        this.numberOfMipmapLevels = headerDataView.getUint32(11 * dataSize, littleEndian); // number of levels; disregard possibility of 0 for compressed textures\r\n        this.bytesOfKeyValueData = headerDataView.getUint32(12 * dataSize, littleEndian); // the amount of space after the header for meta-data\r\n\r\n        // Make sure we have a compressed type.  Not only reduces work, but probably better to let dev know they are not compressing.\r\n        if (this.glType !== 0) {\r\n            Logger.Error(\"only compressed formats currently supported\");\r\n            this.isInvalid = true;\r\n            return;\r\n        } else {\r\n            // value of zero is an indication to generate mipmaps @ runtime.  Not usually allowed for compressed, so disregard.\r\n            this.numberOfMipmapLevels = Math.max(1, this.numberOfMipmapLevels);\r\n        }\r\n\r\n        if (this.pixelHeight === 0 || this.pixelDepth !== 0) {\r\n            Logger.Error(\"only 2D textures currently supported\");\r\n            this.isInvalid = true;\r\n            return;\r\n        }\r\n\r\n        if (this.numberOfArrayElements !== 0) {\r\n            Logger.Error(\"texture arrays not currently supported\");\r\n            this.isInvalid = true;\r\n            return;\r\n        }\r\n\r\n        if (this.numberOfFaces !== facesExpected) {\r\n            Logger.Error(\"number of faces expected\" + facesExpected + \", but found \" + this.numberOfFaces);\r\n            this.isInvalid = true;\r\n            return;\r\n        }\r\n\r\n        // we now have a completely validated file, so could use existence of loadType as success\r\n        // would need to make this more elaborate & adjust checks above to support more than one load type\r\n        this.loadType = KhronosTextureContainer.COMPRESSED_2D;\r\n    }\r\n\r\n    /**\r\n     * Uploads KTX content to a Babylon Texture.\r\n     * It is assumed that the texture has already been created & is currently bound\r\n     * @internal\r\n     */\r\n    public uploadLevels(texture: InternalTexture, loadMipmaps: boolean): void {\r\n        switch (this.loadType) {\r\n            case KhronosTextureContainer.COMPRESSED_2D:\r\n                this._upload2DCompressedLevels(texture, loadMipmaps);\r\n                break;\r\n\r\n            case KhronosTextureContainer.TEX_2D:\r\n            case KhronosTextureContainer.COMPRESSED_3D:\r\n            case KhronosTextureContainer.TEX_3D:\r\n        }\r\n    }\r\n\r\n    private _upload2DCompressedLevels(texture: InternalTexture, loadMipmaps: boolean): void {\r\n        // initialize width & height for level 1\r\n        let dataOffset = KhronosTextureContainer.HEADER_LEN + this.bytesOfKeyValueData;\r\n        let width = this.pixelWidth;\r\n        let height = this.pixelHeight;\r\n\r\n        const mipmapCount = loadMipmaps ? this.numberOfMipmapLevels : 1;\r\n        for (let level = 0; level < mipmapCount; level++) {\r\n            const imageSize = new Int32Array(this.data.buffer, this.data.byteOffset + dataOffset, 1)[0]; // size per face, since not supporting array cubemaps\r\n            dataOffset += 4; //image data starts from next multiple of 4 offset. Each face refers to same imagesize field above.\r\n            for (let face = 0; face < this.numberOfFaces; face++) {\r\n                const byteArray = new Uint8Array(this.data.buffer, this.data.byteOffset + dataOffset, imageSize);\r\n\r\n                const engine = texture.getEngine();\r\n                engine._uploadCompressedDataToTextureDirectly(texture, texture.format, width, height, byteArray, face, level);\r\n\r\n                dataOffset += imageSize; // add size of the image for the next face/mipmap\r\n                dataOffset += 3 - ((imageSize + 3) % 4); // add padding for odd sized image\r\n            }\r\n            width = Math.max(1.0, width * 0.5);\r\n            height = Math.max(1.0, height * 0.5);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Checks if the given data starts with a KTX file identifier.\r\n     * @param data the data to check\r\n     * @returns true if the data is a KTX file or false otherwise\r\n     */\r\n    public static IsValid(data: ArrayBufferView): boolean {\r\n        if (data.byteLength >= 12) {\r\n            // '«', 'K', 'T', 'X', ' ', '1', '1', '»', '\\r', '\\n', '\\x1A', '\\n'\r\n            const identifier = new Uint8Array(data.buffer, data.byteOffset, 12);\r\n            if (\r\n                identifier[0] === 0xab &&\r\n                identifier[1] === 0x4b &&\r\n                identifier[2] === 0x54 &&\r\n                identifier[3] === 0x58 &&\r\n                identifier[4] === 0x20 &&\r\n                identifier[5] === 0x31 &&\r\n                identifier[6] === 0x31 &&\r\n                identifier[7] === 0xbb &&\r\n                identifier[8] === 0x0d &&\r\n                identifier[9] === 0x0a &&\r\n                identifier[10] === 0x1a &&\r\n                identifier[11] === 0x0a\r\n            ) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n}\r\n","import type { IDisposable } from \"../scene\";\r\n\r\n/** @ignore */\r\ninterface WorkerInfo {\r\n    workerPromise: Promise<Worker>;\r\n    idle: boolean;\r\n    timeoutId?: ReturnType<typeof setTimeout>;\r\n}\r\n\r\n/**\r\n * Helper class to push actions to a pool of workers.\r\n */\r\nexport class WorkerPool implements IDisposable {\r\n    protected _workerInfos: Array<WorkerInfo>;\r\n    protected _pendingActions = new Array<(worker: Worker, onComplete: () => void) => void>();\r\n\r\n    /**\r\n     * Constructor\r\n     * @param workers Array of workers to use for actions\r\n     */\r\n    constructor(workers: Array<Worker>) {\r\n        this._workerInfos = workers.map((worker) => ({\r\n            workerPromise: Promise.resolve(worker),\r\n            idle: true,\r\n        }));\r\n    }\r\n\r\n    /**\r\n     * Terminates all workers and clears any pending actions.\r\n     */\r\n    public dispose(): void {\r\n        for (const workerInfo of this._workerInfos) {\r\n            workerInfo.workerPromise.then((worker) => {\r\n                worker.terminate();\r\n            });\r\n        }\r\n\r\n        this._workerInfos.length = 0;\r\n        this._pendingActions.length = 0;\r\n    }\r\n\r\n    /**\r\n     * Pushes an action to the worker pool. If all the workers are active, the action will be\r\n     * pended until a worker has completed its action.\r\n     * @param action The action to perform. Call onComplete when the action is complete.\r\n     */\r\n    public push(action: (worker: Worker, onComplete: () => void) => void): void {\r\n        if (!this._executeOnIdleWorker(action)) {\r\n            this._pendingActions.push(action);\r\n        }\r\n    }\r\n\r\n    protected _executeOnIdleWorker(action: (worker: Worker, onComplete: () => void) => void): boolean {\r\n        for (const workerInfo of this._workerInfos) {\r\n            if (workerInfo.idle) {\r\n                this._execute(workerInfo, action);\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    protected _execute(workerInfo: WorkerInfo, action: (worker: Worker, onComplete: () => void) => void): void {\r\n        workerInfo.idle = false;\r\n        workerInfo.workerPromise.then((worker) => {\r\n            action(worker, () => {\r\n                const nextAction = this._pendingActions.shift();\r\n                if (nextAction) {\r\n                    this._execute(workerInfo, nextAction);\r\n                } else {\r\n                    workerInfo.idle = true;\r\n                }\r\n            });\r\n        });\r\n    }\r\n}\r\n\r\n/**\r\n * Options for AutoReleaseWorkerPool\r\n */\r\nexport interface AutoReleaseWorkerPoolOptions {\r\n    /**\r\n     * Idle time elapsed before workers are terminated.\r\n     */\r\n    idleTimeElapsedBeforeRelease: number;\r\n}\r\n\r\n/**\r\n * Similar to the WorkerPool class except it creates and destroys workers automatically with a maximum of `maxWorkers` workers.\r\n * Workers are terminated when it is idle for at least `idleTimeElapsedBeforeRelease` milliseconds.\r\n */\r\nexport class AutoReleaseWorkerPool extends WorkerPool {\r\n    /**\r\n     * Default options for the constructor.\r\n     * Override to change the defaults.\r\n     */\r\n    public static DefaultOptions: AutoReleaseWorkerPoolOptions = {\r\n        idleTimeElapsedBeforeRelease: 1000,\r\n    };\r\n\r\n    private readonly _maxWorkers: number;\r\n    private readonly _createWorkerAsync: () => Promise<Worker>;\r\n    private readonly _options: AutoReleaseWorkerPoolOptions;\r\n\r\n    constructor(maxWorkers: number, createWorkerAsync: () => Promise<Worker>, options = AutoReleaseWorkerPool.DefaultOptions) {\r\n        super([]);\r\n\r\n        this._maxWorkers = maxWorkers;\r\n        this._createWorkerAsync = createWorkerAsync;\r\n        this._options = options;\r\n    }\r\n\r\n    public override push(action: (worker: Worker, onComplete: () => void) => void): void {\r\n        if (!this._executeOnIdleWorker(action)) {\r\n            if (this._workerInfos.length < this._maxWorkers) {\r\n                const workerInfo: WorkerInfo = {\r\n                    workerPromise: this._createWorkerAsync(),\r\n                    idle: false,\r\n                };\r\n                this._workerInfos.push(workerInfo);\r\n                this._execute(workerInfo, action);\r\n            } else {\r\n                this._pendingActions.push(action);\r\n            }\r\n        }\r\n    }\r\n\r\n    protected override _execute(workerInfo: WorkerInfo, action: (worker: Worker, onComplete: () => void) => void): void {\r\n        // Reset the idle timeout.\r\n        if (workerInfo.timeoutId) {\r\n            clearTimeout(workerInfo.timeoutId);\r\n            delete workerInfo.timeoutId;\r\n        }\r\n\r\n        super._execute(workerInfo, (worker, onComplete) => {\r\n            action(worker, () => {\r\n                onComplete();\r\n\r\n                if (workerInfo.idle) {\r\n                    // Schedule the worker to be terminated after the elapsed time.\r\n                    workerInfo.timeoutId = setTimeout(() => {\r\n                        workerInfo.workerPromise.then((worker) => {\r\n                            worker.terminate();\r\n                        });\r\n\r\n                        const indexOf = this._workerInfos.indexOf(workerInfo);\r\n                        if (indexOf !== -1) {\r\n                            this._workerInfos.splice(indexOf, 1);\r\n                        }\r\n                    }, this._options.idleTimeElapsedBeforeRelease);\r\n                }\r\n            });\r\n        });\r\n    }\r\n}\r\n","export enum SourceTextureFormat {\r\n    ETC1S,\r\n    UASTC4x4,\r\n}\r\n\r\nexport enum TranscodeTarget {\r\n    ASTC_4X4_RGBA,\r\n    BC7_RGBA,\r\n    BC3_RGBA,\r\n    BC1_RGB,\r\n    PVRTC1_4_RGBA,\r\n    PVRTC1_4_RGB,\r\n    ETC2_RGBA,\r\n    ETC1_RGB,\r\n    RGBA32,\r\n    R8,\r\n    RG8,\r\n}\r\n\r\nexport const enum EngineFormat {\r\n    COMPRESSED_RGBA_BPTC_UNORM_EXT = 0x8e8c,\r\n    COMPRESSED_RGBA_ASTC_4X4_KHR = 0x93b0,\r\n    COMPRESSED_RGB_S3TC_DXT1_EXT = 0x83f0,\r\n    COMPRESSED_RGBA_S3TC_DXT5_EXT = 0x83f3,\r\n    COMPRESSED_RGBA_PVRTC_4BPPV1_IMG = 0x8c02,\r\n    COMPRESSED_RGB_PVRTC_4BPPV1_IMG = 0x8c00,\r\n    COMPRESSED_RGBA8_ETC2_EAC = 0x9278,\r\n    COMPRESSED_RGB8_ETC2 = 0x9274,\r\n    COMPRESSED_RGB_ETC1_WEBGL = 0x8d64,\r\n    RGBA8Format = 0x8058,\r\n    R8Format = 0x8229,\r\n    RG8Format = 0x822b,\r\n}\r\n\r\n/**\r\n * Leaf node of a decision tree\r\n * It defines the transcoding format to use to transcode the texture as well as the corresponding format to use at the engine level when creating the texture\r\n */\r\nexport interface ILeaf {\r\n    /**\r\n     * The format to transcode to\r\n     */\r\n    transcodeFormat: TranscodeTarget;\r\n\r\n    /**\r\n     * The format to use when creating the texture at the engine level after it has been transcoded to transcodeFormat\r\n     */\r\n    engineFormat: EngineFormat;\r\n\r\n    /**\r\n     * Whether the texture must be rounded to a multiple of 4 (should normally be the case for all compressed formats). Default: true\r\n     */\r\n    roundToMultiple4?: boolean;\r\n}\r\n\r\n/**\r\n * Regular node of a decision tree\r\n *\r\n * Each property (except for \"yes\" and \"no\"), if not empty, will be checked in order to determine the next node to select.\r\n * If all checks are successful, the \"yes\" node will be selected, else the \"no\" node will be selected.\r\n */\r\nexport interface INode {\r\n    /**\r\n     * The name of the capability to check. Can be one of the following:\r\n     *      astc\r\n     *      bptc\r\n     *      s3tc\r\n     *      pvrtc\r\n     *      etc2\r\n     *      etc1\r\n     */\r\n    cap?: string;\r\n\r\n    /**\r\n     * The name of the option to check from the options object passed to the KTX2 decode function. {@link IKTX2DecoderOptions}\r\n     */\r\n    option?: string;\r\n\r\n    /**\r\n     * Checks if alpha is present in the texture\r\n     */\r\n    alpha?: boolean;\r\n\r\n    /**\r\n     * Checks the currently selected transcoding format.\r\n     */\r\n    transcodeFormat?: TranscodeTarget | TranscodeTarget[];\r\n\r\n    /**\r\n     * Checks that the texture is a power of two\r\n     */\r\n    needsPowerOfTwo?: boolean;\r\n\r\n    /**\r\n     * The node to select if all checks are successful\r\n     */\r\n    yes?: INode | ILeaf;\r\n\r\n    /**\r\n     * The node to select if at least one check is not successful\r\n     */\r\n    no?: INode | ILeaf;\r\n}\r\n\r\n/**\r\n * Decision tree used to determine the transcoding format to use for a given source texture format\r\n */\r\nexport interface IDecisionTree {\r\n    /**\r\n     * textureFormat can be either UASTC or ETC1S\r\n     */\r\n    [textureFormat: string]: INode;\r\n}\r\n\r\n/**\r\n * Result of the KTX2 decode function\r\n */\r\nexport interface IDecodedData {\r\n    /**\r\n     * Width of the texture\r\n     */\r\n    width: number;\r\n\r\n    /**\r\n     * Height of the texture\r\n     */\r\n    height: number;\r\n\r\n    /**\r\n     * The format to use when creating the texture at the engine level\r\n     * This corresponds to the engineFormat property of the leaf node of the decision tree\r\n     */\r\n    transcodedFormat: number;\r\n\r\n    /**\r\n     * List of mipmap levels.\r\n     * The first element is the base level, the last element is the smallest mipmap level (if more than one mipmap level is present)\r\n     */\r\n    mipmaps: Array<IMipmap>;\r\n\r\n    /**\r\n     * Whether the texture data is in gamma space or not\r\n     */\r\n    isInGammaSpace: boolean;\r\n\r\n    /**\r\n     * Whether the texture has an alpha channel or not\r\n     */\r\n    hasAlpha: boolean;\r\n\r\n    /**\r\n     * The name of the transcoder used to transcode the texture\r\n     */\r\n    transcoderName: string;\r\n\r\n    /**\r\n     * The errors (if any) encountered during the decoding process\r\n     */\r\n    errors?: string;\r\n}\r\n\r\n/**\r\n * Defines a mipmap level\r\n */\r\nexport interface IMipmap {\r\n    /**\r\n     * The data of the mipmap level\r\n     */\r\n    data: Uint8Array | null;\r\n\r\n    /**\r\n     * The width of the mipmap level\r\n     */\r\n    width: number;\r\n\r\n    /**\r\n     * The height of the mipmap level\r\n     */\r\n    height: number;\r\n}\r\n\r\n/**\r\n * The compressed texture formats supported by the browser\r\n */\r\nexport interface ICompressedFormatCapabilities {\r\n    /**\r\n     * Whether the browser supports ASTC\r\n     */\r\n    astc?: boolean;\r\n\r\n    /**\r\n     * Whether the browser supports BPTC\r\n     */\r\n    bptc?: boolean;\r\n\r\n    /**\r\n     * Whether the browser supports S3TC\r\n     */\r\n    s3tc?: boolean;\r\n\r\n    /**\r\n     * Whether the browser supports PVRTC\r\n     */\r\n    pvrtc?: boolean;\r\n\r\n    /**\r\n     * Whether the browser supports ETC2\r\n     */\r\n    etc2?: boolean;\r\n\r\n    /**\r\n     * Whether the browser supports ETC1\r\n     */\r\n    etc1?: boolean;\r\n}\r\n\r\n/**\r\n * Options passed to the KTX2 decode function\r\n */\r\nexport interface IKTX2DecoderOptions {\r\n    /** use RGBA format if ASTC and BC7 are not available as transcoded format */\r\n    useRGBAIfASTCBC7NotAvailableWhenUASTC?: boolean;\r\n\r\n    /** force to always use (uncompressed) RGBA for transcoded format */\r\n    forceRGBA?: boolean;\r\n\r\n    /** force to always use (uncompressed) R8 for transcoded format */\r\n    forceR8?: boolean;\r\n\r\n    /** force to always use (uncompressed) RG8 for transcoded format */\r\n    forceRG8?: boolean;\r\n\r\n    /**\r\n     * list of transcoders to bypass when looking for a suitable transcoder. The available transcoders are:\r\n     *      UniversalTranscoder_UASTC_ASTC\r\n     *      UniversalTranscoder_UASTC_BC7\r\n     *      UniversalTranscoder_UASTC_RGBA_UNORM\r\n     *      UniversalTranscoder_UASTC_RGBA_SRGB\r\n     *      UniversalTranscoder_UASTC_R8_UNORM\r\n     *      UniversalTranscoder_UASTC_RG8_UNORM\r\n     *      MSCTranscoder\r\n     */\r\n    bypassTranscoders?: string[];\r\n\r\n    /**\r\n     * Custom decision tree to apply after the default decision tree has selected a transcoding format.\r\n     * Allows the user to override the default decision tree selection.\r\n     * The decision tree can use the INode.transcodeFormat property to base its decision on the transcoding format selected by the default decision tree.\r\n     */\r\n    transcodeFormatDecisionTree?: IDecisionTree;\r\n}\r\n","import type { IDecodedData } from \"core/Materials/Textures/ktx2decoderTypes\";\r\n\r\n/* eslint-disable @typescript-eslint/naming-convention */\r\nexport type AllowedKeys =\r\n    | \"wasmUASTCToASTC\"\r\n    | \"wasmUASTCToBC7\"\r\n    | \"wasmUASTCToRGBA_UNORM\"\r\n    | \"wasmUASTCToRGBA_SRGB\"\r\n    | \"wasmUASTCToR8_UNORM\"\r\n    | \"wasmUASTCToRG8_UNORM\"\r\n    | \"wasmMSCTranscoder\"\r\n    | \"wasmZSTDDecoder\"\r\n    | \"jsDecoderModule\"\r\n    | \"jsMSCTranscoder\";\r\n\r\ndeclare function importScripts(...urls: string[]): void;\r\ndeclare function postMessage(message: any, transfer?: any[]): void;\r\ndeclare let KTX2DECODER: any;\r\n\r\nexport function applyConfig(urls?: { [key in AllowedKeys]: string }, binariesAndModulesContainer?: { [key in AllowedKeys]: ArrayBuffer | any }): void {\r\n    const KTX2DecoderModule = binariesAndModulesContainer?.jsDecoderModule || KTX2DECODER;\r\n    if (urls) {\r\n        if (urls.wasmUASTCToASTC) {\r\n            KTX2DecoderModule.LiteTranscoder_UASTC_ASTC.WasmModuleURL = urls.wasmUASTCToASTC;\r\n        }\r\n\r\n        if (urls.wasmUASTCToBC7) {\r\n            KTX2DecoderModule.LiteTranscoder_UASTC_BC7.WasmModuleURL = urls.wasmUASTCToBC7;\r\n        }\r\n\r\n        if (urls.wasmUASTCToRGBA_UNORM) {\r\n            KTX2DecoderModule.LiteTranscoder_UASTC_RGBA_UNORM.WasmModuleURL = urls.wasmUASTCToRGBA_UNORM;\r\n        }\r\n\r\n        if (urls.wasmUASTCToRGBA_SRGB) {\r\n            KTX2DecoderModule.LiteTranscoder_UASTC_RGBA_SRGB.WasmModuleURL = urls.wasmUASTCToRGBA_SRGB;\r\n        }\r\n\r\n        if (urls.wasmUASTCToR8_UNORM) {\r\n            KTX2DecoderModule.LiteTranscoder_UASTC_R8_UNORM.WasmModuleURL = urls.wasmUASTCToR8_UNORM;\r\n        }\r\n\r\n        if (urls.wasmUASTCToRG8_UNORM) {\r\n            KTX2DecoderModule.LiteTranscoder_UASTC_RG8_UNORM.WasmModuleURL = urls.wasmUASTCToRG8_UNORM;\r\n        }\r\n\r\n        if (urls.jsMSCTranscoder) {\r\n            KTX2DecoderModule.MSCTranscoder.JSModuleURL = urls.jsMSCTranscoder;\r\n        }\r\n\r\n        if (urls.wasmMSCTranscoder) {\r\n            KTX2DecoderModule.MSCTranscoder.WasmModuleURL = urls.wasmMSCTranscoder;\r\n        }\r\n\r\n        if (urls.wasmZSTDDecoder) {\r\n            KTX2DecoderModule.ZSTDDecoder.WasmModuleURL = urls.wasmZSTDDecoder;\r\n        }\r\n    }\r\n    if (binariesAndModulesContainer) {\r\n        if (binariesAndModulesContainer.wasmUASTCToASTC) {\r\n            KTX2DecoderModule.LiteTranscoder_UASTC_ASTC.WasmBinary = binariesAndModulesContainer.wasmUASTCToASTC;\r\n        }\r\n        if (binariesAndModulesContainer.wasmUASTCToBC7) {\r\n            KTX2DecoderModule.LiteTranscoder_UASTC_BC7.WasmBinary = binariesAndModulesContainer.wasmUASTCToBC7;\r\n        }\r\n        if (binariesAndModulesContainer.wasmUASTCToRGBA_UNORM) {\r\n            KTX2DecoderModule.LiteTranscoder_UASTC_RGBA_UNORM.WasmBinary = binariesAndModulesContainer.wasmUASTCToRGBA_UNORM;\r\n        }\r\n        if (binariesAndModulesContainer.wasmUASTCToRGBA_SRGB) {\r\n            KTX2DecoderModule.LiteTranscoder_UASTC_RGBA_SRGB.WasmBinary = binariesAndModulesContainer.wasmUASTCToRGBA_SRGB;\r\n        }\r\n        if (binariesAndModulesContainer.wasmUASTCToR8_UNORM) {\r\n            KTX2DecoderModule.LiteTranscoder_UASTC_R8_UNORM.WasmBinary = binariesAndModulesContainer.wasmUASTCToR8_UNORM;\r\n        }\r\n        if (binariesAndModulesContainer.wasmUASTCToRG8_UNORM) {\r\n            KTX2DecoderModule.LiteTranscoder_UASTC_RG8_UNORM.WasmBinary = binariesAndModulesContainer.wasmUASTCToRG8_UNORM;\r\n        }\r\n        if (binariesAndModulesContainer.jsMSCTranscoder) {\r\n            KTX2DecoderModule.MSCTranscoder.JSModule = binariesAndModulesContainer.jsMSCTranscoder;\r\n        }\r\n        if (binariesAndModulesContainer.wasmMSCTranscoder) {\r\n            KTX2DecoderModule.MSCTranscoder.WasmBinary = binariesAndModulesContainer.wasmMSCTranscoder;\r\n        }\r\n        if (binariesAndModulesContainer.wasmZSTDDecoder) {\r\n            KTX2DecoderModule.ZSTDDecoder.WasmBinary = binariesAndModulesContainer.wasmZSTDDecoder;\r\n        }\r\n    }\r\n}\r\n\r\nexport function workerFunction(KTX2DecoderModule: any): void {\r\n    if (typeof KTX2DecoderModule === \"undefined\" && typeof KTX2DECODER !== \"undefined\") {\r\n        KTX2DecoderModule = KTX2DECODER;\r\n    }\r\n    let ktx2Decoder: any;\r\n\r\n    onmessage = (event) => {\r\n        if (!event.data) {\r\n            return;\r\n        }\r\n        switch (event.data.action) {\r\n            case \"init\": {\r\n                const urls = event.data.urls;\r\n                if (urls) {\r\n                    if (urls.jsDecoderModule && typeof KTX2DecoderModule === \"undefined\") {\r\n                        importScripts(urls.jsDecoderModule);\r\n                        // assuming global namespace populated by the script (UMD pattern)\r\n                        KTX2DecoderModule = KTX2DECODER;\r\n                    }\r\n                    applyConfig(urls);\r\n                }\r\n                if (event.data.wasmBinaries) {\r\n                    applyConfig(undefined, { ...event.data.wasmBinaries, jsDecoderModule: KTX2DecoderModule });\r\n                }\r\n                ktx2Decoder = new KTX2DecoderModule.KTX2Decoder();\r\n                postMessage({ action: \"init\" });\r\n                break;\r\n            }\r\n            case \"setDefaultDecoderOptions\": {\r\n                KTX2DecoderModule.KTX2Decoder.DefaultDecoderOptions = event.data.options;\r\n                break;\r\n            }\r\n            case \"decode\":\r\n                ktx2Decoder\r\n                    .decode(event.data.data, event.data.caps, event.data.options)\r\n                    .then((data: IDecodedData) => {\r\n                        const buffers = [];\r\n                        for (let mip = 0; mip < data.mipmaps.length; ++mip) {\r\n                            const mipmap = data.mipmaps[mip];\r\n                            if (mipmap && mipmap.data) {\r\n                                buffers.push(mipmap.data.buffer);\r\n                            }\r\n                        }\r\n                        postMessage({ action: \"decoded\", success: true, decodedData: data }, buffers);\r\n                    })\r\n                    .catch((reason: any) => {\r\n                        postMessage({ action: \"decoded\", success: false, msg: reason });\r\n                    });\r\n                break;\r\n        }\r\n    };\r\n}\r\n\r\nexport function initializeWebWorker(worker: Worker, wasmBinaries?: { [key in AllowedKeys]?: ArrayBuffer }, urls?: { [key in AllowedKeys]: string }): Promise<Worker> {\r\n    return new Promise((resolve, reject) => {\r\n        const onError = (error: ErrorEvent) => {\r\n            worker.removeEventListener(\"error\", onError);\r\n            worker.removeEventListener(\"message\", onMessage);\r\n            reject(error);\r\n        };\r\n\r\n        const onMessage = (message: MessageEvent) => {\r\n            if (message.data.action === \"init\") {\r\n                worker.removeEventListener(\"error\", onError);\r\n                worker.removeEventListener(\"message\", onMessage);\r\n                resolve(worker);\r\n            }\r\n        };\r\n\r\n        worker.addEventListener(\"error\", onError);\r\n        worker.addEventListener(\"message\", onMessage);\r\n\r\n        worker.postMessage({\r\n            action: \"init\",\r\n            urls,\r\n            wasmBinaries,\r\n        });\r\n    });\r\n}\r\n","/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { InternalTexture } from \"../Materials/Textures/internalTexture\";\r\nimport type { AbstractEngine } from \"../Engines/abstractEngine\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { AutoReleaseWorkerPool } from \"./workerPool\";\r\nimport { Tools } from \"./tools\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { ICompressedFormatCapabilities, IDecodedData, IKTX2DecoderOptions } from \"core/Materials/Textures/ktx2decoderTypes\";\r\nimport { EngineFormat, TranscodeTarget } from \"core/Materials/Textures/ktx2decoderTypes\";\r\nimport type { AllowedKeys } from \"./khronosTextureContainer2Worker\";\r\nimport { applyConfig, initializeWebWorker, workerFunction } from \"./khronosTextureContainer2Worker\";\r\n\r\ndeclare let KTX2DECODER: any;\r\n\r\n/**\r\n * Class that defines the default KTX2 decoder options.\r\n *\r\n * This class is useful for providing options to the KTX2 decoder to control how the source data is transcoded.\r\n */\r\nexport class DefaultKTX2DecoderOptions {\r\n    private _isDirty = true;\r\n\r\n    /**\r\n     * Gets the dirty flag\r\n     */\r\n    public get isDirty() {\r\n        return this._isDirty;\r\n    }\r\n\r\n    private _useRGBAIfASTCBC7NotAvailableWhenUASTC?: boolean;\r\n    /**\r\n     * force a (uncompressed) RGBA transcoded format if transcoding a UASTC source format and ASTC + BC7 are not available as a compressed transcoded format\r\n     */\r\n    public get useRGBAIfASTCBC7NotAvailableWhenUASTC() {\r\n        return this._useRGBAIfASTCBC7NotAvailableWhenUASTC;\r\n    }\r\n\r\n    public set useRGBAIfASTCBC7NotAvailableWhenUASTC(value: boolean | undefined) {\r\n        if (this._useRGBAIfASTCBC7NotAvailableWhenUASTC === value) {\r\n            return;\r\n        }\r\n        this._useRGBAIfASTCBC7NotAvailableWhenUASTC = value;\r\n        this._isDirty = true;\r\n    }\r\n\r\n    private _useRGBAIfOnlyBC1BC3AvailableWhenUASTC?: boolean = true;\r\n    /**\r\n     * force a (uncompressed) RGBA transcoded format if transcoding a UASTC source format and only BC1 or BC3 are available as a compressed transcoded format.\r\n     * This property is true by default to favor speed over memory, because currently transcoding from UASTC to BC1/3 is slow because the transcoder transcodes\r\n     * to uncompressed and then recompresses the texture\r\n     */\r\n    public get useRGBAIfOnlyBC1BC3AvailableWhenUASTC() {\r\n        return this._useRGBAIfOnlyBC1BC3AvailableWhenUASTC;\r\n    }\r\n\r\n    public set useRGBAIfOnlyBC1BC3AvailableWhenUASTC(value: boolean | undefined) {\r\n        if (this._useRGBAIfOnlyBC1BC3AvailableWhenUASTC === value) {\r\n            return;\r\n        }\r\n        this._useRGBAIfOnlyBC1BC3AvailableWhenUASTC = value;\r\n        this._isDirty = true;\r\n    }\r\n\r\n    private _forceRGBA?: boolean;\r\n    /**\r\n     * force to always use (uncompressed) RGBA for transcoded format\r\n     */\r\n    public get forceRGBA() {\r\n        return this._forceRGBA;\r\n    }\r\n\r\n    public set forceRGBA(value: boolean | undefined) {\r\n        if (this._forceRGBA === value) {\r\n            return;\r\n        }\r\n        this._forceRGBA = value;\r\n        this._isDirty = true;\r\n    }\r\n\r\n    private _forceR8?: boolean;\r\n    /**\r\n     * force to always use (uncompressed) R8 for transcoded format\r\n     */\r\n    public get forceR8() {\r\n        return this._forceR8;\r\n    }\r\n\r\n    public set forceR8(value: boolean | undefined) {\r\n        if (this._forceR8 === value) {\r\n            return;\r\n        }\r\n        this._forceR8 = value;\r\n        this._isDirty = true;\r\n    }\r\n\r\n    private _forceRG8?: boolean;\r\n    /**\r\n     * force to always use (uncompressed) RG8 for transcoded format\r\n     */\r\n    public get forceRG8() {\r\n        return this._forceRG8;\r\n    }\r\n\r\n    public set forceRG8(value: boolean | undefined) {\r\n        if (this._forceRG8 === value) {\r\n            return;\r\n        }\r\n        this._forceRG8 = value;\r\n        this._isDirty = true;\r\n    }\r\n\r\n    private _bypassTranscoders?: string[];\r\n    /**\r\n     * list of transcoders to bypass when looking for a suitable transcoder. The available transcoders are:\r\n     *      UniversalTranscoder_UASTC_ASTC\r\n     *      UniversalTranscoder_UASTC_BC7\r\n     *      UniversalTranscoder_UASTC_RGBA_UNORM\r\n     *      UniversalTranscoder_UASTC_RGBA_SRGB\r\n     *      UniversalTranscoder_UASTC_R8_UNORM\r\n     *      UniversalTranscoder_UASTC_RG8_UNORM\r\n     *      MSCTranscoder\r\n     */\r\n    public get bypassTranscoders() {\r\n        return this._bypassTranscoders;\r\n    }\r\n\r\n    public set bypassTranscoders(value: string[] | undefined) {\r\n        if (this._bypassTranscoders === value) {\r\n            return;\r\n        }\r\n        this._bypassTranscoders = value;\r\n        this._isDirty = true;\r\n    }\r\n\r\n    private _ktx2DecoderOptions: IKTX2DecoderOptions = {};\r\n\r\n    /** @internal */\r\n    public _getKTX2DecoderOptions(): IKTX2DecoderOptions {\r\n        if (!this._isDirty) {\r\n            return this._ktx2DecoderOptions;\r\n        }\r\n\r\n        this._isDirty = false;\r\n\r\n        const options: IKTX2DecoderOptions = {\r\n            useRGBAIfASTCBC7NotAvailableWhenUASTC: this._useRGBAIfASTCBC7NotAvailableWhenUASTC,\r\n            forceRGBA: this._forceRGBA,\r\n            forceR8: this._forceR8,\r\n            forceRG8: this._forceRG8,\r\n            bypassTranscoders: this._bypassTranscoders,\r\n        };\r\n\r\n        if (this.useRGBAIfOnlyBC1BC3AvailableWhenUASTC) {\r\n            options.transcodeFormatDecisionTree = {\r\n                UASTC: {\r\n                    transcodeFormat: [TranscodeTarget.BC1_RGB, TranscodeTarget.BC3_RGBA],\r\n                    yes: {\r\n                        transcodeFormat: TranscodeTarget.RGBA32,\r\n                        engineFormat: EngineFormat.RGBA8Format,\r\n                        roundToMultiple4: false,\r\n                    },\r\n                },\r\n            };\r\n        }\r\n\r\n        this._ktx2DecoderOptions = options;\r\n\r\n        return options;\r\n    }\r\n}\r\n\r\n/**\r\n * Options for the KTX2 decoder\r\n */\r\nexport interface IKhronosTextureContainer2Options {\r\n    /**\r\n     * Number of workers to use for async operations. Specify `0` to disable web workers and run synchronously in the current context.\r\n     */\r\n    numWorkers?: number;\r\n    /**\r\n     * Worker pool to use for async operations. If set, `numWorkers` will be ignored.\r\n     */\r\n    workerPool?: AutoReleaseWorkerPool;\r\n    /**\r\n     * Optional container for the KTX2 decoder module and its dependencies. If set, the module will be used from this container and the URLs will be ignored.\r\n     */\r\n    binariesAndModulesContainer?: { [key in AllowedKeys]?: ArrayBuffer | any };\r\n}\r\n\r\n/**\r\n * Class for loading KTX2 files\r\n */\r\nexport class KhronosTextureContainer2 {\r\n    private static _WorkerPoolPromise?: Promise<AutoReleaseWorkerPool>;\r\n    private static _DecoderModulePromise?: Promise<any>;\r\n    private static _KTX2DecoderModule?: any;\r\n\r\n    /**\r\n     * URLs to use when loading the KTX2 decoder module as well as its dependencies\r\n     * If a url is null, the default url is used (pointing to https://preview.babylonjs.com)\r\n     * Note that jsDecoderModule can't be null and that the other dependencies will only be loaded if necessary\r\n     * Urls you can change:\r\n     *     URLConfig.jsDecoderModule\r\n     *     URLConfig.wasmUASTCToASTC\r\n     *     URLConfig.wasmUASTCToBC7\r\n     *     URLConfig.wasmUASTCToRGBA_UNORM\r\n     *     URLConfig.wasmUASTCToRGBA_SRGB\r\n     *     URLConfig.wasmUASTCToR8_UNORM\r\n     *     URLConfig.wasmUASTCToRG8_UNORM\r\n     *     URLConfig.jsMSCTranscoder\r\n     *     URLConfig.wasmMSCTranscoder\r\n     *     URLConfig.wasmZSTDDecoder\r\n     * You can see their default values in this PG: https://playground.babylonjs.com/#EIJH8L#29\r\n     */\r\n    public static URLConfig: {\r\n        jsDecoderModule: string;\r\n        wasmUASTCToASTC: Nullable<string>;\r\n        wasmUASTCToBC7: Nullable<string>;\r\n        wasmUASTCToRGBA_UNORM: Nullable<string>;\r\n        wasmUASTCToRGBA_SRGB: Nullable<string>;\r\n        wasmUASTCToR8_UNORM: Nullable<string>;\r\n        wasmUASTCToRG8_UNORM: Nullable<string>;\r\n        jsMSCTranscoder: Nullable<string>;\r\n        wasmMSCTranscoder: Nullable<string>;\r\n        wasmZSTDDecoder: Nullable<string>;\r\n    } = {\r\n        jsDecoderModule: \"https://cdn.babylonjs.com/babylon.ktx2Decoder.js\",\r\n        wasmUASTCToASTC: null,\r\n        wasmUASTCToBC7: null,\r\n        wasmUASTCToRGBA_UNORM: null,\r\n        wasmUASTCToRGBA_SRGB: null,\r\n        wasmUASTCToR8_UNORM: null,\r\n        wasmUASTCToRG8_UNORM: null,\r\n        jsMSCTranscoder: null,\r\n        wasmMSCTranscoder: null,\r\n        wasmZSTDDecoder: null,\r\n    };\r\n\r\n    /**\r\n     * If provided, this worker pool will be used instead of creating a new one.\r\n     * This is useful when loading the WASM and the js modules on your own and\r\n     * you want to use the ktxTextureLoader and not construct this class directly.\r\n     */\r\n    public static WorkerPool?: AutoReleaseWorkerPool;\r\n\r\n    /**\r\n     * Default number of workers used to handle data decoding\r\n     */\r\n    public static DefaultNumWorkers = KhronosTextureContainer2.GetDefaultNumWorkers();\r\n\r\n    /**\r\n     * Default configuration for the KTX2 decoder.\r\n     * The options defined in this way have priority over those passed when creating a KTX2 texture with new Texture(...).\r\n     */\r\n    public static DefaultDecoderOptions = new DefaultKTX2DecoderOptions();\r\n\r\n    private static GetDefaultNumWorkers(): number {\r\n        if (typeof navigator !== \"object\" || !navigator.hardwareConcurrency) {\r\n            return 1;\r\n        }\r\n\r\n        // Use 50% of the available logical processors but capped at 4.\r\n        return Math.min(Math.floor(navigator.hardwareConcurrency * 0.5), 4);\r\n    }\r\n\r\n    private _engine: AbstractEngine;\r\n\r\n    private static _Initialize(numWorkers: number): void {\r\n        if (KhronosTextureContainer2._WorkerPoolPromise || KhronosTextureContainer2._DecoderModulePromise) {\r\n            return;\r\n        }\r\n\r\n        const urls = {\r\n            jsDecoderModule: Tools.GetBabylonScriptURL(this.URLConfig.jsDecoderModule, true),\r\n            wasmUASTCToASTC: Tools.GetBabylonScriptURL(this.URLConfig.wasmUASTCToASTC, true),\r\n            wasmUASTCToBC7: Tools.GetBabylonScriptURL(this.URLConfig.wasmUASTCToBC7, true),\r\n            wasmUASTCToRGBA_UNORM: Tools.GetBabylonScriptURL(this.URLConfig.wasmUASTCToRGBA_UNORM, true),\r\n            wasmUASTCToRGBA_SRGB: Tools.GetBabylonScriptURL(this.URLConfig.wasmUASTCToRGBA_SRGB, true),\r\n            wasmUASTCToR8_UNORM: Tools.GetBabylonScriptURL(this.URLConfig.wasmUASTCToR8_UNORM, true),\r\n            wasmUASTCToRG8_UNORM: Tools.GetBabylonScriptURL(this.URLConfig.wasmUASTCToRG8_UNORM, true),\r\n            jsMSCTranscoder: Tools.GetBabylonScriptURL(this.URLConfig.jsMSCTranscoder, true),\r\n            wasmMSCTranscoder: Tools.GetBabylonScriptURL(this.URLConfig.wasmMSCTranscoder, true),\r\n            wasmZSTDDecoder: Tools.GetBabylonScriptURL(this.URLConfig.wasmZSTDDecoder, true),\r\n        };\r\n\r\n        if (numWorkers && typeof Worker === \"function\" && typeof URL !== \"undefined\") {\r\n            KhronosTextureContainer2._WorkerPoolPromise = new Promise((resolve) => {\r\n                const workerContent = `${applyConfig}(${workerFunction})()`;\r\n                const workerBlobUrl = URL.createObjectURL(new Blob([workerContent], { type: \"application/javascript\" }));\r\n                resolve(new AutoReleaseWorkerPool(numWorkers, () => initializeWebWorker(new Worker(workerBlobUrl), undefined, urls)));\r\n            });\r\n        } else {\r\n            if (typeof KhronosTextureContainer2._KTX2DecoderModule === \"undefined\") {\r\n                KhronosTextureContainer2._DecoderModulePromise = Tools.LoadBabylonScriptAsync(urls.jsDecoderModule).then(() => {\r\n                    KhronosTextureContainer2._KTX2DecoderModule = KTX2DECODER;\r\n                    KhronosTextureContainer2._KTX2DecoderModule.MSCTranscoder.UseFromWorkerThread = false;\r\n                    KhronosTextureContainer2._KTX2DecoderModule.WASMMemoryManager.LoadBinariesFromCurrentThread = true;\r\n                    applyConfig(urls, KhronosTextureContainer2._KTX2DecoderModule);\r\n                    return new KhronosTextureContainer2._KTX2DecoderModule.KTX2Decoder();\r\n                });\r\n            } else {\r\n                KhronosTextureContainer2._KTX2DecoderModule.MSCTranscoder.UseFromWorkerThread = false;\r\n                KhronosTextureContainer2._KTX2DecoderModule.WASMMemoryManager.LoadBinariesFromCurrentThread = true;\r\n                KhronosTextureContainer2._DecoderModulePromise = Promise.resolve(new KhronosTextureContainer2._KTX2DecoderModule.KTX2Decoder());\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Constructor\r\n     * @param engine The engine to use\r\n     * @param numWorkersOrOptions The number of workers for async operations. Specify `0` to disable web workers and run synchronously in the current context.\r\n     */\r\n    public constructor(engine: AbstractEngine, numWorkersOrOptions: number | IKhronosTextureContainer2Options = KhronosTextureContainer2.DefaultNumWorkers) {\r\n        this._engine = engine;\r\n        const workerPoolOption = (typeof numWorkersOrOptions === \"object\" && numWorkersOrOptions.workerPool) || KhronosTextureContainer2.WorkerPool;\r\n        if (workerPoolOption) {\r\n            KhronosTextureContainer2._WorkerPoolPromise = Promise.resolve(workerPoolOption);\r\n        } else {\r\n            // set the KTX2 decoder module\r\n            if (typeof numWorkersOrOptions === \"object\") {\r\n                KhronosTextureContainer2._KTX2DecoderModule = numWorkersOrOptions?.binariesAndModulesContainer?.jsDecoderModule;\r\n            } else if (typeof KTX2DECODER !== \"undefined\") {\r\n                KhronosTextureContainer2._KTX2DecoderModule = KTX2DECODER;\r\n            }\r\n            const numberOfWorkers = typeof numWorkersOrOptions === \"number\" ? numWorkersOrOptions : (numWorkersOrOptions.numWorkers ?? KhronosTextureContainer2.DefaultNumWorkers);\r\n            KhronosTextureContainer2._Initialize(numberOfWorkers);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _uploadAsync(data: ArrayBufferView, internalTexture: InternalTexture, options?: IKTX2DecoderOptions & IDecodedData): Promise<void> {\r\n        const caps = this._engine.getCaps();\r\n\r\n        const compressedTexturesCaps: ICompressedFormatCapabilities = {\r\n            astc: !!caps.astc,\r\n            bptc: !!caps.bptc,\r\n            s3tc: !!caps.s3tc,\r\n            pvrtc: !!caps.pvrtc,\r\n            etc2: !!caps.etc2,\r\n            etc1: !!caps.etc1,\r\n        };\r\n\r\n        if (KhronosTextureContainer2._WorkerPoolPromise) {\r\n            return KhronosTextureContainer2._WorkerPoolPromise.then((workerPool) => {\r\n                return new Promise((resolve, reject) => {\r\n                    workerPool.push((worker, onComplete) => {\r\n                        const onError = (error: ErrorEvent) => {\r\n                            worker.removeEventListener(\"error\", onError);\r\n                            worker.removeEventListener(\"message\", onMessage);\r\n                            reject(error);\r\n                            onComplete();\r\n                        };\r\n\r\n                        const onMessage = (message: MessageEvent) => {\r\n                            if (message.data.action === \"decoded\") {\r\n                                worker.removeEventListener(\"error\", onError);\r\n                                worker.removeEventListener(\"message\", onMessage);\r\n                                if (!message.data.success) {\r\n                                    reject({ message: message.data.msg });\r\n                                } else {\r\n                                    try {\r\n                                        this._createTexture(message.data.decodedData, internalTexture, options);\r\n                                        resolve();\r\n                                    } catch (err) {\r\n                                        reject({ message: err });\r\n                                    }\r\n                                }\r\n                                onComplete();\r\n                            }\r\n                        };\r\n\r\n                        worker.addEventListener(\"error\", onError);\r\n                        worker.addEventListener(\"message\", onMessage);\r\n                        worker.postMessage({ action: \"setDefaultDecoderOptions\", options: KhronosTextureContainer2.DefaultDecoderOptions._getKTX2DecoderOptions() });\r\n\r\n                        const dataCopy = new Uint8Array(data.byteLength);\r\n                        dataCopy.set(new Uint8Array(data.buffer, data.byteOffset, data.byteLength));\r\n\r\n                        worker.postMessage({ action: \"decode\", data: dataCopy, caps: compressedTexturesCaps, options }, [dataCopy.buffer]);\r\n                    });\r\n                });\r\n            });\r\n        } else if (KhronosTextureContainer2._DecoderModulePromise) {\r\n            return KhronosTextureContainer2._DecoderModulePromise.then((decoder) => {\r\n                if (KhronosTextureContainer2.DefaultDecoderOptions.isDirty) {\r\n                    KhronosTextureContainer2._KTX2DecoderModule.KTX2Decoder.DefaultDecoderOptions = KhronosTextureContainer2.DefaultDecoderOptions._getKTX2DecoderOptions();\r\n                }\r\n                return new Promise((resolve, reject) => {\r\n                    decoder\r\n                        .decode(data, caps)\r\n                        .then((data: IDecodedData) => {\r\n                            this._createTexture(data, internalTexture);\r\n                            resolve();\r\n                        })\r\n                        .catch((reason: any) => {\r\n                            reject({ message: reason });\r\n                        });\r\n                });\r\n            });\r\n        }\r\n\r\n        throw new Error(\"KTX2 decoder module is not available\");\r\n    }\r\n\r\n    protected _createTexture(data: IDecodedData, internalTexture: InternalTexture, options?: IKTX2DecoderOptions & IDecodedData): void {\r\n        const oglTexture2D = 3553; // gl.TEXTURE_2D\r\n\r\n        this._engine._bindTextureDirectly(oglTexture2D, internalTexture);\r\n\r\n        if (options) {\r\n            // return back some information about the decoded data\r\n            options.transcodedFormat = data.transcodedFormat;\r\n            options.isInGammaSpace = data.isInGammaSpace;\r\n            options.hasAlpha = data.hasAlpha;\r\n            options.transcoderName = data.transcoderName;\r\n        }\r\n\r\n        let isUncompressedFormat = true;\r\n\r\n        switch (data.transcodedFormat) {\r\n            case 0x8058 /* RGBA8 */:\r\n                internalTexture.type = Constants.TEXTURETYPE_UNSIGNED_BYTE;\r\n                internalTexture.format = Constants.TEXTUREFORMAT_RGBA;\r\n                break;\r\n            case 0x8229 /* R8 */:\r\n                internalTexture.type = Constants.TEXTURETYPE_UNSIGNED_BYTE;\r\n                internalTexture.format = Constants.TEXTUREFORMAT_R;\r\n                break;\r\n            case 0x822b /* RG8 */:\r\n                internalTexture.type = Constants.TEXTURETYPE_UNSIGNED_BYTE;\r\n                internalTexture.format = Constants.TEXTUREFORMAT_RG;\r\n                break;\r\n            default:\r\n                internalTexture.format = data.transcodedFormat;\r\n                isUncompressedFormat = false;\r\n                break;\r\n        }\r\n\r\n        internalTexture._gammaSpace = data.isInGammaSpace;\r\n        internalTexture.generateMipMaps = data.mipmaps.length > 1;\r\n\r\n        if (data.errors) {\r\n            throw new Error(\"KTX2 container - could not transcode the data. \" + data.errors);\r\n        }\r\n\r\n        for (let t = 0; t < data.mipmaps.length; ++t) {\r\n            const mipmap = data.mipmaps[t];\r\n\r\n            if (!mipmap || !mipmap.data) {\r\n                throw new Error(\"KTX2 container - could not transcode one of the image\");\r\n            }\r\n\r\n            if (isUncompressedFormat) {\r\n                // uncompressed RGBA / R8 / RG8\r\n                internalTexture.width = mipmap.width; // need to set width/height so that the call to _uploadDataToTextureDirectly uses the right dimensions\r\n                internalTexture.height = mipmap.height;\r\n\r\n                this._engine._uploadDataToTextureDirectly(internalTexture, mipmap.data, 0, t, undefined, true);\r\n            } else {\r\n                this._engine._uploadCompressedDataToTextureDirectly(internalTexture, data.transcodedFormat, mipmap.width, mipmap.height, mipmap.data, 0, t);\r\n            }\r\n        }\r\n\r\n        internalTexture._extension = \".ktx2\";\r\n        internalTexture.width = data.mipmaps[0].width;\r\n        internalTexture.height = data.mipmaps[0].height;\r\n        internalTexture.isReady = true;\r\n\r\n        this._engine._bindTextureDirectly(oglTexture2D, null);\r\n    }\r\n\r\n    /**\r\n     * Checks if the given data starts with a KTX2 file identifier.\r\n     * @param data the data to check\r\n     * @returns true if the data is a KTX2 file or false otherwise\r\n     */\r\n    public static IsValid(data: ArrayBufferView): boolean {\r\n        if (data.byteLength >= 12) {\r\n            // '«', 'K', 'T', 'X', ' ', '2', '0', '»', '\\r', '\\n', '\\x1A', '\\n'\r\n            const identifier = new Uint8Array(data.buffer, data.byteOffset, 12);\r\n            if (\r\n                identifier[0] === 0xab &&\r\n                identifier[1] === 0x4b &&\r\n                identifier[2] === 0x54 &&\r\n                identifier[3] === 0x58 &&\r\n                identifier[4] === 0x20 &&\r\n                identifier[5] === 0x32 &&\r\n                identifier[6] === 0x30 &&\r\n                identifier[7] === 0xbb &&\r\n                identifier[8] === 0x0d &&\r\n                identifier[9] === 0x0a &&\r\n                identifier[10] === 0x1a &&\r\n                identifier[11] === 0x0a\r\n            ) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n}\r\n","import { KhronosTextureContainer } from \"../../../Misc/khronosTextureContainer\";\r\nimport { KhronosTextureContainer2 } from \"../../../Misc/khronosTextureContainer2\";\r\nimport type { Nullable } from \"../../../types\";\r\nimport type { InternalTexture } from \"../../../Materials/Textures/internalTexture\";\r\nimport type { IInternalTextureLoader } from \"./internalTextureLoader\";\r\nimport { Logger } from \"../../../Misc/logger\";\r\nimport { Constants } from \"../../../Engines/constants\";\r\n\r\nfunction mapSRGBToLinear(format: number): Nullable<number> {\r\n    switch (format) {\r\n        case Constants.TEXTUREFORMAT_COMPRESSED_SRGB_S3TC_DXT1_EXT:\r\n            return Constants.TEXTUREFORMAT_COMPRESSED_RGB_S3TC_DXT1;\r\n        case Constants.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT:\r\n            return Constants.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT3;\r\n        case Constants.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT:\r\n            return Constants.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT5;\r\n        case Constants.TEXTUREFORMAT_COMPRESSED_SRGB8_ETC2:\r\n            return Constants.TEXTUREFORMAT_COMPRESSED_RGB8_ETC2;\r\n        case Constants.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:\r\n            return Constants.TEXTUREFORMAT_COMPRESSED_RGBA8_ETC2_EAC;\r\n        case Constants.TEXTUREFORMAT_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:\r\n            return Constants.TEXTUREFORMAT_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2;\r\n        case Constants.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:\r\n            return Constants.TEXTUREFORMAT_COMPRESSED_RGBA_ASTC_4x4;\r\n        case Constants.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_BPTC_UNORM:\r\n            return Constants.TEXTUREFORMAT_COMPRESSED_RGBA_BPTC_UNORM;\r\n    }\r\n\r\n    return null;\r\n}\r\n\r\n/**\r\n * Implementation of the KTX Texture Loader.\r\n * @internal\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class _KTXTextureLoader implements IInternalTextureLoader {\r\n    /**\r\n     * Defines whether the loader supports cascade loading the different faces.\r\n     */\r\n    public readonly supportCascades = false;\r\n\r\n    /**\r\n     * Uploads the cube texture data to the WebGL texture. It has already been bound.\r\n     * @param data contains the texture data\r\n     * @param texture defines the BabylonJS internal texture\r\n     * @param createPolynomials will be true if polynomials have been requested\r\n     * @param onLoad defines the callback to trigger once the texture is ready\r\n     */\r\n    public loadCubeData(data: ArrayBufferView | ArrayBufferView[], texture: InternalTexture, createPolynomials: boolean, onLoad: Nullable<(data?: any) => void>): void {\r\n        if (Array.isArray(data)) {\r\n            return;\r\n        }\r\n\r\n        // Need to invert vScale as invertY via UNPACK_FLIP_Y_WEBGL is not supported by compressed texture\r\n        texture._invertVScale = !texture.invertY;\r\n        const engine = texture.getEngine();\r\n        const ktx = new KhronosTextureContainer(data, 6);\r\n\r\n        const loadMipmap = ktx.numberOfMipmapLevels > 1 && texture.generateMipMaps;\r\n\r\n        engine._unpackFlipY(true);\r\n\r\n        ktx.uploadLevels(texture, texture.generateMipMaps);\r\n\r\n        texture.width = ktx.pixelWidth;\r\n        texture.height = ktx.pixelHeight;\r\n\r\n        engine._setCubeMapTextureParams(texture, loadMipmap, ktx.numberOfMipmapLevels - 1);\r\n        texture.isReady = true;\r\n        texture.onLoadedObservable.notifyObservers(texture);\r\n        texture.onLoadedObservable.clear();\r\n\r\n        if (onLoad) {\r\n            onLoad();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Uploads the 2D texture data to the WebGL texture. It has already been bound once in the callback.\r\n     * @param data contains the texture data\r\n     * @param texture defines the BabylonJS internal texture\r\n     * @param callback defines the method to call once ready to upload\r\n     * @param options\r\n     */\r\n    public loadData(\r\n        data: ArrayBufferView,\r\n        texture: InternalTexture,\r\n        callback: (width: number, height: number, loadMipmap: boolean, isCompressed: boolean, done: () => void, loadFailed: boolean) => void,\r\n        options?: any\r\n    ): void {\r\n        if (KhronosTextureContainer.IsValid(data)) {\r\n            // Need to invert vScale as invertY via UNPACK_FLIP_Y_WEBGL is not supported by compressed texture\r\n            texture._invertVScale = !texture.invertY;\r\n            const ktx = new KhronosTextureContainer(data, 1);\r\n\r\n            const mappedFormat = mapSRGBToLinear(ktx.glInternalFormat);\r\n            if (mappedFormat) {\r\n                texture.format = mappedFormat;\r\n                texture._useSRGBBuffer = texture.getEngine()._getUseSRGBBuffer(true, texture.generateMipMaps);\r\n                texture._gammaSpace = true;\r\n            } else {\r\n                texture.format = ktx.glInternalFormat;\r\n            }\r\n\r\n            callback(\r\n                ktx.pixelWidth,\r\n                ktx.pixelHeight,\r\n                texture.generateMipMaps,\r\n                true,\r\n                () => {\r\n                    ktx.uploadLevels(texture, texture.generateMipMaps);\r\n                },\r\n                ktx.isInvalid\r\n            );\r\n        } else if (KhronosTextureContainer2.IsValid(data)) {\r\n            const ktx2 = new KhronosTextureContainer2(texture.getEngine());\r\n            ktx2._uploadAsync(data, texture, options).then(\r\n                () => {\r\n                    callback(texture.width, texture.height, texture.generateMipMaps, true, () => {}, false);\r\n                },\r\n                (error) => {\r\n                    Logger.Warn(`Failed to load KTX2 texture data: ${error.message}`);\r\n                    callback(0, 0, false, false, () => {}, true);\r\n                }\r\n            );\r\n        } else {\r\n            Logger.Error(\"texture missing KTX identifier\");\r\n            callback(0, 0, false, false, () => {}, true);\r\n        }\r\n    }\r\n}\r\n"],"names":["KhronosTextureContainer","data","facesExpected","isInvalid","IsValid","this","Error","dataSize","Uint32Array","BYTES_PER_ELEMENT","headerDataView","DataView","buffer","byteOffset","littleEndian","getUint32","glType","glTypeSize","glFormat","glInternalFormat","glBaseInternalFormat","pixelWidth","pixelHeight","pixelDepth","numberOfArrayElements","numberOfFaces","numberOfMipmapLevels","bytesOfKeyValueData","Math","max","loadType","COMPRESSED_2D","uploadLevels","texture","loadMipmaps","_upload2DCompressedLevels","TEX_2D","COMPRESSED_3D","TEX_3D","dataOffset","HEADER_LEN","width","height","mipmapCount","level","imageSize","Int32Array","face","byteArray","Uint8Array","getEngine","_uploadCompressedDataToTextureDirectly","format","byteLength","identifier","WorkerPool","constructor","workers","_pendingActions","Array","_workerInfos","map","worker","workerPromise","Promise","resolve","idle","dispose","workerInfo","then","terminate","length","push","action","_executeOnIdleWorker","_execute","nextAction","shift","AutoReleaseWorkerPool","maxWorkers","createWorkerAsync","options","DefaultOptions","super","_maxWorkers","_createWorkerAsync","_options","timeoutId","clearTimeout","onComplete","setTimeout","indexOf","splice","idleTimeElapsedBeforeRelease","SourceTextureFormat","TranscodeTarget","EngineFormat","applyConfig","urls","binariesAndModulesContainer","KTX2DecoderModule","jsDecoderModule","KTX2DECODER","wasmUASTCToASTC","LiteTranscoder_UASTC_ASTC","WasmModuleURL","wasmUASTCToBC7","LiteTranscoder_UASTC_BC7","wasmUASTCToRGBA_UNORM","LiteTranscoder_UASTC_RGBA_UNORM","wasmUASTCToRGBA_SRGB","LiteTranscoder_UASTC_RGBA_SRGB","wasmUASTCToR8_UNORM","LiteTranscoder_UASTC_R8_UNORM","wasmUASTCToRG8_UNORM","LiteTranscoder_UASTC_RG8_UNORM","jsMSCTranscoder","MSCTranscoder","JSModuleURL","wasmMSCTranscoder","wasmZSTDDecoder","ZSTDDecoder","WasmBinary","JSModule","workerFunction","ktx2Decoder","onmessage","event","importScripts","wasmBinaries","undefined","KTX2Decoder","postMessage","DefaultDecoderOptions","decode","caps","buffers","mip","mipmaps","mipmap","success","decodedData","catch","reason","msg","KhronosTextureContainer2","GetDefaultNumWorkers","navigator","hardwareConcurrency","min","floor","_Initialize","numWorkers","_WorkerPoolPromise","_DecoderModulePromise","GetBabylonScriptURL","URLConfig","Worker","URL","workerContent","workerBlobUrl","createObjectURL","Blob","type","reject","onError","error","removeEventListener","onMessage","message","addEventListener","initializeWebWorker","_KTX2DecoderModule","LoadBabylonScriptAsync","UseFromWorkerThread","WASMMemoryManager","LoadBinariesFromCurrentThread","engine","numWorkersOrOptions","DefaultNumWorkers","_engine","workerPoolOption","workerPool","numberOfWorkers","_uploadAsync","internalTexture","getCaps","compressedTexturesCaps","astc","bptc","s3tc","pvrtc","etc2","etc1","_createTexture","err","_getKTX2DecoderOptions","dataCopy","set","decoder","isDirty","_bindTextureDirectly","transcodedFormat","isInGammaSpace","hasAlpha","transcoderName","isUncompressedFormat","_gammaSpace","generateMipMaps","errors","t","_uploadDataToTextureDirectly","_extension","isReady","_isDirty","_useRGBAIfOnlyBC1BC3AvailableWhenUASTC","_ktx2DecoderOptions","useRGBAIfASTCBC7NotAvailableWhenUASTC","_useRGBAIfASTCBC7NotAvailableWhenUASTC","value","useRGBAIfOnlyBC1BC3AvailableWhenUASTC","forceRGBA","_forceRGBA","forceR8","_forceR8","forceRG8","_forceRG8","bypassTranscoders","_bypassTranscoders","transcodeFormatDecisionTree","UASTC","transcodeFormat","BC1_RGB","BC3_RGBA","yes","RGBA32","engineFormat","roundToMultiple4","_KTXTextureLoader","supportCascades","loadCubeData","createPolynomials","onLoad","isArray","_invertVScale","invertY","ktx","loadMipmap","_unpackFlipY","_setCubeMapTextureParams","onLoadedObservable","notifyObservers","clear","loadData","callback","mappedFormat","mapSRGBToLinear","_useSRGBBuffer","_getUseSRGBBuffer","Warn"],"sourceRoot":""}