{"version":3,"file":"js/850.46afbc2ab51959f5ab50.js","mappings":"6JAAA,SAASA,EAAaC,GAClB,OAAOC,KAAKC,MAAMF,EAAW,EACjC,CAEA,SAASG,EAAWH,GAChB,OAAO,GAAKA,EAAW,CAC3B,C,+BAOO,MAAMI,EAOT,YAAmCC,GAAA,KAAAA,KAAAA,EAC/BC,KAAKC,WAAa,IAAIC,WAAWP,KAAKQ,KAAKH,KAAKD,KAAO,GAC3D,CAOO,GAAAK,CAAIV,GACP,GAAIA,GAAYM,KAAKD,KACjB,MAAM,IAAIM,WAAW,0BAEzB,MAAMC,EAAYb,EAAaC,GACzBa,EAAUV,EAAWH,GAC3B,SAAQM,KAAKC,WAAWK,GAAaC,EACzC,CAOO,GAAAC,CAAId,EAAkBe,GACzB,GAAIf,GAAYM,KAAKD,KACjB,MAAM,IAAIM,WAAW,0BAEzB,MAAMC,EAAYb,EAAaC,GACzBa,EAAUV,EAAWH,GACvBe,EACAT,KAAKC,WAAWK,IAAcC,EAE9BP,KAAKC,WAAWK,KAAeC,CAEvC,EC/CG,SAASG,EAAgBC,GAC5B,MAAMC,EAA8B,GAC9BC,EAAYF,EAAQG,OAAS,EAGnC,IAAK,IAAIC,EAAI,EAAGA,EAAIF,EAAWE,IAC3BH,EAAMI,KAAK,CAACL,EAAY,EAAJI,GAAQJ,EAAY,EAAJI,EAAQ,GAAIJ,EAAY,EAAJI,EAAQ,KAIpE,MAAME,EAAkB,IAAIC,IAC5BN,EAAMO,SAAQ,CAACC,EAAMC,KACjBD,EAAKD,SAASG,IACV,IAAIF,EAAOH,EAAgBb,IAAIkB,GAC1BF,GACDH,EAAgBT,IAAIc,EAASF,EAAO,IAExCA,EAAKJ,KAAKK,EAAU,GACtB,IAIN,MAAME,EAAU,IAAIzB,EAASe,GACvBW,EAA+B,GAG/BC,EAAwBC,IAC1B,MAAMC,EAAuB,CAACD,GAE9B,KAAOC,EAAMb,OAAS,GAAG,CACrB,MAAMc,EAAmBD,EAAME,MAE3BN,EAAQnB,IAAIwB,KAGhBL,EAAQf,IAAIoB,GAAkB,GAC9BJ,EAAYR,KAAKJ,EAAMgB,IAGvBhB,EAAMgB,GAAkBT,SAASG,IAC7B,MAAMQ,EAAYb,EAAgBb,IAAIkB,GAEjCQ,GAILA,EAAUX,SAASY,IACVR,EAAQnB,IAAI2B,IACbJ,EAAMX,KAAKe,EACf,GACF,IAEV,GAIJ,IAAK,IAAIhB,EAAI,EAAGA,EAAIF,EAAWE,IACtBQ,EAAQnB,IAAIW,IACbU,EAAqBV,GAK7B,IAAIiB,EAAQ,EACZR,EAAYL,SAASC,IACjBT,EAAQqB,KAAWZ,EAAK,GACxBT,EAAQqB,KAAWZ,EAAK,GACxBT,EAAQqB,KAAWZ,EAAK,EAAE,GAElC,C","sources":["webpack://babylonjs-typescript-webpack-template/./dev/core/src/Misc/bitArray.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Meshes/mesh.vertexData.functions.ts"],"sourcesContent":["function getByteIndex(bitIndex: number): number {\r\n    return Math.floor(bitIndex / 8);\r\n}\r\n\r\nfunction getBitMask(bitIndex: number): number {\r\n    return 1 << bitIndex % 8;\r\n}\r\n\r\n/**\r\n * An fixed size array that effectively stores boolean values where each value is a single bit of backing data.\r\n * @remarks\r\n * All bits are initialized to false.\r\n */\r\nexport class BitArray {\r\n    private readonly _byteArray: Uint8Array;\r\n\r\n    /**\r\n     * Creates a new bit array with a fixed size.\r\n     * @param size The number of bits to store.\r\n     */\r\n    public constructor(public readonly size: number) {\r\n        this._byteArray = new Uint8Array(Math.ceil(this.size / 8));\r\n    }\r\n\r\n    /**\r\n     * Gets the current value at the specified index.\r\n     * @param bitIndex The index to get the value from.\r\n     * @returns The value at the specified index.\r\n     */\r\n    public get(bitIndex: number): boolean {\r\n        if (bitIndex >= this.size) {\r\n            throw new RangeError(\"Bit index out of range\");\r\n        }\r\n        const byteIndex = getByteIndex(bitIndex);\r\n        const bitMask = getBitMask(bitIndex);\r\n        return (this._byteArray[byteIndex] & bitMask) !== 0;\r\n    }\r\n\r\n    /**\r\n     * Sets the value at the specified index.\r\n     * @param bitIndex The index to set the value at.\r\n     * @param value The value to set.\r\n     */\r\n    public set(bitIndex: number, value: boolean): void {\r\n        if (bitIndex >= this.size) {\r\n            throw new RangeError(\"Bit index out of range\");\r\n        }\r\n        const byteIndex = getByteIndex(bitIndex);\r\n        const bitMask = getBitMask(bitIndex);\r\n        if (value) {\r\n            this._byteArray[byteIndex] |= bitMask;\r\n        } else {\r\n            this._byteArray[byteIndex] &= ~bitMask;\r\n        }\r\n    }\r\n}\r\n","import type { IndicesArray } from \"core/types\";\r\nimport { BitArray } from \"core/Misc/bitArray\";\r\n\r\n/**\r\n * Sort (in place) the index array so that faces with common indices are close\r\n * @param indices the array of indices to sort\r\n */\r\nexport function OptimizeIndices(indices: IndicesArray) {\r\n    const faces: Array<Array<number>> = [];\r\n    const faceCount = indices.length / 3;\r\n\r\n    // Step 1: Break the indices array into faces\r\n    for (let i = 0; i < faceCount; i++) {\r\n        faces.push([indices[i * 3], indices[i * 3 + 1], indices[i * 3 + 2]]);\r\n    }\r\n\r\n    // Step 2: Build a graph connecting faces sharing a vertex\r\n    const vertexToFaceMap = new Map<number, number[]>();\r\n    faces.forEach((face, faceIndex) => {\r\n        face.forEach((vertex) => {\r\n            let face = vertexToFaceMap.get(vertex);\r\n            if (!face) {\r\n                vertexToFaceMap.set(vertex, (face = []));\r\n            }\r\n            face.push(faceIndex);\r\n        });\r\n    });\r\n\r\n    // Step 3: Traverse faces using DFS to ensure connected faces are close\r\n    const visited = new BitArray(faceCount);\r\n    const sortedFaces: Array<number[]> = [];\r\n\r\n    // Using a stack and not a recursive version to avoid call stack overflow\r\n    const deepFirstSearchStack = (startFaceIndex: number) => {\r\n        const stack: Array<number> = [startFaceIndex];\r\n\r\n        while (stack.length > 0) {\r\n            const currentFaceIndex = stack.pop()!;\r\n\r\n            if (visited.get(currentFaceIndex)) {\r\n                continue;\r\n            }\r\n            visited.set(currentFaceIndex, true);\r\n            sortedFaces.push(faces[currentFaceIndex]);\r\n\r\n            // Push unvisited neighbors (faces sharing a vertex) onto the stack\r\n            faces[currentFaceIndex].forEach((vertex) => {\r\n                const neighbors = vertexToFaceMap.get(vertex);\r\n\r\n                if (!neighbors) {\r\n                    return;\r\n                }\r\n\r\n                neighbors.forEach((neighborFaceIndex) => {\r\n                    if (!visited.get(neighborFaceIndex)) {\r\n                        stack.push(neighborFaceIndex);\r\n                    }\r\n                });\r\n            });\r\n        }\r\n    };\r\n\r\n    // Start DFS from the first face\r\n    for (let i = 0; i < faceCount; i++) {\r\n        if (!visited.get(i)) {\r\n            deepFirstSearchStack(i);\r\n        }\r\n    }\r\n\r\n    // Step 4: Flatten the sorted faces back into an array\r\n    let index = 0;\r\n    sortedFaces.forEach((face) => {\r\n        indices[index++] = face[0];\r\n        indices[index++] = face[1];\r\n        indices[index++] = face[2];\r\n    });\r\n}\r\n"],"names":["getByteIndex","bitIndex","Math","floor","getBitMask","BitArray","size","this","_byteArray","Uint8Array","ceil","get","RangeError","byteIndex","bitMask","set","value","OptimizeIndices","indices","faces","faceCount","length","i","push","vertexToFaceMap","Map","forEach","face","faceIndex","vertex","visited","sortedFaces","deepFirstSearchStack","startFaceIndex","stack","currentFaceIndex","pop","neighbors","neighborFaceIndex","index"],"sourceRoot":""}