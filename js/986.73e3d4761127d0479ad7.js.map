{"version":3,"file":"js/986.73e3d4761127d0479ad7.js","mappings":"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","sources":["webpack://babylonjs-typescript-webpack-template/./dev/core/src/Compute/computeEffect.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Engines/WebGPU/webgpuComputeContext.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Engines/WebGPU/webgpuComputePipelineContext.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Engines/WebGPU/Extensions/engine.computeShader.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Engines/WebGPU/Extensions/engine.debugging.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Engines/WebGPU/Extensions/engine.dynamicTexture.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Engines/WebGPU/Extensions/engine.multiRender.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Engines/WebGPU/Extensions/engine.videoTexture.ts"],"sourcesContent":["import { Logger } from \"../Misc/logger\";\r\nimport type { Nullable } from \"../types\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport type { IComputePipelineContext } from \"./IComputePipelineContext\";\r\nimport { GetDOMTextContent, IsWindowObjectExist } from \"../Misc/domManagement\";\r\nimport { Finalize, Initialize, PreProcess } from \"../Engines/Processors/shaderProcessor\";\r\nimport type { ProcessingOptions } from \"../Engines/Processors/shaderProcessingOptions\";\r\nimport { ShaderStore } from \"../Engines/shaderStore\";\r\nimport { ShaderLanguage } from \"../Materials/shaderLanguage\";\r\n\r\nimport type { AbstractEngine } from \"../Engines/abstractEngine\";\r\nimport type { ComputeCompilationMessages } from \"../Engines/Extensions/engine.computeShader\";\r\nimport { _retryWithInterval } from \"core/Misc/timingTools\";\r\n\r\n/**\r\n * Defines the route to the shader code. The priority is as follows:\r\n *  * object: `{ computeSource: \"compute shader code string\"}` for directly passing the shader code\r\n *  * object: `{ computeElement: \"vertexShaderCode\" }`, used with shader code in script tags\r\n *  * object: `{ compute: \"custom\" }`, used with `Effect.ShadersStore[\"customVertexShader\"]` and `Effect.ShadersStore[\"customFragmentShader\"]`\r\n *  * string: `\"./COMMON_NAME\"`, used with external files COMMON_NAME.vertex.fx and COMMON_NAME.fragment.fx in index.html folder.\r\n */\r\nexport type IComputeShaderPath = {\r\n    /**\r\n     * Directly pass the shader code\r\n     */\r\n    computeSource?: string;\r\n    /**\r\n     * Used with Effect.ShadersStore. If the `vertex` is set to `\"custom`, then\r\n     * Babylon.js will read from Effect.ShadersStore[\"customVertexShader\"]\r\n     */\r\n    compute?: string;\r\n    /**\r\n     * Used with shader code in script tags\r\n     */\r\n    computeElement?: string;\r\n};\r\n\r\n/**\r\n * Options to be used when creating a compute effect.\r\n */\r\nexport interface IComputeEffectCreationOptions {\r\n    /**\r\n     * Define statements that will be set in the shader.\r\n     */\r\n    defines: any;\r\n    /**\r\n     * The name of the entry point in the shader source (default: \"main\")\r\n     */\r\n    entryPoint?: string;\r\n    /**\r\n     * Callback that will be called when the shader is compiled.\r\n     */\r\n    onCompiled: Nullable<(effect: ComputeEffect) => void>;\r\n    /**\r\n     * Callback that will be called if an error occurs during shader compilation.\r\n     */\r\n    onError: Nullable<(effect: ComputeEffect, errors: string) => void>;\r\n    /**\r\n     * If provided, will be called with the shader code so that this code can be updated before it is compiled by the GPU\r\n     */\r\n    processFinalCode?: Nullable<(code: string) => string>;\r\n}\r\n\r\n/**\r\n * Effect wrapping a compute shader and let execute (dispatch) the shader\r\n */\r\nexport class ComputeEffect {\r\n    private static _UniqueIdSeed = 0;\r\n\r\n    /**\r\n     * Enable logging of the shader code when a compilation error occurs\r\n     */\r\n    public static LogShaderCodeOnCompilationError = true;\r\n    /**\r\n     * Name of the effect.\r\n     */\r\n    public name: IComputeShaderPath | string;\r\n    /**\r\n     * String container all the define statements that should be set on the shader.\r\n     */\r\n    public defines: string = \"\";\r\n    /**\r\n     * Callback that will be called when the shader is compiled.\r\n     */\r\n    public onCompiled: Nullable<(effect: ComputeEffect) => void> = null;\r\n    /**\r\n     * Callback that will be called if an error occurs during shader compilation.\r\n     */\r\n    public onError: Nullable<(effect: ComputeEffect, errors: string) => void> = null;\r\n    /**\r\n     * Unique ID of the effect.\r\n     */\r\n    public uniqueId = 0;\r\n    /**\r\n     * Observable that will be called when the shader is compiled.\r\n     * It is recommended to use executeWhenCompile() or to make sure that scene.isReady() is called to get this observable raised.\r\n     */\r\n    public onCompileObservable = new Observable<ComputeEffect>();\r\n    /**\r\n     * Observable that will be called if an error occurs during shader compilation.\r\n     */\r\n    public onErrorObservable = new Observable<ComputeEffect>();\r\n    /**\r\n     * Observable that will be called when effect is bound.\r\n     */\r\n    public onBindObservable = new Observable<ComputeEffect>();\r\n\r\n    /**\r\n     * @internal\r\n     * Specifies if the effect was previously ready\r\n     */\r\n    public _wasPreviouslyReady = false;\r\n\r\n    private _engine: AbstractEngine;\r\n    private _isReady = false;\r\n    private _compilationError = \"\";\r\n    /** @internal */\r\n    public _key: string = \"\";\r\n    private _computeSourceCodeOverride: string = \"\";\r\n    /** @internal */\r\n    public _pipelineContext: Nullable<IComputePipelineContext> = null;\r\n    /** @internal */\r\n    public _computeSourceCode: string = \"\";\r\n    private _rawComputeSourceCode: string = \"\";\r\n    private _entryPoint: string;\r\n    private _shaderLanguage = ShaderLanguage.WGSL;\r\n    private _shaderStore: { [key: string]: string };\r\n    private _shaderRepository: string;\r\n    private _includeShaderStore: { [key: string]: string };\r\n\r\n    /**\r\n     * Creates a compute effect that can be used to execute a compute shader\r\n     * @param baseName Name of the effect\r\n     * @param options Set of all options to create the effect\r\n     * @param engine The engine the effect is created for\r\n     * @param key Effect Key identifying uniquely compiled shader variants\r\n     */\r\n    constructor(baseName: IComputeShaderPath | string, options: IComputeEffectCreationOptions, engine: AbstractEngine, key = \"\") {\r\n        this.name = baseName;\r\n        this._key = key;\r\n\r\n        this._engine = engine;\r\n        this.uniqueId = ComputeEffect._UniqueIdSeed++;\r\n\r\n        this.defines = options.defines ?? \"\";\r\n        this.onError = options.onError;\r\n        this.onCompiled = options.onCompiled;\r\n        this._entryPoint = options.entryPoint ?? \"main\";\r\n\r\n        this._shaderStore = ShaderStore.GetShadersStore(this._shaderLanguage);\r\n        this._shaderRepository = ShaderStore.GetShadersRepository(this._shaderLanguage);\r\n        this._includeShaderStore = ShaderStore.GetIncludesShadersStore(this._shaderLanguage);\r\n\r\n        let computeSource: IComputeShaderPath | HTMLElement | string;\r\n\r\n        const hostDocument = IsWindowObjectExist() ? this._engine.getHostDocument() : null;\r\n\r\n        if (typeof baseName === \"string\") {\r\n            computeSource = baseName;\r\n        } else if (baseName.computeSource) {\r\n            computeSource = \"source:\" + baseName.computeSource;\r\n        } else if (baseName.computeElement) {\r\n            computeSource = hostDocument?.getElementById(baseName.computeElement) || baseName.computeElement;\r\n        } else {\r\n            computeSource = baseName.compute || baseName;\r\n        }\r\n\r\n        const processorOptions: ProcessingOptions = {\r\n            defines: this.defines.split(\"\\n\"),\r\n            indexParameters: undefined,\r\n            isFragment: false,\r\n            shouldUseHighPrecisionShader: false,\r\n            processor: null,\r\n            supportsUniformBuffers: this._engine.supportsUniformBuffers,\r\n            shadersRepository: this._shaderRepository,\r\n            includesShadersStore: this._includeShaderStore,\r\n            version: (this._engine.version * 100).toString(),\r\n            platformName: this._engine.shaderPlatformName,\r\n            processingContext: null,\r\n            isNDCHalfZRange: this._engine.isNDCHalfZRange,\r\n            useReverseDepthBuffer: this._engine.useReverseDepthBuffer,\r\n            processCodeAfterIncludes: (shaderType: string, code: string, defines?: string[]) => {\r\n                if (!defines) {\r\n                    return code;\r\n                }\r\n                // We need to convert #define key value to a const\r\n                for (const define of defines) {\r\n                    const keyValue = define.replace(\"#define\", \"\").replace(\";\", \"\").trim();\r\n                    const split = keyValue.split(\" \");\r\n                    if (split.length === 2) {\r\n                        const key = split[0];\r\n                        const value = split[1];\r\n                        if (!isNaN(parseInt(value)) || !isNaN(parseFloat(value))) {\r\n                            code = `const ${key} = ${value};\\n` + code;\r\n                        }\r\n                    }\r\n                }\r\n                return code;\r\n            },\r\n        };\r\n\r\n        this._loadShader(computeSource, \"Compute\", \"\", (computeCode) => {\r\n            Initialize(processorOptions);\r\n            PreProcess(\r\n                computeCode,\r\n                processorOptions,\r\n                (migratedComputeCode) => {\r\n                    this._rawComputeSourceCode = computeCode;\r\n                    if (options.processFinalCode) {\r\n                        migratedComputeCode = options.processFinalCode(migratedComputeCode);\r\n                    }\r\n                    const finalShaders = Finalize(migratedComputeCode, \"\", processorOptions);\r\n                    this._useFinalCode(finalShaders.vertexCode, baseName);\r\n                },\r\n                this._engine\r\n            );\r\n        });\r\n    }\r\n\r\n    private _useFinalCode(migratedCommputeCode: string, baseName: any) {\r\n        if (baseName) {\r\n            const compute = baseName.computeElement || baseName.compute || baseName.spectorName || baseName;\r\n\r\n            this._computeSourceCode = \"//#define SHADER_NAME compute:\" + compute + \"\\n\" + migratedCommputeCode;\r\n        } else {\r\n            this._computeSourceCode = migratedCommputeCode;\r\n        }\r\n        this._prepareEffect();\r\n    }\r\n\r\n    /**\r\n     * Unique key for this effect\r\n     */\r\n    public get key(): string {\r\n        return this._key;\r\n    }\r\n\r\n    /**\r\n     * If the effect has been compiled and prepared.\r\n     * @returns if the effect is compiled and prepared.\r\n     */\r\n    public isReady(): boolean {\r\n        try {\r\n            return this._isReadyInternal();\r\n        } catch {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    private _isReadyInternal(): boolean {\r\n        if (this._isReady) {\r\n            return true;\r\n        }\r\n        if (this._pipelineContext) {\r\n            return this._pipelineContext.isReady;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * The engine the effect was initialized with.\r\n     * @returns the engine.\r\n     */\r\n    public getEngine(): AbstractEngine {\r\n        return this._engine;\r\n    }\r\n\r\n    /**\r\n     * The pipeline context for this effect\r\n     * @returns the associated pipeline context\r\n     */\r\n    public getPipelineContext(): Nullable<IComputePipelineContext> {\r\n        return this._pipelineContext;\r\n    }\r\n\r\n    /**\r\n     * The error from the last compilation.\r\n     * @returns the error string.\r\n     */\r\n    public getCompilationError(): string {\r\n        return this._compilationError;\r\n    }\r\n\r\n    /**\r\n     * Adds a callback to the onCompiled observable and call the callback immediately if already ready.\r\n     * @param func The callback to be used.\r\n     */\r\n    public executeWhenCompiled(func: (effect: ComputeEffect) => void): void {\r\n        if (this.isReady()) {\r\n            func(this);\r\n            return;\r\n        }\r\n\r\n        this.onCompileObservable.add((effect) => {\r\n            func(effect);\r\n        });\r\n\r\n        if (!this._pipelineContext || this._pipelineContext.isAsync) {\r\n            this._checkIsReady(null);\r\n        }\r\n    }\r\n\r\n    private _checkIsReady(previousPipelineContext: Nullable<IComputePipelineContext>) {\r\n        _retryWithInterval(\r\n            () => this._isReadyInternal(),\r\n            () => {\r\n                // no-op, all work is done in _isReadyInternal\r\n            },\r\n            (e) => {\r\n                this._processCompilationErrors(e, previousPipelineContext);\r\n            },\r\n            undefined,\r\n            undefined,\r\n            false\r\n        );\r\n    }\r\n\r\n    private _loadShader(shader: any, key: string, optionalKey: string, callback: (data: any) => void): void {\r\n        if (typeof HTMLElement !== \"undefined\") {\r\n            // DOM element ?\r\n            if (shader instanceof HTMLElement) {\r\n                const shaderCode = GetDOMTextContent(shader);\r\n                callback(shaderCode);\r\n                return;\r\n            }\r\n        }\r\n\r\n        // Direct source ?\r\n        if (shader.substring(0, 7) === \"source:\") {\r\n            callback(shader.substring(7));\r\n            return;\r\n        }\r\n\r\n        // Base64 encoded ?\r\n        if (shader.substring(0, 7) === \"base64:\") {\r\n            const shaderBinary = window.atob(shader.substring(7));\r\n            callback(shaderBinary);\r\n            return;\r\n        }\r\n\r\n        // Is in local store ?\r\n        if (this._shaderStore[shader + key + \"Shader\"]) {\r\n            callback(this._shaderStore[shader + key + \"Shader\"]);\r\n            return;\r\n        }\r\n\r\n        if (optionalKey && this._shaderStore[shader + optionalKey + \"Shader\"]) {\r\n            callback(this._shaderStore[shader + optionalKey + \"Shader\"]);\r\n            return;\r\n        }\r\n\r\n        let shaderUrl;\r\n\r\n        if (shader[0] === \".\" || shader[0] === \"/\" || shader.indexOf(\"http\") > -1) {\r\n            shaderUrl = shader;\r\n        } else {\r\n            shaderUrl = this._shaderRepository + shader;\r\n        }\r\n\r\n        this._engine._loadFile(shaderUrl + \".\" + key.toLowerCase() + \".fx\", callback);\r\n    }\r\n\r\n    /**\r\n     * Gets the compute shader source code of this effect\r\n     */\r\n    public get computeSourceCode(): string {\r\n        return this._computeSourceCodeOverride ? this._computeSourceCodeOverride : (this._pipelineContext?._getComputeShaderCode() ?? this._computeSourceCode);\r\n    }\r\n\r\n    /**\r\n     * Gets the compute shader source code before it has been processed by the preprocessor\r\n     */\r\n    public get rawComputeSourceCode(): string {\r\n        return this._rawComputeSourceCode;\r\n    }\r\n\r\n    /**\r\n     * Prepares the effect\r\n     * @internal\r\n     */\r\n    public _prepareEffect() {\r\n        const defines = this.defines;\r\n\r\n        const previousPipelineContext = this._pipelineContext;\r\n\r\n        this._isReady = false;\r\n\r\n        try {\r\n            const engine = this._engine;\r\n\r\n            this._pipelineContext = engine.createComputePipelineContext();\r\n            this._pipelineContext._name = this._key;\r\n\r\n            engine._prepareComputePipelineContext(\r\n                this._pipelineContext,\r\n                this._computeSourceCodeOverride ? this._computeSourceCodeOverride : this._computeSourceCode,\r\n                this._rawComputeSourceCode,\r\n                this._computeSourceCodeOverride ? null : defines,\r\n                this._entryPoint\r\n            );\r\n\r\n            engine._executeWhenComputeStateIsCompiled(this._pipelineContext, (messages: Nullable<ComputeCompilationMessages>) => {\r\n                if (messages && messages.numErrors > 0) {\r\n                    this._processCompilationErrors(messages, previousPipelineContext);\r\n                    return;\r\n                }\r\n                this._compilationError = \"\";\r\n                this._isReady = true;\r\n                if (this.onCompiled) {\r\n                    this.onCompiled(this);\r\n                }\r\n                this.onCompileObservable.notifyObservers(this);\r\n                this.onCompileObservable.clear();\r\n\r\n                if (previousPipelineContext) {\r\n                    this.getEngine()._deleteComputePipelineContext(previousPipelineContext);\r\n                }\r\n            });\r\n\r\n            if (this._pipelineContext.isAsync) {\r\n                this._checkIsReady(previousPipelineContext);\r\n            }\r\n        } catch (e) {\r\n            this._processCompilationErrors(e, previousPipelineContext);\r\n        }\r\n    }\r\n\r\n    private _processCompilationErrors(e: ComputeCompilationMessages | string, previousPipelineContext: Nullable<IComputePipelineContext> = null) {\r\n        this._compilationError = \"\";\r\n\r\n        Logger.Error(\"Unable to compile compute effect:\");\r\n        if (this.defines) {\r\n            Logger.Error(\"Defines:\\n\" + this.defines);\r\n        }\r\n\r\n        if (ComputeEffect.LogShaderCodeOnCompilationError) {\r\n            const code = this._pipelineContext?._getComputeShaderCode();\r\n            if (code) {\r\n                Logger.Error(\"Compute code:\");\r\n                Logger.Error(code);\r\n            }\r\n        }\r\n\r\n        if (typeof e === \"string\") {\r\n            this._compilationError = e;\r\n            Logger.Error(\"Error: \" + this._compilationError);\r\n        } else {\r\n            for (const message of e.messages) {\r\n                let msg = \"\";\r\n                if (message.line !== undefined) {\r\n                    msg += \"Line \" + message.line + \", \";\r\n                }\r\n                if (message.offset !== undefined) {\r\n                    msg += \"Offset \" + message.offset + \", \";\r\n                }\r\n                if (message.length !== undefined) {\r\n                    msg += \"Length \" + message.length + \", \";\r\n                }\r\n                msg += message.type + \": \" + message.text;\r\n\r\n                if (this._compilationError) {\r\n                    this._compilationError += \"\\n\";\r\n                }\r\n                this._compilationError += msg;\r\n                Logger.Error(msg);\r\n            }\r\n        }\r\n\r\n        if (previousPipelineContext) {\r\n            this._pipelineContext = previousPipelineContext;\r\n            this._isReady = true;\r\n        }\r\n\r\n        if (this.onError) {\r\n            this.onError(this, this._compilationError);\r\n        }\r\n        this.onErrorObservable.notifyObservers(this);\r\n    }\r\n\r\n    /**\r\n     * Release all associated resources.\r\n     **/\r\n    public dispose() {\r\n        if (this._pipelineContext) {\r\n            this._pipelineContext.dispose();\r\n        }\r\n        this._engine._releaseComputeEffect(this);\r\n    }\r\n\r\n    /**\r\n     * This function will add a new compute shader to the shader store\r\n     * @param name the name of the shader\r\n     * @param computeShader compute shader content\r\n     */\r\n    public static RegisterShader(name: string, computeShader: string) {\r\n        ShaderStore.GetShadersStore(ShaderLanguage.WGSL)[`${name}ComputeShader`] = computeShader;\r\n    }\r\n}\r\n","import type { DataBuffer } from \"core/Buffers/dataBuffer\";\r\nimport type { StorageBuffer } from \"../../Buffers/storageBuffer\";\r\nimport type { IComputeContext } from \"../../Compute/IComputeContext\";\r\nimport type { BaseTexture } from \"../../Materials/Textures/baseTexture\";\r\nimport type { TextureSampler } from \"../../Materials/Textures/textureSampler\";\r\nimport type { UniformBuffer } from \"../../Materials/uniformBuffer\";\r\nimport { Logger } from \"../../Misc/logger\";\r\nimport type { ComputeBindingList, ComputeBindingMapping } from \"../Extensions/engine.computeShader\";\r\nimport { ComputeBindingType } from \"../Extensions/engine.computeShader\";\r\nimport type { WebGPUCacheSampler } from \"./webgpuCacheSampler\";\r\nimport * as WebGPUConstants from \"./webgpuConstants\";\r\nimport type { WebGPUHardwareTexture } from \"./webgpuHardwareTexture\";\r\nimport type { ExternalTexture } from \"core/Materials/Textures/externalTexture\";\r\n\r\n/** @internal */\r\nexport class WebGPUComputeContext implements IComputeContext {\r\n    private static _Counter = 0;\r\n\r\n    public readonly uniqueId: number;\r\n\r\n    private _device: GPUDevice;\r\n    private _cacheSampler: WebGPUCacheSampler;\r\n    private _bindGroups: GPUBindGroup[];\r\n    private _bindGroupEntries: GPUBindGroupEntry[][];\r\n\r\n    public getBindGroups(bindings: ComputeBindingList, computePipeline: GPUComputePipeline, bindingsMapping?: ComputeBindingMapping): GPUBindGroup[] {\r\n        if (!bindingsMapping) {\r\n            throw new Error(\"WebGPUComputeContext.getBindGroups: bindingsMapping is required until browsers support reflection for wgsl shaders!\");\r\n        }\r\n        if (this._bindGroups.length === 0) {\r\n            const bindGroupEntriesExist = this._bindGroupEntries.length > 0;\r\n            for (const key in bindings) {\r\n                const binding = bindings[key],\r\n                    location = bindingsMapping[key],\r\n                    group = location.group,\r\n                    index = location.binding,\r\n                    type = binding.type,\r\n                    object = binding.object;\r\n                let indexInGroupEntries = binding.indexInGroupEntries;\r\n\r\n                let entries = this._bindGroupEntries[group];\r\n                if (!entries) {\r\n                    entries = this._bindGroupEntries[group] = [];\r\n                }\r\n\r\n                switch (type) {\r\n                    case ComputeBindingType.Sampler: {\r\n                        const sampler = object as TextureSampler;\r\n                        if (indexInGroupEntries !== undefined && bindGroupEntriesExist) {\r\n                            entries[indexInGroupEntries].resource = this._cacheSampler.getSampler(sampler);\r\n                        } else {\r\n                            binding.indexInGroupEntries = entries.length;\r\n                            entries.push({\r\n                                binding: index,\r\n                                resource: this._cacheSampler.getSampler(sampler),\r\n                            });\r\n                        }\r\n                        break;\r\n                    }\r\n\r\n                    case ComputeBindingType.Texture:\r\n                    case ComputeBindingType.TextureWithoutSampler: {\r\n                        const texture = object as BaseTexture;\r\n                        const hardwareTexture = texture._texture!._hardwareTexture as WebGPUHardwareTexture;\r\n                        if (indexInGroupEntries !== undefined && bindGroupEntriesExist) {\r\n                            if (type === ComputeBindingType.Texture) {\r\n                                entries[indexInGroupEntries++].resource = this._cacheSampler.getSampler(texture._texture!);\r\n                            }\r\n                            entries[indexInGroupEntries].resource = hardwareTexture.view!;\r\n                        } else {\r\n                            binding.indexInGroupEntries = entries.length;\r\n                            if (type === ComputeBindingType.Texture) {\r\n                                entries.push({\r\n                                    binding: index - 1,\r\n                                    resource: this._cacheSampler.getSampler(texture._texture!),\r\n                                });\r\n                            }\r\n                            entries.push({\r\n                                binding: index,\r\n                                resource: hardwareTexture.view!,\r\n                            });\r\n                        }\r\n                        break;\r\n                    }\r\n\r\n                    case ComputeBindingType.StorageTexture: {\r\n                        const texture = object as BaseTexture;\r\n                        const hardwareTexture = texture._texture!._hardwareTexture as WebGPUHardwareTexture;\r\n                        if ((hardwareTexture.textureAdditionalUsages & WebGPUConstants.TextureUsage.StorageBinding) === 0) {\r\n                            Logger.Error(`computeDispatch: The texture (name=${texture.name}, uniqueId=${texture.uniqueId}) is not a storage texture!`, 50);\r\n                        }\r\n                        if (indexInGroupEntries !== undefined && bindGroupEntriesExist) {\r\n                            entries[indexInGroupEntries].resource = hardwareTexture.viewForWriting!;\r\n                        } else {\r\n                            binding.indexInGroupEntries = entries.length;\r\n                            entries.push({\r\n                                binding: index,\r\n                                resource: hardwareTexture.viewForWriting!,\r\n                            });\r\n                        }\r\n                        break;\r\n                    }\r\n\r\n                    case ComputeBindingType.ExternalTexture: {\r\n                        const texture = object as ExternalTexture;\r\n                        const externalTexture = texture.underlyingResource;\r\n                        if (indexInGroupEntries !== undefined && bindGroupEntriesExist) {\r\n                            entries[indexInGroupEntries].resource = this._device.importExternalTexture({ source: externalTexture });\r\n                        } else {\r\n                            binding.indexInGroupEntries = entries.length;\r\n                            entries.push({\r\n                                binding: index,\r\n                                resource: this._device.importExternalTexture({ source: externalTexture }),\r\n                            });\r\n                        }\r\n                        break;\r\n                    }\r\n\r\n                    case ComputeBindingType.UniformBuffer:\r\n                    case ComputeBindingType.StorageBuffer:\r\n                    case ComputeBindingType.DataBuffer: {\r\n                        const dataBuffer =\r\n                            type === ComputeBindingType.DataBuffer\r\n                                ? (object as DataBuffer)\r\n                                : type === ComputeBindingType.UniformBuffer\r\n                                  ? (object as UniformBuffer).getBuffer()!\r\n                                  : (object as StorageBuffer).getBuffer()!;\r\n                        const webgpuBuffer = dataBuffer.underlyingResource as GPUBuffer;\r\n                        if (indexInGroupEntries !== undefined && bindGroupEntriesExist) {\r\n                            (entries[indexInGroupEntries].resource as GPUBufferBinding).buffer = webgpuBuffer;\r\n                            (entries[indexInGroupEntries].resource as GPUBufferBinding).size = dataBuffer.capacity;\r\n                        } else {\r\n                            binding.indexInGroupEntries = entries.length;\r\n                            entries.push({\r\n                                binding: index,\r\n                                resource: {\r\n                                    buffer: webgpuBuffer,\r\n                                    offset: 0,\r\n                                    size: dataBuffer.capacity,\r\n                                },\r\n                            });\r\n                        }\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n\r\n            for (let i = 0; i < this._bindGroupEntries.length; ++i) {\r\n                const entries = this._bindGroupEntries[i];\r\n                if (!entries) {\r\n                    this._bindGroups[i] = undefined as any;\r\n                    continue;\r\n                }\r\n                this._bindGroups[i] = this._device.createBindGroup({\r\n                    layout: computePipeline.getBindGroupLayout(i),\r\n                    entries,\r\n                });\r\n            }\r\n\r\n            this._bindGroups.length = this._bindGroupEntries.length;\r\n        }\r\n\r\n        return this._bindGroups;\r\n    }\r\n\r\n    constructor(device: GPUDevice, cacheSampler: WebGPUCacheSampler) {\r\n        this._device = device;\r\n        this._cacheSampler = cacheSampler;\r\n        this.uniqueId = WebGPUComputeContext._Counter++;\r\n        this._bindGroupEntries = [];\r\n        this.clear();\r\n    }\r\n\r\n    public clear(): void {\r\n        this._bindGroups = [];\r\n        // Don't reset _bindGroupEntries if they have already been created, they are still ok even if we have to clear _bindGroups (the layout of the compute shader can't change once created)\r\n    }\r\n}\r\n","import type { IComputePipelineContext } from \"../../Compute/IComputePipelineContext\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { WebGPUEngine } from \"../webgpuEngine\";\r\n\r\n/** @internal */\r\nexport class WebGPUComputePipelineContext implements IComputePipelineContext {\r\n    public engine: WebGPUEngine;\r\n\r\n    public sources: {\r\n        compute: string;\r\n        rawCompute: string;\r\n    };\r\n\r\n    public stage: Nullable<GPUProgrammableStage>;\r\n\r\n    public computePipeline: GPUComputePipeline;\r\n\r\n    public get isAsync() {\r\n        return false;\r\n    }\r\n\r\n    public get isReady(): boolean {\r\n        if (this.isAsync) {\r\n            // When async mode is implemented, this should return true if the pipeline is ready\r\n            return false;\r\n        }\r\n\r\n        // In synchronous mode, we return false, the readiness being determined by ComputeEffect\r\n        return false;\r\n    }\r\n\r\n    /** @internal */\r\n    public _name: string;\r\n\r\n    constructor(engine: WebGPUEngine) {\r\n        this._name = \"unnamed\";\r\n        this.engine = engine;\r\n    }\r\n\r\n    public _getComputeShaderCode(): string | null {\r\n        return this.sources?.compute;\r\n    }\r\n\r\n    public dispose(): void {}\r\n}\r\n","import { Logger } from \"core/Misc/logger\";\r\nimport type { IComputeEffectCreationOptions, IComputeShaderPath } from \"../../../Compute/computeEffect\";\r\nimport { ComputeEffect } from \"../../../Compute/computeEffect\";\r\nimport type { IComputeContext } from \"../../../Compute/IComputeContext\";\r\nimport type { IComputePipelineContext } from \"../../../Compute/IComputePipelineContext\";\r\nimport type { Nullable } from \"../../../types\";\r\nimport type { ComputeBindingList, ComputeBindingMapping, ComputeCompilationMessages } from \"../../Extensions/engine.computeShader\";\r\nimport { WebGPUEngine } from \"../../webgpuEngine\";\r\nimport { WebGPUComputeContext } from \"../webgpuComputeContext\";\r\nimport { WebGPUComputePipelineContext } from \"../webgpuComputePipelineContext\";\r\nimport * as WebGPUConstants from \"../webgpuConstants\";\r\nimport type { WebGPUPerfCounter } from \"../webgpuPerfCounter\";\r\nimport type { DataBuffer } from \"../../../Buffers/dataBuffer\";\r\n\r\ndeclare module \"../../webgpuEngine\" {\r\n    export interface WebGPUEngine {\r\n        /** @internal */\r\n        _createComputePipelineStageDescriptor(computeShader: string, defines: Nullable<string>, entryPoint: string): GPUProgrammableStage;\r\n        /** @internal\r\n         * Either all of x,y,z or buffer and offset should be defined.\r\n         */\r\n        _computeDispatch(\r\n            effect: ComputeEffect,\r\n            context: IComputeContext,\r\n            bindings: ComputeBindingList,\r\n            x?: number,\r\n            y?: number,\r\n            z?: number,\r\n            buffer?: DataBuffer,\r\n            offset?: number,\r\n            bindingsMapping?: ComputeBindingMapping,\r\n            gpuPerfCounter?: WebGPUPerfCounter\r\n        ): void;\r\n    }\r\n}\r\n\r\nconst computePassDescriptor: GPUComputePassDescriptor = {};\r\n\r\nWebGPUEngine.prototype.createComputeContext = function (): IComputeContext | undefined {\r\n    return new WebGPUComputeContext(this._device, this._cacheSampler);\r\n};\r\n\r\nWebGPUEngine.prototype.createComputeEffect = function (baseName: string | (IComputeShaderPath & { computeToken?: string }), options: IComputeEffectCreationOptions): ComputeEffect {\r\n    const compute = typeof baseName === \"string\" ? baseName : baseName.computeToken || baseName.computeSource || baseName.computeElement || baseName.compute;\r\n\r\n    const name = compute + \"@\" + options.defines;\r\n    if (this._compiledComputeEffects[name]) {\r\n        const compiledEffect = <ComputeEffect>this._compiledComputeEffects[name];\r\n        if (options.onCompiled && compiledEffect.isReady()) {\r\n            options.onCompiled(compiledEffect);\r\n        }\r\n\r\n        return compiledEffect;\r\n    }\r\n    const effect = new ComputeEffect(baseName, options, this, name);\r\n    this._compiledComputeEffects[name] = effect;\r\n\r\n    return effect;\r\n};\r\n\r\nWebGPUEngine.prototype.createComputePipelineContext = function (): IComputePipelineContext {\r\n    return new WebGPUComputePipelineContext(this);\r\n};\r\n\r\nWebGPUEngine.prototype.areAllComputeEffectsReady = function (): boolean {\r\n    for (const key in this._compiledComputeEffects) {\r\n        const effect = this._compiledComputeEffects[key];\r\n\r\n        if (!effect.isReady()) {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    return true;\r\n};\r\n\r\nWebGPUEngine.prototype.computeDispatch = function (\r\n    effect: ComputeEffect,\r\n    context: IComputeContext,\r\n    bindings: ComputeBindingList,\r\n    x: number,\r\n    y = 1,\r\n    z = 1,\r\n    bindingsMapping?: ComputeBindingMapping,\r\n    gpuPerfCounter?: WebGPUPerfCounter\r\n): void {\r\n    this._computeDispatch(effect, context, bindings, x, y, z, undefined, undefined, bindingsMapping, gpuPerfCounter);\r\n};\r\n\r\nWebGPUEngine.prototype.computeDispatchIndirect = function (\r\n    effect: ComputeEffect,\r\n    context: IComputeContext,\r\n    bindings: ComputeBindingList,\r\n    buffer: DataBuffer,\r\n    offset: number = 0,\r\n    bindingsMapping?: ComputeBindingMapping,\r\n    gpuPerfCounter?: WebGPUPerfCounter\r\n): void {\r\n    this._computeDispatch(effect, context, bindings, undefined, undefined, undefined, buffer, offset, bindingsMapping, gpuPerfCounter);\r\n};\r\n\r\nWebGPUEngine.prototype._computeDispatch = function (\r\n    effect: ComputeEffect,\r\n    context: IComputeContext,\r\n    bindings: ComputeBindingList,\r\n    x?: number,\r\n    y?: number,\r\n    z?: number,\r\n    buffer?: DataBuffer,\r\n    offset?: number,\r\n    bindingsMapping?: ComputeBindingMapping,\r\n    gpuPerfCounter?: WebGPUPerfCounter\r\n): void {\r\n    this._endCurrentRenderPass();\r\n\r\n    const contextPipeline = effect._pipelineContext as WebGPUComputePipelineContext;\r\n    const computeContext = context as WebGPUComputeContext;\r\n\r\n    if (!contextPipeline.computePipeline) {\r\n        contextPipeline.computePipeline = this._device.createComputePipeline({\r\n            layout: WebGPUConstants.AutoLayoutMode.Auto,\r\n            compute: contextPipeline.stage!,\r\n        });\r\n    }\r\n\r\n    if (gpuPerfCounter) {\r\n        this._timestampQuery.startPass(computePassDescriptor, this._timestampIndex);\r\n    }\r\n\r\n    const computePass = this._renderEncoder.beginComputePass(computePassDescriptor);\r\n\r\n    computePass.setPipeline(contextPipeline.computePipeline);\r\n\r\n    const bindGroups = computeContext.getBindGroups(bindings, contextPipeline.computePipeline, bindingsMapping);\r\n    for (let i = 0; i < bindGroups.length; ++i) {\r\n        const bindGroup = bindGroups[i];\r\n        if (!bindGroup) {\r\n            continue;\r\n        }\r\n        computePass.setBindGroup(i, bindGroup);\r\n    }\r\n\r\n    if (buffer !== undefined) {\r\n        computePass.dispatchWorkgroupsIndirect(buffer.underlyingResource, <number>offset);\r\n    } else {\r\n        if (<number>x + <number>y + <number>z > 0) {\r\n            computePass.dispatchWorkgroups(<number>x, <number>y, <number>z);\r\n        }\r\n    }\r\n    computePass.end();\r\n\r\n    if (gpuPerfCounter) {\r\n        this._timestampQuery.endPass(this._timestampIndex, gpuPerfCounter);\r\n        this._timestampIndex += 2;\r\n    }\r\n};\r\n\r\nWebGPUEngine.prototype.releaseComputeEffects = function () {\r\n    for (const name in this._compiledComputeEffects) {\r\n        const webGPUPipelineContextCompute = this._compiledComputeEffects[name].getPipelineContext() as WebGPUComputePipelineContext;\r\n        this._deleteComputePipelineContext(webGPUPipelineContextCompute);\r\n    }\r\n\r\n    this._compiledComputeEffects = {};\r\n};\r\n\r\nWebGPUEngine.prototype._prepareComputePipelineContext = function (\r\n    pipelineContext: IComputePipelineContext,\r\n    computeSourceCode: string,\r\n    rawComputeSourceCode: string,\r\n    defines: Nullable<string>,\r\n    entryPoint: string\r\n): void {\r\n    const webGpuContext = pipelineContext as WebGPUComputePipelineContext;\r\n\r\n    if (this.dbgShowShaderCode) {\r\n        Logger.Log(defines!);\r\n        Logger.Log(computeSourceCode);\r\n    }\r\n\r\n    webGpuContext.sources = {\r\n        compute: computeSourceCode,\r\n        rawCompute: rawComputeSourceCode,\r\n    };\r\n\r\n    webGpuContext.stage = this._createComputePipelineStageDescriptor(computeSourceCode, defines, entryPoint);\r\n};\r\n\r\nWebGPUEngine.prototype._releaseComputeEffect = function (effect: ComputeEffect): void {\r\n    if (this._compiledComputeEffects[effect._key]) {\r\n        delete this._compiledComputeEffects[effect._key];\r\n\r\n        this._deleteComputePipelineContext(effect.getPipelineContext() as WebGPUComputePipelineContext);\r\n    }\r\n};\r\n\r\nWebGPUEngine.prototype._rebuildComputeEffects = function (): void {\r\n    for (const key in this._compiledComputeEffects) {\r\n        const effect = this._compiledComputeEffects[key];\r\n\r\n        effect._pipelineContext = null;\r\n        effect._wasPreviouslyReady = false;\r\n        effect._prepareEffect();\r\n    }\r\n};\r\n\r\nWebGPUEngine.prototype._executeWhenComputeStateIsCompiled = function (\r\n    pipelineContext: WebGPUComputePipelineContext,\r\n    action: (messages: Nullable<ComputeCompilationMessages>) => void\r\n): void {\r\n    pipelineContext.stage!.module.getCompilationInfo().then((info) => {\r\n        const compilationMessages: ComputeCompilationMessages = {\r\n            numErrors: 0,\r\n            messages: [],\r\n        };\r\n        for (const message of info.messages) {\r\n            if (message.type === \"error\") {\r\n                compilationMessages.numErrors++;\r\n            }\r\n            compilationMessages.messages.push({\r\n                type: message.type,\r\n                text: message.message,\r\n                line: message.lineNum,\r\n                column: message.linePos,\r\n                length: message.length,\r\n                offset: message.offset,\r\n            });\r\n        }\r\n        action(compilationMessages);\r\n    });\r\n};\r\n\r\nWebGPUEngine.prototype._deleteComputePipelineContext = function (pipelineContext: IComputePipelineContext): void {\r\n    const webgpuPipelineContext = pipelineContext as WebGPUComputePipelineContext;\r\n    if (webgpuPipelineContext) {\r\n        pipelineContext.dispose();\r\n    }\r\n};\r\n\r\nWebGPUEngine.prototype._createComputePipelineStageDescriptor = function (computeShader: string, defines: Nullable<string>, entryPoint: string): GPUProgrammableStage {\r\n    if (defines) {\r\n        defines = \"//\" + defines.split(\"\\n\").join(\"\\n//\") + \"\\n\";\r\n    } else {\r\n        defines = \"\";\r\n    }\r\n    return {\r\n        module: this._device.createShaderModule({\r\n            code: defines + computeShader,\r\n        }),\r\n        entryPoint,\r\n    };\r\n};\r\n","import { WebGPUEngine } from \"../../webgpuEngine\";\r\n\r\nWebGPUEngine.prototype._debugPushGroup = function (groupName: string, targetObject?: number): void {\r\n    if (!this._options.enableGPUDebugMarkers) {\r\n        return;\r\n    }\r\n\r\n    if (targetObject === 0 || targetObject === 1) {\r\n        if (targetObject === 1) {\r\n            if (this._currentRenderTarget) {\r\n                this.unBindFramebuffer(this._currentRenderTarget);\r\n            } else {\r\n                this._endCurrentRenderPass();\r\n            }\r\n        }\r\n        this._renderEncoder.pushDebugGroup(groupName);\r\n    } else if (this._currentRenderPass) {\r\n        this._currentRenderPass.pushDebugGroup(groupName);\r\n        this._debugStackRenderPass.push(groupName);\r\n    } else {\r\n        this._pendingDebugCommands.push([\"push\", groupName, targetObject]);\r\n    }\r\n};\r\n\r\nWebGPUEngine.prototype._debugPopGroup = function (targetObject?: number): void {\r\n    if (!this._options.enableGPUDebugMarkers) {\r\n        return;\r\n    }\r\n\r\n    if (targetObject === 0 || targetObject === 1) {\r\n        if (targetObject === 1) {\r\n            if (this._currentRenderTarget) {\r\n                this.unBindFramebuffer(this._currentRenderTarget);\r\n            } else {\r\n                this._endCurrentRenderPass();\r\n            }\r\n        }\r\n        this._renderEncoder.popDebugGroup();\r\n    } else if (this._currentRenderPass) {\r\n        this._currentRenderPass.popDebugGroup();\r\n        this._debugStackRenderPass.pop();\r\n    } else {\r\n        this._pendingDebugCommands.push([\"pop\", null, targetObject]);\r\n    }\r\n};\r\n\r\nWebGPUEngine.prototype._debugInsertMarker = function (text: string, targetObject?: number): void {\r\n    if (!this._options.enableGPUDebugMarkers) {\r\n        return;\r\n    }\r\n\r\n    if (targetObject === 0 || targetObject === 1) {\r\n        if (targetObject === 1) {\r\n            if (this._currentRenderTarget) {\r\n                this.unBindFramebuffer(this._currentRenderTarget);\r\n            } else {\r\n                this._endCurrentRenderPass();\r\n            }\r\n        }\r\n        this._renderEncoder.insertDebugMarker(text);\r\n    } else if (this._currentRenderPass) {\r\n        this._currentRenderPass.insertDebugMarker(text);\r\n    } else {\r\n        this._pendingDebugCommands.push([\"insert\", text, targetObject]);\r\n    }\r\n};\r\n\r\nWebGPUEngine.prototype._debugFlushPendingCommands = function (): void {\r\n    if (this._debugStackRenderPass.length !== 0) {\r\n        const currentDebugStack = this._debugStackRenderPass.slice();\r\n        this._debugStackRenderPass.length = 0;\r\n        for (let i = 0; i < currentDebugStack.length; ++i) {\r\n            this._debugPushGroup(currentDebugStack[i], 2);\r\n        }\r\n    }\r\n\r\n    for (let i = 0; i < this._pendingDebugCommands.length; ++i) {\r\n        const [name, param, targetObject] = this._pendingDebugCommands[i];\r\n\r\n        switch (name) {\r\n            case \"push\":\r\n                this._debugPushGroup(param!, targetObject);\r\n                break;\r\n            case \"pop\":\r\n                this._debugPopGroup(targetObject);\r\n                break;\r\n            case \"insert\":\r\n                this._debugInsertMarker(param!, targetObject);\r\n                break;\r\n        }\r\n    }\r\n    this._pendingDebugCommands.length = 0;\r\n};\r\n","import { InternalTexture, InternalTextureSource } from \"../../../Materials/Textures/internalTexture\";\r\nimport type { ImageSource, Nullable } from \"../../../types\";\r\nimport { WebGPUEngine } from \"../../webgpuEngine\";\r\nimport type { WebGPUHardwareTexture } from \"../webgpuHardwareTexture\";\r\nimport { GetExponentOfTwo } from \"../../../Misc/tools.functions\";\r\nimport type { ICanvas } from \"../../../Engines/ICanvas\";\r\n\r\ndeclare module \"../../abstractEngine\" {\r\n    export interface AbstractEngine {\r\n        /**\r\n         * Creates a dynamic texture\r\n         * @param width defines the width of the texture\r\n         * @param height defines the height of the texture\r\n         * @param generateMipMaps defines if the engine should generate the mip levels\r\n         * @param samplingMode defines the required sampling mode (Texture.NEAREST_SAMPLINGMODE by default)\r\n         * @returns the dynamic texture inside an InternalTexture\r\n         */\r\n        createDynamicTexture(width: number, height: number, generateMipMaps: boolean, samplingMode: number): InternalTexture;\r\n\r\n        /**\r\n         * Update the content of a dynamic texture\r\n         * @param texture defines the texture to update\r\n         * @param source defines the source containing the data\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         * @param premulAlpha defines if alpha is stored as premultiplied\r\n         * @param format defines the format of the data\r\n         * @param forceBindTexture if the texture should be forced to be bound eg. after a graphics context loss (Default: false)\r\n         * @param allowGPUOptimization true to allow some specific GPU optimizations (subject to engine feature \"allowGPUOptimizationsForGUI\" being true)\r\n         */\r\n        updateDynamicTexture(\r\n            texture: Nullable<InternalTexture>,\r\n            source: ImageSource | ICanvas,\r\n            invertY?: boolean,\r\n            premulAlpha?: boolean,\r\n            format?: number,\r\n            forceBindTexture?: boolean,\r\n            allowGPUOptimization?: boolean\r\n        ): void;\r\n    }\r\n}\r\n\r\nWebGPUEngine.prototype.createDynamicTexture = function (width: number, height: number, generateMipMaps: boolean, samplingMode: number): InternalTexture {\r\n    const texture = new InternalTexture(this, InternalTextureSource.Dynamic);\r\n    texture.baseWidth = width;\r\n    texture.baseHeight = height;\r\n\r\n    if (generateMipMaps) {\r\n        width = this.needPOTTextures ? GetExponentOfTwo(width, this._caps.maxTextureSize) : width;\r\n        height = this.needPOTTextures ? GetExponentOfTwo(height, this._caps.maxTextureSize) : height;\r\n    }\r\n\r\n    texture.width = width;\r\n    texture.height = height;\r\n    texture.isReady = false;\r\n    texture.generateMipMaps = generateMipMaps;\r\n    texture.samplingMode = samplingMode;\r\n\r\n    this.updateTextureSamplingMode(samplingMode, texture);\r\n\r\n    this._internalTexturesCache.push(texture);\r\n\r\n    if (width && height) {\r\n        this._textureHelper.createGPUTextureForInternalTexture(texture, width, height);\r\n    }\r\n\r\n    return texture;\r\n};\r\n\r\nWebGPUEngine.prototype.updateDynamicTexture = function (\r\n    texture: Nullable<InternalTexture>,\r\n    source: ImageSource,\r\n    invertY: boolean,\r\n    premulAlpha: boolean = false,\r\n    format?: number,\r\n    forceBindTexture?: boolean,\r\n    allowGPUOptimization?: boolean\r\n): void {\r\n    if (!texture) {\r\n        return;\r\n    }\r\n\r\n    const width = source.width,\r\n        height = source.height;\r\n\r\n    let gpuTextureWrapper = texture._hardwareTexture as WebGPUHardwareTexture;\r\n\r\n    if (!texture._hardwareTexture?.underlyingResource) {\r\n        gpuTextureWrapper = this._textureHelper.createGPUTextureForInternalTexture(texture, width, height);\r\n    }\r\n\r\n    this._textureHelper.updateTexture(source, texture, width, height, texture.depth, gpuTextureWrapper.format, 0, 0, invertY, premulAlpha, 0, 0, allowGPUOptimization);\r\n    if (texture.generateMipMaps) {\r\n        this._generateMipmaps(texture);\r\n    }\r\n\r\n    texture._dynamicTextureSource = source;\r\n    texture._premulAlpha = premulAlpha;\r\n    texture.invertY = invertY || false;\r\n    texture.isReady = true;\r\n};\r\n","import { InternalTexture, InternalTextureSource } from \"../../../Materials/Textures/internalTexture\";\r\nimport type { IMultiRenderTargetOptions } from \"../../../Materials/Textures/multiRenderTarget\";\r\nimport { Logger } from \"../../../Misc/logger\";\r\nimport type { Nullable } from \"../../../types\";\r\nimport { Constants } from \"../../constants\";\r\nimport type { TextureSize } from \"../../../Materials/Textures/textureCreationOptions\";\r\nimport type { RenderTargetWrapper } from \"../../renderTargetWrapper\";\r\nimport { WebGPUEngine } from \"../../webgpuEngine\";\r\nimport type { WebGPURenderTargetWrapper } from \"../webgpuRenderTargetWrapper\";\r\nimport type { WebGPUHardwareTexture } from \"../webgpuHardwareTexture\";\r\ndeclare module \"../../abstractEngine\" {\r\n    export interface AbstractEngine {\r\n        /**\r\n         * Unbind a list of render target textures from the webGL context\r\n         * This is used only when drawBuffer extension or webGL2 are active\r\n         * @param rtWrapper defines the render target wrapper to unbind\r\n         * @param disableGenerateMipMaps defines a boolean indicating that mipmaps must not be generated\r\n         * @param onBeforeUnbind defines a function which will be called before the effective unbind\r\n         */\r\n        unBindMultiColorAttachmentFramebuffer(rtWrapper: RenderTargetWrapper, disableGenerateMipMaps: boolean, onBeforeUnbind?: () => void): void;\r\n\r\n        /**\r\n         * Create a multi render target texture\r\n         * @see https://doc.babylonjs.com/setup/support/webGL2#multiple-render-target\r\n         * @param size defines the size of the texture\r\n         * @param options defines the creation options\r\n         * @param initializeBuffers if set to true, the engine will make an initializing call of drawBuffers\r\n         * @returns a new render target wrapper ready to render textures\r\n         */\r\n        createMultipleRenderTarget(size: TextureSize, options: IMultiRenderTargetOptions, initializeBuffers?: boolean): RenderTargetWrapper;\r\n\r\n        /**\r\n         * Update the sample count for a given multiple render target texture\r\n         * @see https://doc.babylonjs.com/setup/support/webGL2#multisample-render-targets\r\n         * @param rtWrapper defines the render target wrapper to update\r\n         * @param samples defines the sample count to set\r\n         * @param initializeBuffers if set to true, the engine will make an initializing call of drawBuffers\r\n         * @returns the effective sample count (could be 0 if multisample render targets are not supported)\r\n         */\r\n        updateMultipleRenderTargetTextureSampleCount(rtWrapper: Nullable<RenderTargetWrapper>, samples: number, initializeBuffers?: boolean): number;\r\n\r\n        /**\r\n         * Generates mipmaps for the texture of the (multi) render target\r\n         * @param texture The render target containing the textures to generate the mipmaps for\r\n         */\r\n        generateMipMapsMultiFramebuffer(texture: RenderTargetWrapper): void;\r\n\r\n        /**\r\n         * Resolves the MSAA textures of the (multi) render target into their non-MSAA version.\r\n         * Note that if \"texture\" is not a MSAA render target, no resolve is performed.\r\n         * @param texture The render target texture containing the MSAA textures to resolve\r\n         */\r\n        resolveMultiFramebuffer(texture: RenderTargetWrapper): void;\r\n\r\n        /**\r\n         * Select a subsets of attachments to draw to.\r\n         * @param attachments gl attachments\r\n         */\r\n        bindAttachments(attachments: number[]): void;\r\n\r\n        /**\r\n         * Creates a layout object to draw/clear on specific textures in a MRT\r\n         * @param textureStatus textureStatus[i] indicates if the i-th is active\r\n         * @returns A layout to be fed to the engine, calling `bindAttachments`.\r\n         */\r\n        buildTextureLayout(textureStatus: boolean[]): number[];\r\n\r\n        /**\r\n         * Restores the webgl state to only draw on the main color attachment\r\n         * when the frame buffer associated is the canvas frame buffer\r\n         */\r\n        restoreSingleAttachment(): void;\r\n\r\n        /**\r\n         * Restores the webgl state to only draw on the main color attachment\r\n         * when the frame buffer associated is not the canvas frame buffer\r\n         */\r\n        restoreSingleAttachmentForRenderTarget(): void;\r\n    }\r\n}\r\n\r\nWebGPUEngine.prototype.unBindMultiColorAttachmentFramebuffer = function (\r\n    rtWrapper: RenderTargetWrapper,\r\n    disableGenerateMipMaps: boolean = false,\r\n    onBeforeUnbind?: () => void\r\n): void {\r\n    if (onBeforeUnbind) {\r\n        onBeforeUnbind();\r\n    }\r\n\r\n    this._endCurrentRenderPass();\r\n\r\n    if (!disableGenerateMipMaps) {\r\n        this.generateMipMapsMultiFramebuffer(rtWrapper);\r\n    }\r\n\r\n    this._currentRenderTarget = null;\r\n\r\n    this._mrtAttachments = [];\r\n    this._cacheRenderPipeline.setMRT([]);\r\n    this._cacheRenderPipeline.setMRTAttachments(this._mrtAttachments);\r\n};\r\n\r\nWebGPUEngine.prototype.createMultipleRenderTarget = function (size: TextureSize, options: IMultiRenderTargetOptions, initializeBuffers?: boolean): RenderTargetWrapper {\r\n    let generateMipMaps = false;\r\n    let generateDepthBuffer = true;\r\n    let generateStencilBuffer = false;\r\n    let generateDepthTexture = false;\r\n    let depthTextureFormat = Constants.TEXTUREFORMAT_DEPTH16;\r\n    let textureCount = 1;\r\n    let samples = 1;\r\n\r\n    const defaultType = Constants.TEXTURETYPE_UNSIGNED_BYTE;\r\n    const defaultSamplingMode = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE;\r\n    const defaultUseSRGBBuffer = false;\r\n    const defaultFormat = Constants.TEXTUREFORMAT_RGBA;\r\n    const defaultTarget = Constants.TEXTURE_2D;\r\n\r\n    let types: number[] = [];\r\n    let samplingModes: number[] = [];\r\n    let useSRGBBuffers: boolean[] = [];\r\n    let formats: number[] = [];\r\n    let targets: number[] = [];\r\n    let faceIndex: number[] = [];\r\n    let layerIndex: number[] = [];\r\n    let layers: number[] = [];\r\n    let labels: string[] = [];\r\n    let creationFlags: number[] = [];\r\n    let dontCreateTextures = false;\r\n\r\n    const rtWrapper = this._createHardwareRenderTargetWrapper(true, false, size) as WebGPURenderTargetWrapper;\r\n\r\n    if (options !== undefined) {\r\n        generateMipMaps = options.generateMipMaps ?? false;\r\n        generateDepthBuffer = options.generateDepthBuffer ?? true;\r\n        generateStencilBuffer = options.generateStencilBuffer ?? false;\r\n        generateDepthTexture = options.generateDepthTexture ?? false;\r\n        textureCount = options.textureCount ?? 1;\r\n        depthTextureFormat = options.depthTextureFormat ?? Constants.TEXTUREFORMAT_DEPTH16;\r\n        types = options.types || types;\r\n        samplingModes = options.samplingModes || samplingModes;\r\n        useSRGBBuffers = options.useSRGBBuffers || useSRGBBuffers;\r\n        formats = options.formats || formats;\r\n        targets = options.targetTypes || targets;\r\n        faceIndex = options.faceIndex || faceIndex;\r\n        layerIndex = options.layerIndex || layerIndex;\r\n        layers = options.layerCounts || layers;\r\n        labels = options.labels || labels;\r\n        creationFlags = options.creationFlags || creationFlags;\r\n        samples = options.samples ?? samples;\r\n        dontCreateTextures = options.dontCreateTextures ?? false;\r\n    }\r\n\r\n    const width = (<{ width: number; height: number }>size).width ?? <number>size;\r\n    const height = (<{ width: number; height: number }>size).height ?? <number>size;\r\n\r\n    const textures: InternalTexture[] = [];\r\n    const attachments: number[] = [];\r\n    const defaultAttachments: number[] = [];\r\n\r\n    rtWrapper.label = options?.label ?? \"MultiRenderTargetWrapper\";\r\n    rtWrapper._generateDepthBuffer = generateDepthBuffer;\r\n    rtWrapper._generateStencilBuffer = generateStencilBuffer;\r\n    rtWrapper._attachments = attachments;\r\n    rtWrapper._defaultAttachments = defaultAttachments;\r\n\r\n    let depthStencilTexture: Nullable<InternalTexture> = null;\r\n    if ((generateDepthBuffer || generateStencilBuffer || generateDepthTexture) && !dontCreateTextures) {\r\n        if (!generateDepthTexture) {\r\n            // The caller doesn't want a depth texture, so we are free to use the depth texture format we want.\r\n            // So, we will align with what the WebGL engine does\r\n            if (generateDepthBuffer && generateStencilBuffer) {\r\n                depthTextureFormat = Constants.TEXTUREFORMAT_DEPTH24_STENCIL8;\r\n            } else if (generateDepthBuffer) {\r\n                depthTextureFormat = Constants.TEXTUREFORMAT_DEPTH32_FLOAT;\r\n            } else {\r\n                depthTextureFormat = Constants.TEXTUREFORMAT_STENCIL8;\r\n            }\r\n        }\r\n        depthStencilTexture = rtWrapper.createDepthStencilTexture(0, false, generateStencilBuffer, 1, depthTextureFormat, rtWrapper.label + \"-DepthStencil\");\r\n    }\r\n\r\n    const mipmapsCreationOnly = options !== undefined && typeof options === \"object\" && options.createMipMaps && !generateMipMaps;\r\n\r\n    for (let i = 0; i < textureCount; i++) {\r\n        let samplingMode = samplingModes[i] || defaultSamplingMode;\r\n        let type = types[i] || defaultType;\r\n\r\n        const format = formats[i] || defaultFormat;\r\n        const useSRGBBuffer = (useSRGBBuffers[i] || defaultUseSRGBBuffer) && this._caps.supportSRGBBuffers;\r\n\r\n        const target = targets[i] || defaultTarget;\r\n        const layerCount = layers[i] ?? 1;\r\n        const creationFlag = creationFlags[i];\r\n\r\n        if (type === Constants.TEXTURETYPE_FLOAT && !this._caps.textureFloatLinearFiltering) {\r\n            // if floating point linear (FLOAT) then force to NEAREST_SAMPLINGMODE\r\n            samplingMode = Constants.TEXTURE_NEAREST_SAMPLINGMODE;\r\n        } else if (type === Constants.TEXTURETYPE_HALF_FLOAT && !this._caps.textureHalfFloatLinearFiltering) {\r\n            // if floating point linear (HALF_FLOAT) then force to NEAREST_SAMPLINGMODE\r\n            samplingMode = Constants.TEXTURE_NEAREST_SAMPLINGMODE;\r\n        }\r\n\r\n        if (type === Constants.TEXTURETYPE_FLOAT && !this._caps.textureFloat) {\r\n            type = Constants.TEXTURETYPE_UNSIGNED_BYTE;\r\n            Logger.Warn(\"Float textures are not supported. Render target forced to TEXTURETYPE_UNSIGNED_BYTE type\");\r\n        }\r\n\r\n        attachments.push(i + 1);\r\n        defaultAttachments.push(initializeBuffers ? i + 1 : i === 0 ? 1 : 0);\r\n\r\n        if (target === -1 || dontCreateTextures) {\r\n            continue;\r\n        }\r\n\r\n        const texture = new InternalTexture(this, InternalTextureSource.MultiRenderTarget);\r\n        textures[i] = texture;\r\n\r\n        switch (target) {\r\n            case Constants.TEXTURE_CUBE_MAP:\r\n                texture.isCube = true;\r\n                break;\r\n            case Constants.TEXTURE_3D:\r\n                texture.is3D = true;\r\n                texture.baseDepth = texture.depth = layerCount;\r\n                break;\r\n            case Constants.TEXTURE_2D_ARRAY:\r\n                texture.is2DArray = true;\r\n                texture.baseDepth = texture.depth = layerCount;\r\n                break;\r\n        }\r\n\r\n        texture.baseWidth = width;\r\n        texture.baseHeight = height;\r\n        texture.width = width;\r\n        texture.height = height;\r\n        texture.isReady = true;\r\n        texture.samples = 1;\r\n        texture.generateMipMaps = generateMipMaps;\r\n        texture.samplingMode = samplingMode;\r\n        texture.type = type;\r\n        texture._cachedWrapU = Constants.TEXTURE_CLAMP_ADDRESSMODE;\r\n        texture._cachedWrapV = Constants.TEXTURE_CLAMP_ADDRESSMODE;\r\n        texture._useSRGBBuffer = useSRGBBuffer;\r\n        texture.format = format;\r\n        texture.label = labels[i] ?? rtWrapper.label + \"-Texture\" + i;\r\n\r\n        this._internalTexturesCache.push(texture);\r\n\r\n        if (mipmapsCreationOnly) {\r\n            // createGPUTextureForInternalTexture will only create a texture with mipmaps if generateMipMaps is true, as InternalTexture has no createMipMaps property, separate from generateMipMaps.\r\n            texture.generateMipMaps = true;\r\n        }\r\n\r\n        this._textureHelper.createGPUTextureForInternalTexture(texture, undefined, undefined, undefined, creationFlag, true);\r\n\r\n        if (mipmapsCreationOnly) {\r\n            texture.generateMipMaps = false;\r\n        }\r\n    }\r\n\r\n    if (depthStencilTexture) {\r\n        depthStencilTexture.incrementReferences();\r\n        textures[textureCount] = depthStencilTexture;\r\n        this._internalTexturesCache.push(depthStencilTexture);\r\n    }\r\n\r\n    rtWrapper.setTextures(textures);\r\n    rtWrapper.setLayerAndFaceIndices(layerIndex, faceIndex);\r\n\r\n    if (!dontCreateTextures) {\r\n        this.updateMultipleRenderTargetTextureSampleCount(rtWrapper, samples);\r\n    } else {\r\n        rtWrapper._samples = samples;\r\n    }\r\n\r\n    return rtWrapper;\r\n};\r\n\r\nWebGPUEngine.prototype.updateMultipleRenderTargetTextureSampleCount = function (rtWrapper: Nullable<RenderTargetWrapper>, samples: number): number {\r\n    if (!rtWrapper || !rtWrapper.textures || rtWrapper.textures.length === 0 || rtWrapper.textures[0].samples === samples) {\r\n        return samples;\r\n    }\r\n\r\n    const count = rtWrapper.textures.length;\r\n\r\n    if (count === 0) {\r\n        return 1;\r\n    }\r\n\r\n    samples = Math.min(samples, this.getCaps().maxMSAASamples);\r\n\r\n    for (let i = 0; i < count; ++i) {\r\n        const texture = rtWrapper.textures[i];\r\n        const gpuTextureWrapper = texture._hardwareTexture as Nullable<WebGPUHardwareTexture>;\r\n\r\n        gpuTextureWrapper?.releaseMSAATexture(rtWrapper.getBaseArrayLayer(i));\r\n    }\r\n\r\n    // Note that rtWrapper.textures can't have null textures, lastTextureIsDepthTexture can't be true if rtWrapper._depthStencilTexture is null\r\n    const lastTextureIsDepthTexture = rtWrapper._depthStencilTexture === rtWrapper.textures[count - 1];\r\n\r\n    for (let i = 0; i < count; ++i) {\r\n        const texture = rtWrapper.textures[i];\r\n        this._textureHelper.createMSAATexture(texture, samples, false, rtWrapper.getBaseArrayLayer(i));\r\n        texture.samples = samples;\r\n    }\r\n\r\n    // Note that the last texture of textures is the depth texture if the depth texture has been generated by the MRT class and so the MSAA texture\r\n    // will be recreated for this texture by the loop above: in that case, there's no need to create the MSAA texture for rtWrapper._depthStencilTexture\r\n    // because rtWrapper._depthStencilTexture is the same texture than the depth texture\r\n    if (rtWrapper._depthStencilTexture && !lastTextureIsDepthTexture) {\r\n        this._textureHelper.createMSAATexture(rtWrapper._depthStencilTexture, samples);\r\n        rtWrapper._depthStencilTexture.samples = samples;\r\n    }\r\n\r\n    rtWrapper._samples = samples;\r\n\r\n    return samples;\r\n};\r\n\r\nWebGPUEngine.prototype.generateMipMapsMultiFramebuffer = function (texture: RenderTargetWrapper): void {\r\n    const rtWrapper = texture as WebGPURenderTargetWrapper;\r\n\r\n    if (!rtWrapper.isMulti) {\r\n        return;\r\n    }\r\n\r\n    const attachments = rtWrapper._attachments!;\r\n    const count = attachments.length;\r\n\r\n    for (let i = 0; i < count; i++) {\r\n        const texture = rtWrapper.textures![i];\r\n        if (texture.generateMipMaps && !texture.isCube && !texture.is3D) {\r\n            this._generateMipmaps(texture);\r\n        }\r\n    }\r\n};\r\n\r\nWebGPUEngine.prototype.resolveMultiFramebuffer = function (_texture: RenderTargetWrapper): void {\r\n    throw new Error(\"resolveMultiFramebuffer is not yet implemented in WebGPU!\");\r\n};\r\n\r\nWebGPUEngine.prototype.bindAttachments = function (attachments: number[]): void {\r\n    if (attachments.length === 0 || !this._currentRenderTarget) {\r\n        return;\r\n    }\r\n\r\n    this._mrtAttachments = attachments;\r\n    if (this._currentRenderPass) {\r\n        // the render pass has already been created, we need to call setMRTAttachments to update the state of the attachments\r\n        this._cacheRenderPipeline.setMRTAttachments(attachments);\r\n    } else {\r\n        // the render pass is not created yet so we don't need to call setMRTAttachments: it will be called as part of the render pass creation (see WebGPUEngine._startRenderTargetRenderPass)\r\n    }\r\n};\r\n\r\nWebGPUEngine.prototype.buildTextureLayout = function (textureStatus: boolean[]): number[] {\r\n    const result = [];\r\n\r\n    for (let i = 0; i < textureStatus.length; i++) {\r\n        if (textureStatus[i]) {\r\n            result.push(i + 1);\r\n        } else {\r\n            result.push(0);\r\n        }\r\n    }\r\n\r\n    return result;\r\n};\r\n\r\nWebGPUEngine.prototype.restoreSingleAttachment = function (): void {\r\n    // not sure what to do, probably nothing... This function and restoreSingleAttachmentForRenderTarget are not called in Babylon.js so it's hard to know the use case\r\n};\r\n\r\nWebGPUEngine.prototype.restoreSingleAttachmentForRenderTarget = function (): void {\r\n    // not sure what to do, probably nothing... This function and restoreSingleAttachment are not called in Babylon.js so it's hard to know the use case\r\n};\r\n","import type { InternalTexture } from \"../../../Materials/Textures/internalTexture\";\r\nimport type { Nullable } from \"../../../types\";\r\nimport { WebGPUEngine } from \"../../webgpuEngine\";\r\nimport type { WebGPUHardwareTexture } from \"../webgpuHardwareTexture\";\r\nimport type { ExternalTexture } from \"../../../Materials/Textures/externalTexture\";\r\n\r\ndeclare module \"../../abstractEngine\" {\r\n    export interface AbstractEngine {\r\n        /**\r\n         * Update a video texture\r\n         * @param texture defines the texture to update\r\n         * @param video defines the video element to use\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         */\r\n        updateVideoTexture(texture: Nullable<InternalTexture>, video: HTMLVideoElement | Nullable<ExternalTexture>, invertY: boolean): void;\r\n    }\r\n}\r\n\r\nfunction IsExternalTexture(texture: Nullable<ExternalTexture> | HTMLVideoElement): texture is ExternalTexture {\r\n    return texture && (texture as ExternalTexture).underlyingResource !== undefined ? true : false;\r\n}\r\n\r\nWebGPUEngine.prototype.updateVideoTexture = function (texture: Nullable<InternalTexture>, video: HTMLVideoElement | Nullable<ExternalTexture>, invertY: boolean): void {\r\n    if (!texture || texture._isDisabled) {\r\n        return;\r\n    }\r\n\r\n    if (this._videoTextureSupported === undefined) {\r\n        this._videoTextureSupported = true;\r\n    }\r\n\r\n    let gpuTextureWrapper = texture._hardwareTexture as WebGPUHardwareTexture;\r\n\r\n    if (!texture._hardwareTexture?.underlyingResource) {\r\n        gpuTextureWrapper = this._textureHelper.createGPUTextureForInternalTexture(texture);\r\n    }\r\n\r\n    if (IsExternalTexture(video)) {\r\n        if (video.isReady()) {\r\n            try {\r\n                this._textureHelper.copyVideoToTexture(video, texture, gpuTextureWrapper.format, !invertY);\r\n                if (texture.generateMipMaps) {\r\n                    this._generateMipmaps(texture);\r\n                }\r\n            } catch (e) {\r\n                // WebGPU doesn't support video element who are not playing so far\r\n                // Ignore this error ensures we can start a video texture in a paused state\r\n            }\r\n            texture.isReady = true;\r\n        }\r\n    } else if (video) {\r\n        this.createImageBitmap(video)\r\n            .then((bitmap) => {\r\n                this._textureHelper.updateTexture(bitmap, texture, texture.width, texture.height, texture.depth, gpuTextureWrapper.format, 0, 0, !invertY, false, 0, 0);\r\n                if (texture.generateMipMaps) {\r\n                    this._generateMipmaps(texture);\r\n                }\r\n\r\n                texture.isReady = true;\r\n            })\r\n            .catch(() => {\r\n                // Sometimes createImageBitmap(video) fails with \"Failed to execute 'createImageBitmap' on 'Window': The provided element's player has no current data.\"\r\n                // Just keep going on\r\n                texture.isReady = true;\r\n            });\r\n    }\r\n};\r\n"],"names":["ComputeEffect","constructor","baseName","options","engine","key","computeSource","defines","onCompiled","onError","uniqueId","onCompileObservable","onErrorObservable","onBindObservable","_wasPreviouslyReady","_isReady","_compilationError","_key","_computeSourceCodeOverride","_pipelineContext","_computeSourceCode","_rawComputeSourceCode","_shaderLanguage","this","name","_engine","_UniqueIdSeed","_entryPoint","entryPoint","_shaderStore","GetShadersStore","_shaderRepository","GetShadersRepository","_includeShaderStore","GetIncludesShadersStore","hostDocument","getHostDocument","computeElement","getElementById","compute","processorOptions","split","indexParameters","undefined","isFragment","shouldUseHighPrecisionShader","processor","supportsUniformBuffers","shadersRepository","includesShadersStore","version","toString","platformName","shaderPlatformName","processingContext","isNDCHalfZRange","useReverseDepthBuffer","processCodeAfterIncludes","shaderType","code","define","replace","trim","length","value","isNaN","parseInt","parseFloat","_loadShader","computeCode","migratedComputeCode","processFinalCode","finalShaders","_useFinalCode","vertexCode","migratedCommputeCode","spectorName","_prepareEffect","isReady","_isReadyInternal","getEngine","getPipelineContext","getCompilationError","executeWhenCompiled","func","add","effect","isAsync","_checkIsReady","previousPipelineContext","e","_processCompilationErrors","shader","optionalKey","callback","HTMLElement","substring","window","atob","shaderUrl","indexOf","_loadFile","toLowerCase","computeSourceCode","_getComputeShaderCode","rawComputeSourceCode","createComputePipelineContext","_name","_prepareComputePipelineContext","_executeWhenComputeStateIsCompiled","messages","numErrors","notifyObservers","clear","_deleteComputePipelineContext","Error","LogShaderCodeOnCompilationError","message","msg","line","offset","type","text","dispose","_releaseComputeEffect","RegisterShader","computeShader","WebGPUComputeContext","getBindGroups","bindings","computePipeline","bindingsMapping","_bindGroups","bindGroupEntriesExist","_bindGroupEntries","binding","location","group","index","object","indexInGroupEntries","entries","sampler","resource","_cacheSampler","getSampler","push","texture","hardwareTexture","_texture","_hardwareTexture","view","textureAdditionalUsages","viewForWriting","externalTexture","underlyingResource","_device","importExternalTexture","source","dataBuffer","getBuffer","webgpuBuffer","buffer","size","capacity","i","createBindGroup","layout","getBindGroupLayout","device","cacheSampler","_Counter","WebGPUComputePipelineContext","sources","computePassDescriptor","prototype","createComputeContext","createComputeEffect","computeToken","_compiledComputeEffects","compiledEffect","areAllComputeEffectsReady","computeDispatch","context","x","y","z","gpuPerfCounter","_computeDispatch","computeDispatchIndirect","_endCurrentRenderPass","contextPipeline","computeContext","createComputePipeline","stage","_timestampQuery","startPass","_timestampIndex","computePass","_renderEncoder","beginComputePass","setPipeline","bindGroups","bindGroup","setBindGroup","dispatchWorkgroupsIndirect","dispatchWorkgroups","end","endPass","releaseComputeEffects","webGPUPipelineContextCompute","pipelineContext","webGpuContext","dbgShowShaderCode","Log","rawCompute","_createComputePipelineStageDescriptor","_rebuildComputeEffects","action","module","getCompilationInfo","then","info","compilationMessages","lineNum","column","linePos","join","createShaderModule","_debugPushGroup","groupName","targetObject","_options","enableGPUDebugMarkers","_currentRenderTarget","unBindFramebuffer","pushDebugGroup","_currentRenderPass","_debugStackRenderPass","_pendingDebugCommands","_debugPopGroup","popDebugGroup","pop","_debugInsertMarker","insertDebugMarker","_debugFlushPendingCommands","currentDebugStack","slice","param","createDynamicTexture","width","height","generateMipMaps","samplingMode","baseWidth","baseHeight","needPOTTextures","_caps","maxTextureSize","updateTextureSamplingMode","_internalTexturesCache","_textureHelper","createGPUTextureForInternalTexture","updateDynamicTexture","invertY","premulAlpha","format","forceBindTexture","allowGPUOptimization","gpuTextureWrapper","updateTexture","depth","_generateMipmaps","_dynamicTextureSource","_premulAlpha","unBindMultiColorAttachmentFramebuffer","rtWrapper","disableGenerateMipMaps","onBeforeUnbind","generateMipMapsMultiFramebuffer","_mrtAttachments","_cacheRenderPipeline","setMRT","setMRTAttachments","createMultipleRenderTarget","initializeBuffers","generateDepthBuffer","generateStencilBuffer","generateDepthTexture","depthTextureFormat","textureCount","samples","types","samplingModes","useSRGBBuffers","formats","targets","faceIndex","layerIndex","layers","labels","creationFlags","dontCreateTextures","_createHardwareRenderTargetWrapper","targetTypes","layerCounts","textures","attachments","defaultAttachments","label","_generateDepthBuffer","_generateStencilBuffer","_attachments","_defaultAttachments","depthStencilTexture","createDepthStencilTexture","mipmapsCreationOnly","createMipMaps","useSRGBBuffer","supportSRGBBuffers","target","layerCount","creationFlag","Warn","isCube","is3D","baseDepth","is2DArray","_cachedWrapU","_cachedWrapV","_useSRGBBuffer","incrementReferences","setTextures","setLayerAndFaceIndices","_samples","updateMultipleRenderTargetTextureSampleCount","count","Math","min","getCaps","maxMSAASamples","releaseMSAATexture","getBaseArrayLayer","lastTextureIsDepthTexture","_depthStencilTexture","createMSAATexture","isMulti","resolveMultiFramebuffer","bindAttachments","buildTextureLayout","textureStatus","result","restoreSingleAttachment","restoreSingleAttachmentForRenderTarget","updateVideoTexture","video","_isDisabled","_videoTextureSupported","IsExternalTexture","copyVideoToTexture","createImageBitmap","bitmap","catch"],"sourceRoot":""}