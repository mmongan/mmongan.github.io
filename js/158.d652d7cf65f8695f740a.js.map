{"version":3,"file":"js/158.d652d7cf65f8695f740a.js","mappings":"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","sources":["webpack://babylonjs-typescript-webpack-template/./dev/core/src/Materials/Textures/Loaders/ddsTextureLoader.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Engines/AbstractEngine/abstractEngine.cubeTexture.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Misc/urlTools.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Misc/dds.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Misc/HighDynamicRange/cubemapToSphericalPolynomial.ts"],"sourcesContent":["import type { Nullable } from \"../../../types\";\r\nimport { SphericalPolynomial } from \"../../../Maths/sphericalPolynomial\";\r\nimport type { InternalTexture } from \"../../../Materials/Textures/internalTexture\";\r\nimport type { IInternalTextureLoader } from \"./internalTextureLoader\";\r\nimport type { DDSInfo } from \"../../../Misc/dds\";\r\nimport { DDSTools } from \"../../../Misc/dds\";\r\n\r\nimport type { Engine } from \"core/Engines/engine\";\r\n\r\n/**\r\n * Implementation of the DDS Texture Loader.\r\n * @internal\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class _DDSTextureLoader implements IInternalTextureLoader {\r\n    /**\r\n     * Defines whether the loader supports cascade loading the different faces.\r\n     */\r\n    public readonly supportCascades = true;\r\n\r\n    /**\r\n     * Uploads the cube texture data to the WebGL texture. It has already been bound.\r\n     * @param imgs contains the cube maps\r\n     * @param texture defines the BabylonJS internal texture\r\n     * @param createPolynomials will be true if polynomials have been requested\r\n     * @param onLoad defines the callback to trigger once the texture is ready\r\n     */\r\n    public loadCubeData(imgs: ArrayBufferView | ArrayBufferView[], texture: InternalTexture, createPolynomials: boolean, onLoad: Nullable<(data?: any) => void>): void {\r\n        const engine = texture.getEngine() as Engine;\r\n        let info: DDSInfo | undefined;\r\n        let loadMipmap: boolean = false;\r\n        let maxLevel: number = 1000;\r\n        if (Array.isArray(imgs)) {\r\n            for (let index = 0; index < imgs.length; index++) {\r\n                const data = imgs[index];\r\n                info = DDSTools.GetDDSInfo(data);\r\n\r\n                texture.width = info.width;\r\n                texture.height = info.height;\r\n\r\n                loadMipmap = (info.isRGB || info.isLuminance || info.mipmapCount > 1) && texture.generateMipMaps;\r\n\r\n                engine._unpackFlipY(info.isCompressed);\r\n\r\n                DDSTools.UploadDDSLevels(engine, texture, data, info, loadMipmap, 6, -1, index);\r\n\r\n                if (!info.isFourCC && info.mipmapCount === 1) {\r\n                    engine.generateMipMapsForCubemap(texture);\r\n                } else {\r\n                    maxLevel = info.mipmapCount - 1;\r\n                }\r\n            }\r\n        } else {\r\n            const data = imgs;\r\n            info = DDSTools.GetDDSInfo(data);\r\n\r\n            texture.width = info.width;\r\n            texture.height = info.height;\r\n\r\n            if (createPolynomials) {\r\n                info.sphericalPolynomial = new SphericalPolynomial();\r\n            }\r\n\r\n            loadMipmap = (info.isRGB || info.isLuminance || info.mipmapCount > 1) && texture.generateMipMaps;\r\n            engine._unpackFlipY(info.isCompressed);\r\n\r\n            DDSTools.UploadDDSLevels(engine, texture, data, info, loadMipmap, 6);\r\n\r\n            if (!info.isFourCC && info.mipmapCount === 1) {\r\n                // Do not unbind as we still need to set the parameters.\r\n                engine.generateMipMapsForCubemap(texture, false);\r\n            } else {\r\n                maxLevel = info.mipmapCount - 1;\r\n            }\r\n        }\r\n        engine._setCubeMapTextureParams(texture, loadMipmap, maxLevel);\r\n        texture.isReady = true;\r\n        texture.onLoadedObservable.notifyObservers(texture);\r\n        texture.onLoadedObservable.clear();\r\n\r\n        if (onLoad) {\r\n            onLoad({ isDDS: true, width: texture.width, info, data: imgs, texture });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Uploads the 2D texture data to the WebGL texture. It has already been bound once in the callback.\r\n     * @param data contains the texture data\r\n     * @param texture defines the BabylonJS internal texture\r\n     * @param callback defines the method to call once ready to upload\r\n     */\r\n    public loadData(\r\n        data: ArrayBufferView,\r\n        texture: InternalTexture,\r\n        callback: (width: number, height: number, loadMipmap: boolean, isCompressed: boolean, done: () => void) => void\r\n    ): void {\r\n        const info = DDSTools.GetDDSInfo(data);\r\n\r\n        const loadMipmap = (info.isRGB || info.isLuminance || info.mipmapCount > 1) && texture.generateMipMaps && Math.max(info.width, info.height) >> (info.mipmapCount - 1) === 1;\r\n        callback(info.width, info.height, loadMipmap, info.isFourCC, () => {\r\n            DDSTools.UploadDDSLevels(texture.getEngine(), texture, data, info, loadMipmap, 1);\r\n        });\r\n    }\r\n}\r\n","import { InternalTexture, InternalTextureSource } from \"../../Materials/Textures/internalTexture\";\r\nimport { Logger } from \"../../Misc/logger\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { LoadImage } from \"../../Misc/fileTools\";\r\nimport { RandomGUID } from \"../../Misc/guid\";\r\nimport type { IWebRequest } from \"../../Misc/interfaces/iWebRequest\";\r\nimport { AbstractEngine } from \"../abstractEngine\";\r\nimport { _GetCompatibleTextureLoader } from \"core/Materials/Textures/Loaders/textureLoaderManager\";\r\nimport { GetExtensionFromUrl } from \"core/Misc/urlTools\";\r\n\r\ndeclare module \"../../Engines/abstractEngine\" {\r\n    export interface AbstractEngine {\r\n        /** @internal */\r\n        createCubeTextureBase(\r\n            rootUrl: string,\r\n            scene: Nullable<Scene>,\r\n            files: Nullable<string[]>,\r\n            noMipmap: boolean,\r\n            onLoad: Nullable<(data?: any) => void>,\r\n            onError: Nullable<(message?: string, exception?: any) => void>,\r\n            format: number | undefined,\r\n            forcedExtension: any,\r\n            createPolynomials: boolean,\r\n            lodScale: number,\r\n            lodOffset: number,\r\n            fallback: Nullable<InternalTexture>,\r\n            beforeLoadCubeDataCallback: Nullable<(texture: InternalTexture, data: ArrayBufferView | ArrayBufferView[]) => void>,\r\n            imageHandler: Nullable<(texture: InternalTexture, imgs: HTMLImageElement[] | ImageBitmap[]) => void>,\r\n            useSRGBBuffer: boolean,\r\n            buffer: Nullable<ArrayBufferView>\r\n        ): InternalTexture;\r\n\r\n        /** @internal */\r\n        _partialLoadFile(\r\n            url: string,\r\n            index: number,\r\n            loadedFiles: ArrayBuffer[],\r\n            onfinish: (files: ArrayBuffer[]) => void,\r\n            onErrorCallBack: Nullable<(message?: string, exception?: any) => void>\r\n        ): void;\r\n\r\n        /** @internal */\r\n        _cascadeLoadFiles(scene: Nullable<Scene>, onfinish: (images: ArrayBuffer[]) => void, files: string[], onError: Nullable<(message?: string, exception?: any) => void>): void;\r\n\r\n        /** @internal */\r\n        _cascadeLoadImgs(\r\n            scene: Nullable<Scene>,\r\n            texture: InternalTexture,\r\n            onfinish: Nullable<(texture: InternalTexture, images: HTMLImageElement[] | ImageBitmap[]) => void>,\r\n            files: string[],\r\n            onError: Nullable<(message?: string, exception?: any) => void>,\r\n            mimeType?: string\r\n        ): void;\r\n\r\n        /** @internal */\r\n        _partialLoadImg(\r\n            url: string,\r\n            index: number,\r\n            loadedImages: HTMLImageElement[] | ImageBitmap[],\r\n            scene: Nullable<Scene>,\r\n            texture: InternalTexture,\r\n            onfinish: Nullable<(texture: InternalTexture, images: HTMLImageElement[] | ImageBitmap[]) => void>,\r\n            onErrorCallBack: Nullable<(message?: string, exception?: any) => void>,\r\n            mimeType?: string\r\n        ): void;\r\n    }\r\n}\r\n\r\nAbstractEngine.prototype._partialLoadFile = function (\r\n    url: string,\r\n    index: number,\r\n    loadedFiles: ArrayBuffer[],\r\n    onfinish: (files: ArrayBuffer[]) => void,\r\n    onErrorCallBack: Nullable<(message?: string, exception?: any) => void> = null\r\n): void {\r\n    const onload = (data: ArrayBuffer) => {\r\n        loadedFiles[index] = data;\r\n        (<any>loadedFiles)._internalCount++;\r\n\r\n        if ((<any>loadedFiles)._internalCount === 6) {\r\n            onfinish(loadedFiles);\r\n        }\r\n    };\r\n\r\n    const onerror = (request?: IWebRequest, exception?: any) => {\r\n        if (onErrorCallBack && request) {\r\n            onErrorCallBack(request.status + \" \" + request.statusText, exception);\r\n        }\r\n    };\r\n\r\n    this._loadFile(url, onload as (data: string | ArrayBuffer) => void, undefined, undefined, true, onerror);\r\n};\r\n\r\nAbstractEngine.prototype._cascadeLoadFiles = function (\r\n    scene: Nullable<Scene>,\r\n    onfinish: (images: ArrayBuffer[]) => void,\r\n    files: string[],\r\n    onError: Nullable<(message?: string, exception?: any) => void> = null\r\n): void {\r\n    const loadedFiles: ArrayBuffer[] = [];\r\n    (<any>loadedFiles)._internalCount = 0;\r\n\r\n    for (let index = 0; index < 6; index++) {\r\n        this._partialLoadFile(files[index], index, loadedFiles, onfinish, onError);\r\n    }\r\n};\r\n\r\nAbstractEngine.prototype._cascadeLoadImgs = function (\r\n    scene: Nullable<Scene>,\r\n    texture: InternalTexture,\r\n    onfinish: Nullable<(texture: InternalTexture, images: HTMLImageElement[] | ImageBitmap[]) => void>,\r\n    files: string[],\r\n    onError: Nullable<(message?: string, exception?: any) => void> = null,\r\n    mimeType?: string\r\n) {\r\n    const loadedImages: HTMLImageElement[] | ImageBitmap[] = [];\r\n    (<any>loadedImages)._internalCount = 0;\r\n\r\n    for (let index = 0; index < 6; index++) {\r\n        this._partialLoadImg(files[index], index, loadedImages, scene, texture, onfinish, onError, mimeType);\r\n    }\r\n};\r\n\r\nAbstractEngine.prototype._partialLoadImg = function (\r\n    url: string,\r\n    index: number,\r\n    loadedImages: HTMLImageElement[] | ImageBitmap[],\r\n    scene: Nullable<Scene>,\r\n    texture: InternalTexture,\r\n    onfinish: Nullable<(texture: InternalTexture, images: HTMLImageElement[] | ImageBitmap[]) => void>,\r\n    onErrorCallBack: Nullable<(message?: string, exception?: any) => void> = null,\r\n    mimeType?: string\r\n) {\r\n    const tokenPendingData = RandomGUID();\r\n\r\n    const onload = (img: HTMLImageElement | ImageBitmap) => {\r\n        loadedImages[index] = img;\r\n        (<any>loadedImages)._internalCount++;\r\n\r\n        if (scene) {\r\n            scene.removePendingData(tokenPendingData);\r\n        }\r\n\r\n        if ((<any>loadedImages)._internalCount === 6 && onfinish) {\r\n            onfinish(texture, loadedImages);\r\n        }\r\n    };\r\n\r\n    const onerror = (message?: string, exception?: any) => {\r\n        if (scene) {\r\n            scene.removePendingData(tokenPendingData);\r\n        }\r\n\r\n        if (onErrorCallBack) {\r\n            onErrorCallBack(message, exception);\r\n        }\r\n    };\r\n\r\n    LoadImage(url, onload, onerror, scene ? scene.offlineProvider : null, mimeType);\r\n    if (scene) {\r\n        scene.addPendingData(tokenPendingData);\r\n    }\r\n};\r\n\r\nAbstractEngine.prototype.createCubeTextureBase = function (\r\n    rootUrl: string,\r\n    scene: Nullable<Scene>,\r\n    files: Nullable<string[]>,\r\n    noMipmap?: boolean,\r\n    onLoad: Nullable<(data?: any) => void> = null,\r\n    onError: Nullable<(message?: string, exception?: any) => void> = null,\r\n    format?: number,\r\n    forcedExtension: any = null,\r\n    createPolynomials: boolean = false,\r\n    lodScale: number = 0,\r\n    lodOffset: number = 0,\r\n    fallback: Nullable<InternalTexture> = null,\r\n    beforeLoadCubeDataCallback: Nullable<(texture: InternalTexture, data: ArrayBufferView | ArrayBufferView[]) => void> = null,\r\n    imageHandler: Nullable<(texture: InternalTexture, imgs: HTMLImageElement[] | ImageBitmap[]) => void> = null,\r\n    useSRGBBuffer = false,\r\n    buffer: Nullable<ArrayBufferView> = null\r\n): InternalTexture {\r\n    const texture = fallback ? fallback : new InternalTexture(this, InternalTextureSource.Cube);\r\n    texture.isCube = true;\r\n    texture.url = rootUrl;\r\n    texture.generateMipMaps = !noMipmap;\r\n    texture._lodGenerationScale = lodScale;\r\n    texture._lodGenerationOffset = lodOffset;\r\n    texture._useSRGBBuffer = !!useSRGBBuffer && this._caps.supportSRGBBuffers && (this.version > 1 || this.isWebGPU || !!noMipmap);\r\n    if (texture !== fallback) {\r\n        texture.label = rootUrl.substring(0, 60); // default label, can be overriden by the caller\r\n    }\r\n\r\n    if (!this._doNotHandleContextLost) {\r\n        texture._extension = forcedExtension;\r\n        texture._files = files;\r\n        texture._buffer = buffer;\r\n    }\r\n\r\n    const originalRootUrl = rootUrl;\r\n    if (this._transformTextureUrl && !fallback) {\r\n        rootUrl = this._transformTextureUrl(rootUrl);\r\n    }\r\n\r\n    const extension = forcedExtension ?? GetExtensionFromUrl(rootUrl);\r\n\r\n    const loaderPromise = _GetCompatibleTextureLoader(extension);\r\n\r\n    const onInternalError = (request?: IWebRequest, exception?: any) => {\r\n        if (rootUrl === originalRootUrl) {\r\n            if (onError && request) {\r\n                onError(request.status + \" \" + request.statusText, exception);\r\n            }\r\n        } else {\r\n            // fall back to the original url if the transformed url fails to load\r\n            Logger.Warn(`Failed to load ${rootUrl}, falling back to the ${originalRootUrl}`);\r\n            this.createCubeTextureBase(\r\n                originalRootUrl,\r\n                scene,\r\n                files,\r\n                !!noMipmap,\r\n                onLoad,\r\n                onError,\r\n                format,\r\n                forcedExtension,\r\n                createPolynomials,\r\n                lodScale,\r\n                lodOffset,\r\n                texture,\r\n                beforeLoadCubeDataCallback,\r\n                imageHandler,\r\n                useSRGBBuffer,\r\n                buffer\r\n            );\r\n        }\r\n    };\r\n\r\n    if (loaderPromise) {\r\n        loaderPromise.then((loader) => {\r\n            const onloaddata = (data: ArrayBufferView | ArrayBufferView[]) => {\r\n                if (beforeLoadCubeDataCallback) {\r\n                    beforeLoadCubeDataCallback(texture, data);\r\n                }\r\n                loader.loadCubeData(data, texture, createPolynomials, onLoad, onError);\r\n            };\r\n            if (buffer) {\r\n                onloaddata(buffer);\r\n            } else if (files && files.length === 6) {\r\n                if (loader.supportCascades) {\r\n                    this._cascadeLoadFiles(scene, (images) => onloaddata(images.map((image) => new Uint8Array(image))), files, onError);\r\n                } else {\r\n                    if (onError) {\r\n                        onError(\"Textures type does not support cascades.\");\r\n                    } else {\r\n                        Logger.Warn(\"Texture loader does not support cascades.\");\r\n                    }\r\n                }\r\n            } else {\r\n                this._loadFile(rootUrl, (data) => onloaddata(new Uint8Array(data as ArrayBuffer)), undefined, undefined, true, onInternalError);\r\n            }\r\n        });\r\n    } else {\r\n        if (!files || files.length === 0) {\r\n            throw new Error(\"Cannot load cubemap because files were not defined, or the correct loader was not found.\");\r\n        }\r\n\r\n        this._cascadeLoadImgs(\r\n            scene,\r\n            texture,\r\n            (texture: InternalTexture, imgs: HTMLImageElement[] | ImageBitmap[]) => {\r\n                if (imageHandler) {\r\n                    imageHandler(texture, imgs);\r\n                }\r\n            },\r\n            files,\r\n            onError\r\n        );\r\n    }\r\n\r\n    this._internalTexturesCache.push(texture);\r\n\r\n    return texture;\r\n};\r\n","/**\r\n * Gets the file extension from a URL.\r\n * @param url The URL to get the file extension from.\r\n * @returns The file extension, or an empty string if no extension is found.\r\n */\r\nexport function GetExtensionFromUrl(url: string) {\r\n    const urlWithoutUriParams = url.split(\"?\")[0];\r\n    const lastDot = urlWithoutUriParams.lastIndexOf(\".\");\r\n    const extension = lastDot > -1 ? urlWithoutUriParams.substring(lastDot).toLowerCase() : \"\";\r\n    return extension;\r\n}\r\n","/* eslint-disable @typescript-eslint/naming-convention */\r\nimport { Clamp } from \"../Maths/math.scalar.functions\";\r\nimport type { SphericalPolynomial } from \"../Maths/sphericalPolynomial\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport type { InternalTexture } from \"../Materials/Textures/internalTexture\";\r\nimport type { Nullable } from \"../types\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport { CubeMapToSphericalPolynomialTools } from \"../Misc/HighDynamicRange/cubemapToSphericalPolynomial\";\r\nimport type { AbstractEngine } from \"../Engines/abstractEngine\";\r\nimport { FromHalfFloat, ToHalfFloat } from \"./textureTools\";\r\n\r\nimport \"../Engines/AbstractEngine/abstractEngine.cubeTexture\";\r\n\r\n// Based on demo done by Brandon Jones - http://media.tojicode.com/webgl-samples/dds.html\r\n// All values and structures referenced from:\r\n// http://msdn.microsoft.com/en-us/library/bb943991.aspx/\r\nconst DDS_MAGIC = 0x20534444;\r\n\r\nconst //DDSD_CAPS = 0x1,\r\n    //DDSD_HEIGHT = 0x2,\r\n    //DDSD_WIDTH = 0x4,\r\n    //DDSD_PITCH = 0x8,\r\n    //DDSD_PIXELFORMAT = 0x1000,\r\n    DDSD_MIPMAPCOUNT = 0x20000;\r\n//DDSD_LINEARSIZE = 0x80000,\r\n//DDSD_DEPTH = 0x800000;\r\n\r\n// var DDSCAPS_COMPLEX = 0x8,\r\n//     DDSCAPS_MIPMAP = 0x400000,\r\n//     DDSCAPS_TEXTURE = 0x1000;\r\n\r\nconst DDSCAPS2_CUBEMAP = 0x200;\r\n// DDSCAPS2_CUBEMAP_POSITIVEX = 0x400,\r\n// DDSCAPS2_CUBEMAP_NEGATIVEX = 0x800,\r\n// DDSCAPS2_CUBEMAP_POSITIVEY = 0x1000,\r\n// DDSCAPS2_CUBEMAP_NEGATIVEY = 0x2000,\r\n// DDSCAPS2_CUBEMAP_POSITIVEZ = 0x4000,\r\n// DDSCAPS2_CUBEMAP_NEGATIVEZ = 0x8000,\r\n// DDSCAPS2_VOLUME = 0x200000;\r\n\r\nconst //DDPF_ALPHAPIXELS = 0x1,\r\n    //DDPF_ALPHA = 0x2,\r\n    DDPF_FOURCC = 0x4,\r\n    DDPF_RGB = 0x40,\r\n    //DDPF_YUV = 0x200,\r\n    DDPF_LUMINANCE = 0x20000;\r\n\r\nfunction FourCCToInt32(value: string) {\r\n    return value.charCodeAt(0) + (value.charCodeAt(1) << 8) + (value.charCodeAt(2) << 16) + (value.charCodeAt(3) << 24);\r\n}\r\n\r\nfunction Int32ToFourCC(value: number) {\r\n    return String.fromCharCode(value & 0xff, (value >> 8) & 0xff, (value >> 16) & 0xff, (value >> 24) & 0xff);\r\n}\r\n\r\nconst FOURCC_DXT1 = FourCCToInt32(\"DXT1\");\r\nconst FOURCC_DXT3 = FourCCToInt32(\"DXT3\");\r\nconst FOURCC_DXT5 = FourCCToInt32(\"DXT5\");\r\nconst FOURCC_DX10 = FourCCToInt32(\"DX10\");\r\nconst FOURCC_D3DFMT_R16G16B16A16F = 113;\r\nconst FOURCC_D3DFMT_R32G32B32A32F = 116;\r\n\r\nconst DXGI_FORMAT_R32G32B32A32_FLOAT = 2;\r\nconst DXGI_FORMAT_R16G16B16A16_FLOAT = 10;\r\nconst DXGI_FORMAT_B8G8R8X8_UNORM = 88;\r\n\r\nconst headerLengthInt = 31; // The header length in 32 bit ints\r\n\r\n// Offsets into the header array\r\nconst off_magic = 0;\r\n\r\nconst off_size = 1;\r\nconst off_flags = 2;\r\nconst off_height = 3;\r\nconst off_width = 4;\r\n\r\nconst off_mipmapCount = 7;\r\n\r\nconst off_pfFlags = 20;\r\nconst off_pfFourCC = 21;\r\nconst off_RGBbpp = 22;\r\nconst off_RMask = 23;\r\nconst off_GMask = 24;\r\nconst off_BMask = 25;\r\nconst off_AMask = 26;\r\n// var off_caps1 = 27;\r\nconst off_caps2 = 28;\r\n// var off_caps3 = 29;\r\n// var off_caps4 = 30;\r\nconst off_dxgiFormat = 32;\r\n\r\n/**\r\n * Direct draw surface info\r\n * @see https://docs.microsoft.com/en-us/windows/desktop/direct3ddds/dx-graphics-dds-pguide\r\n */\r\nexport interface DDSInfo {\r\n    /**\r\n     * Width of the texture\r\n     */\r\n    width: number;\r\n    /**\r\n     * Width of the texture\r\n     */\r\n    height: number;\r\n    /**\r\n     * Number of Mipmaps for the texture\r\n     * @see https://en.wikipedia.org/wiki/Mipmap\r\n     */\r\n    mipmapCount: number;\r\n    /**\r\n     * If the textures format is a known fourCC format\r\n     * @see https://www.fourcc.org/\r\n     */\r\n    isFourCC: boolean;\r\n    /**\r\n     * If the texture is an RGB format eg. DXGI_FORMAT_B8G8R8X8_UNORM format\r\n     */\r\n    isRGB: boolean;\r\n    /**\r\n     * If the texture is a lumincance format\r\n     */\r\n    isLuminance: boolean;\r\n    /**\r\n     * If this is a cube texture\r\n     * @see https://docs.microsoft.com/en-us/windows/desktop/direct3ddds/dds-file-layout-for-cubic-environment-maps\r\n     */\r\n    isCube: boolean;\r\n    /**\r\n     * If the texture is a compressed format eg. FOURCC_DXT1\r\n     */\r\n    isCompressed: boolean;\r\n    /**\r\n     * The dxgiFormat of the texture\r\n     * @see https://docs.microsoft.com/en-us/windows/desktop/api/dxgiformat/ne-dxgiformat-dxgi_format\r\n     */\r\n    dxgiFormat: number;\r\n    /**\r\n     * Texture type eg. Engine.TEXTURETYPE_UNSIGNED_BYTE, Engine.TEXTURETYPE_FLOAT\r\n     */\r\n    textureType: number;\r\n    /**\r\n     * Sphericle polynomial created for the dds texture\r\n     */\r\n    sphericalPolynomial?: SphericalPolynomial;\r\n}\r\n\r\n/**\r\n * Class used to provide DDS decompression tools\r\n */\r\nexport class DDSTools {\r\n    /**\r\n     * Gets or sets a boolean indicating that LOD info is stored in alpha channel (false by default)\r\n     */\r\n    public static StoreLODInAlphaChannel = false;\r\n\r\n    /**\r\n     * Gets DDS information from an array buffer\r\n     * @param data defines the array buffer view to read data from\r\n     * @returns the DDS information\r\n     */\r\n    public static GetDDSInfo(data: ArrayBufferView): DDSInfo {\r\n        const header = new Int32Array(data.buffer, data.byteOffset, headerLengthInt);\r\n        const extendedHeader = new Int32Array(data.buffer, data.byteOffset, headerLengthInt + 4);\r\n\r\n        let mipmapCount = 1;\r\n        if (header[off_flags] & DDSD_MIPMAPCOUNT) {\r\n            mipmapCount = Math.max(1, header[off_mipmapCount]);\r\n        }\r\n\r\n        const fourCC = header[off_pfFourCC];\r\n        const dxgiFormat = fourCC === FOURCC_DX10 ? extendedHeader[off_dxgiFormat] : 0;\r\n        let textureType = Constants.TEXTURETYPE_UNSIGNED_BYTE;\r\n\r\n        switch (fourCC) {\r\n            case FOURCC_D3DFMT_R16G16B16A16F:\r\n                textureType = Constants.TEXTURETYPE_HALF_FLOAT;\r\n                break;\r\n            case FOURCC_D3DFMT_R32G32B32A32F:\r\n                textureType = Constants.TEXTURETYPE_FLOAT;\r\n                break;\r\n            case FOURCC_DX10:\r\n                if (dxgiFormat === DXGI_FORMAT_R16G16B16A16_FLOAT) {\r\n                    textureType = Constants.TEXTURETYPE_HALF_FLOAT;\r\n                    break;\r\n                }\r\n                if (dxgiFormat === DXGI_FORMAT_R32G32B32A32_FLOAT) {\r\n                    textureType = Constants.TEXTURETYPE_FLOAT;\r\n                    break;\r\n                }\r\n        }\r\n\r\n        return {\r\n            width: header[off_width],\r\n            height: header[off_height],\r\n            mipmapCount: mipmapCount,\r\n            isFourCC: (header[off_pfFlags] & DDPF_FOURCC) === DDPF_FOURCC,\r\n            isRGB: (header[off_pfFlags] & DDPF_RGB) === DDPF_RGB,\r\n            isLuminance: (header[off_pfFlags] & DDPF_LUMINANCE) === DDPF_LUMINANCE,\r\n            isCube: (header[off_caps2] & DDSCAPS2_CUBEMAP) === DDSCAPS2_CUBEMAP,\r\n            isCompressed: fourCC === FOURCC_DXT1 || fourCC === FOURCC_DXT3 || fourCC === FOURCC_DXT5,\r\n            dxgiFormat: dxgiFormat,\r\n            textureType: textureType,\r\n        };\r\n    }\r\n\r\n    private static _GetHalfFloatAsFloatRGBAArrayBuffer(width: number, height: number, dataOffset: number, dataLength: number, arrayBuffer: ArrayBuffer, lod: number): Float32Array {\r\n        const destArray = new Float32Array(dataLength);\r\n        const srcData = new Uint16Array(arrayBuffer, dataOffset);\r\n        let index = 0;\r\n        for (let y = 0; y < height; y++) {\r\n            for (let x = 0; x < width; x++) {\r\n                const srcPos = (x + y * width) * 4;\r\n                destArray[index] = FromHalfFloat(srcData[srcPos]);\r\n                destArray[index + 1] = FromHalfFloat(srcData[srcPos + 1]);\r\n                destArray[index + 2] = FromHalfFloat(srcData[srcPos + 2]);\r\n                if (DDSTools.StoreLODInAlphaChannel) {\r\n                    destArray[index + 3] = lod;\r\n                } else {\r\n                    destArray[index + 3] = FromHalfFloat(srcData[srcPos + 3]);\r\n                }\r\n                index += 4;\r\n            }\r\n        }\r\n\r\n        return destArray;\r\n    }\r\n\r\n    private static _GetHalfFloatRGBAArrayBuffer(width: number, height: number, dataOffset: number, dataLength: number, arrayBuffer: ArrayBuffer, lod: number): Uint16Array {\r\n        if (DDSTools.StoreLODInAlphaChannel) {\r\n            const destArray = new Uint16Array(dataLength);\r\n            const srcData = new Uint16Array(arrayBuffer, dataOffset);\r\n            let index = 0;\r\n            for (let y = 0; y < height; y++) {\r\n                for (let x = 0; x < width; x++) {\r\n                    const srcPos = (x + y * width) * 4;\r\n                    destArray[index] = srcData[srcPos];\r\n                    destArray[index + 1] = srcData[srcPos + 1];\r\n                    destArray[index + 2] = srcData[srcPos + 2];\r\n                    destArray[index + 3] = ToHalfFloat(lod);\r\n                    index += 4;\r\n                }\r\n            }\r\n\r\n            return destArray;\r\n        }\r\n\r\n        return new Uint16Array(arrayBuffer, dataOffset, dataLength);\r\n    }\r\n\r\n    private static _GetFloatRGBAArrayBuffer(width: number, height: number, dataOffset: number, dataLength: number, arrayBuffer: ArrayBuffer, lod: number): Float32Array {\r\n        if (DDSTools.StoreLODInAlphaChannel) {\r\n            const destArray = new Float32Array(dataLength);\r\n            const srcData = new Float32Array(arrayBuffer, dataOffset);\r\n            let index = 0;\r\n            for (let y = 0; y < height; y++) {\r\n                for (let x = 0; x < width; x++) {\r\n                    const srcPos = (x + y * width) * 4;\r\n                    destArray[index] = srcData[srcPos];\r\n                    destArray[index + 1] = srcData[srcPos + 1];\r\n                    destArray[index + 2] = srcData[srcPos + 2];\r\n                    destArray[index + 3] = lod;\r\n                    index += 4;\r\n                }\r\n            }\r\n\r\n            return destArray;\r\n        }\r\n        return new Float32Array(arrayBuffer, dataOffset, dataLength);\r\n    }\r\n\r\n    private static _GetFloatAsHalfFloatRGBAArrayBuffer(width: number, height: number, dataOffset: number, dataLength: number, arrayBuffer: ArrayBuffer, lod: number): Uint16Array {\r\n        const destArray = new Uint16Array(dataLength);\r\n        const srcData = new Float32Array(arrayBuffer, dataOffset);\r\n        let index = 0;\r\n        for (let y = 0; y < height; y++) {\r\n            for (let x = 0; x < width; x++) {\r\n                destArray[index] = ToHalfFloat(srcData[index]);\r\n                destArray[index + 1] = ToHalfFloat(srcData[index + 1]);\r\n                destArray[index + 2] = ToHalfFloat(srcData[index + 2]);\r\n                if (DDSTools.StoreLODInAlphaChannel) {\r\n                    destArray[index + 3] = ToHalfFloat(lod);\r\n                } else {\r\n                    destArray[index + 3] = ToHalfFloat(srcData[index + 3]);\r\n                }\r\n                index += 4;\r\n            }\r\n        }\r\n\r\n        return destArray;\r\n    }\r\n\r\n    private static _GetFloatAsUIntRGBAArrayBuffer(width: number, height: number, dataOffset: number, dataLength: number, arrayBuffer: ArrayBuffer, lod: number): Uint8Array {\r\n        const destArray = new Uint8Array(dataLength);\r\n        const srcData = new Float32Array(arrayBuffer, dataOffset);\r\n        let index = 0;\r\n        for (let y = 0; y < height; y++) {\r\n            for (let x = 0; x < width; x++) {\r\n                const srcPos = (x + y * width) * 4;\r\n                destArray[index] = Clamp(srcData[srcPos]) * 255;\r\n                destArray[index + 1] = Clamp(srcData[srcPos + 1]) * 255;\r\n                destArray[index + 2] = Clamp(srcData[srcPos + 2]) * 255;\r\n                if (DDSTools.StoreLODInAlphaChannel) {\r\n                    destArray[index + 3] = lod;\r\n                } else {\r\n                    destArray[index + 3] = Clamp(srcData[srcPos + 3]) * 255;\r\n                }\r\n                index += 4;\r\n            }\r\n        }\r\n\r\n        return destArray;\r\n    }\r\n\r\n    private static _GetHalfFloatAsUIntRGBAArrayBuffer(width: number, height: number, dataOffset: number, dataLength: number, arrayBuffer: ArrayBuffer, lod: number): Uint8Array {\r\n        const destArray = new Uint8Array(dataLength);\r\n        const srcData = new Uint16Array(arrayBuffer, dataOffset);\r\n        let index = 0;\r\n        for (let y = 0; y < height; y++) {\r\n            for (let x = 0; x < width; x++) {\r\n                const srcPos = (x + y * width) * 4;\r\n                destArray[index] = Clamp(FromHalfFloat(srcData[srcPos])) * 255;\r\n                destArray[index + 1] = Clamp(FromHalfFloat(srcData[srcPos + 1])) * 255;\r\n                destArray[index + 2] = Clamp(FromHalfFloat(srcData[srcPos + 2])) * 255;\r\n                if (DDSTools.StoreLODInAlphaChannel) {\r\n                    destArray[index + 3] = lod;\r\n                } else {\r\n                    destArray[index + 3] = Clamp(FromHalfFloat(srcData[srcPos + 3])) * 255;\r\n                }\r\n                index += 4;\r\n            }\r\n        }\r\n\r\n        return destArray;\r\n    }\r\n\r\n    private static _GetRGBAArrayBuffer(\r\n        width: number,\r\n        height: number,\r\n        dataOffset: number,\r\n        dataLength: number,\r\n        arrayBuffer: ArrayBuffer,\r\n        rOffset: number,\r\n        gOffset: number,\r\n        bOffset: number,\r\n        aOffset: number\r\n    ): Uint8Array {\r\n        const byteArray = new Uint8Array(dataLength);\r\n        const srcData = new Uint8Array(arrayBuffer, dataOffset);\r\n        let index = 0;\r\n        for (let y = 0; y < height; y++) {\r\n            for (let x = 0; x < width; x++) {\r\n                const srcPos = (x + y * width) * 4;\r\n\r\n                byteArray[index] = srcData[srcPos + rOffset];\r\n                byteArray[index + 1] = srcData[srcPos + gOffset];\r\n                byteArray[index + 2] = srcData[srcPos + bOffset];\r\n                byteArray[index + 3] = srcData[srcPos + aOffset];\r\n                index += 4;\r\n            }\r\n        }\r\n\r\n        return byteArray;\r\n    }\r\n\r\n    private static _ExtractLongWordOrder(value: number): number {\r\n        if (value === 0 || value === 255 || value === -16777216) {\r\n            return 0;\r\n        }\r\n\r\n        return 1 + DDSTools._ExtractLongWordOrder(value >> 8);\r\n    }\r\n\r\n    private static _GetRGBArrayBuffer(\r\n        width: number,\r\n        height: number,\r\n        dataOffset: number,\r\n        dataLength: number,\r\n        arrayBuffer: ArrayBuffer,\r\n        rOffset: number,\r\n        gOffset: number,\r\n        bOffset: number\r\n    ): Uint8Array {\r\n        const byteArray = new Uint8Array(dataLength);\r\n        const srcData = new Uint8Array(arrayBuffer, dataOffset);\r\n        let index = 0;\r\n        for (let y = 0; y < height; y++) {\r\n            for (let x = 0; x < width; x++) {\r\n                const srcPos = (x + y * width) * 3;\r\n\r\n                byteArray[index] = srcData[srcPos + rOffset];\r\n                byteArray[index + 1] = srcData[srcPos + gOffset];\r\n                byteArray[index + 2] = srcData[srcPos + bOffset];\r\n                index += 3;\r\n            }\r\n        }\r\n\r\n        return byteArray;\r\n    }\r\n\r\n    private static _GetLuminanceArrayBuffer(width: number, height: number, dataOffset: number, dataLength: number, arrayBuffer: ArrayBuffer): Uint8Array {\r\n        const byteArray = new Uint8Array(dataLength);\r\n        const srcData = new Uint8Array(arrayBuffer, dataOffset);\r\n        let index = 0;\r\n        for (let y = 0; y < height; y++) {\r\n            for (let x = 0; x < width; x++) {\r\n                const srcPos = x + y * width;\r\n                byteArray[index] = srcData[srcPos];\r\n                index++;\r\n            }\r\n        }\r\n\r\n        return byteArray;\r\n    }\r\n\r\n    /**\r\n     * Uploads DDS Levels to a Babylon Texture\r\n     * @internal\r\n     */\r\n    public static UploadDDSLevels(\r\n        engine: AbstractEngine,\r\n        texture: InternalTexture,\r\n        data: ArrayBufferView,\r\n        info: DDSInfo,\r\n        loadMipmaps: boolean,\r\n        faces: number,\r\n        lodIndex = -1,\r\n        currentFace?: number,\r\n        destTypeMustBeFilterable = true\r\n    ) {\r\n        let sphericalPolynomialFaces: Nullable<Array<ArrayBufferView>> = null;\r\n        if (info.sphericalPolynomial) {\r\n            sphericalPolynomialFaces = [] as ArrayBufferView[];\r\n        }\r\n        const ext = !!engine.getCaps().s3tc;\r\n\r\n        // TODO WEBGPU Once generateMipMaps is split into generateMipMaps + hasMipMaps in InternalTexture this line can be removed\r\n        texture.generateMipMaps = loadMipmaps;\r\n\r\n        const header = new Int32Array(data.buffer, data.byteOffset, headerLengthInt);\r\n        let fourCC: number,\r\n            width: number,\r\n            height: number,\r\n            dataLength: number = 0,\r\n            dataOffset: number;\r\n        let byteArray: Uint8Array, mipmapCount: number, mip: number;\r\n        let internalCompressedFormat = 0;\r\n        let blockBytes = 1;\r\n\r\n        if (header[off_magic] !== DDS_MAGIC) {\r\n            Logger.Error(\"Invalid magic number in DDS header\");\r\n            return;\r\n        }\r\n\r\n        if (!info.isFourCC && !info.isRGB && !info.isLuminance) {\r\n            Logger.Error(\"Unsupported format, must contain a FourCC, RGB or LUMINANCE code\");\r\n            return;\r\n        }\r\n\r\n        if (info.isCompressed && !ext) {\r\n            Logger.Error(\"Compressed textures are not supported on this platform.\");\r\n            return;\r\n        }\r\n\r\n        let bpp = header[off_RGBbpp];\r\n        dataOffset = header[off_size] + 4;\r\n\r\n        let computeFormats = false;\r\n\r\n        if (info.isFourCC) {\r\n            fourCC = header[off_pfFourCC];\r\n            switch (fourCC) {\r\n                case FOURCC_DXT1:\r\n                    blockBytes = 8;\r\n                    internalCompressedFormat = Constants.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT1;\r\n                    break;\r\n                case FOURCC_DXT3:\r\n                    blockBytes = 16;\r\n                    internalCompressedFormat = Constants.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT3;\r\n                    break;\r\n                case FOURCC_DXT5:\r\n                    blockBytes = 16;\r\n                    internalCompressedFormat = Constants.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT5;\r\n                    break;\r\n                case FOURCC_D3DFMT_R16G16B16A16F:\r\n                    computeFormats = true;\r\n                    bpp = 64;\r\n                    break;\r\n                case FOURCC_D3DFMT_R32G32B32A32F:\r\n                    computeFormats = true;\r\n                    bpp = 128;\r\n                    break;\r\n                case FOURCC_DX10: {\r\n                    // There is an additionnal header so dataOffset need to be changed\r\n                    dataOffset += 5 * 4; // 5 uints\r\n\r\n                    let supported = false;\r\n                    switch (info.dxgiFormat) {\r\n                        case DXGI_FORMAT_R16G16B16A16_FLOAT:\r\n                            computeFormats = true;\r\n                            bpp = 64;\r\n                            supported = true;\r\n                            break;\r\n                        case DXGI_FORMAT_R32G32B32A32_FLOAT:\r\n                            computeFormats = true;\r\n                            bpp = 128;\r\n                            supported = true;\r\n                            break;\r\n                        case DXGI_FORMAT_B8G8R8X8_UNORM:\r\n                            info.isRGB = true;\r\n                            info.isFourCC = false;\r\n                            bpp = 32;\r\n                            supported = true;\r\n                            break;\r\n                    }\r\n\r\n                    if (supported) {\r\n                        break;\r\n                    }\r\n                }\r\n                // eslint-disable-next-line no-fallthrough\r\n                default:\r\n                    Logger.Error([\"Unsupported FourCC code:\", Int32ToFourCC(fourCC)]);\r\n                    return;\r\n            }\r\n        }\r\n\r\n        const rOffset = DDSTools._ExtractLongWordOrder(header[off_RMask]);\r\n        const gOffset = DDSTools._ExtractLongWordOrder(header[off_GMask]);\r\n        const bOffset = DDSTools._ExtractLongWordOrder(header[off_BMask]);\r\n        const aOffset = DDSTools._ExtractLongWordOrder(header[off_AMask]);\r\n\r\n        if (computeFormats) {\r\n            internalCompressedFormat = engine._getRGBABufferInternalSizedFormat(info.textureType);\r\n        }\r\n\r\n        mipmapCount = 1;\r\n        if (header[off_flags] & DDSD_MIPMAPCOUNT && loadMipmaps !== false) {\r\n            mipmapCount = Math.max(1, header[off_mipmapCount]);\r\n        }\r\n\r\n        const startFace = currentFace || 0;\r\n        const caps = engine.getCaps();\r\n        for (let face = startFace; face < faces; face++) {\r\n            width = header[off_width];\r\n            height = header[off_height];\r\n\r\n            for (mip = 0; mip < mipmapCount; ++mip) {\r\n                if (lodIndex === -1 || lodIndex === mip) {\r\n                    // In case of fixed LOD, if the lod has just been uploaded, early exit.\r\n                    const i = lodIndex === -1 ? mip : 0;\r\n\r\n                    if (!info.isCompressed && info.isFourCC) {\r\n                        texture.format = Constants.TEXTUREFORMAT_RGBA;\r\n                        dataLength = width * height * 4;\r\n                        let floatArray: Nullable<ArrayBufferView> = null;\r\n\r\n                        if (engine._badOS || engine._badDesktopOS || (!caps.textureHalfFloat && !caps.textureFloat)) {\r\n                            // Required because iOS has many issues with float and half float generation\r\n                            if (bpp === 128) {\r\n                                floatArray = DDSTools._GetFloatAsUIntRGBAArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, i);\r\n                                if (sphericalPolynomialFaces && i == 0) {\r\n                                    sphericalPolynomialFaces.push(DDSTools._GetFloatRGBAArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, i));\r\n                                }\r\n                            } else if (bpp === 64) {\r\n                                floatArray = DDSTools._GetHalfFloatAsUIntRGBAArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, i);\r\n                                if (sphericalPolynomialFaces && i == 0) {\r\n                                    sphericalPolynomialFaces.push(\r\n                                        DDSTools._GetHalfFloatAsFloatRGBAArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, i)\r\n                                    );\r\n                                }\r\n                            }\r\n\r\n                            texture.type = Constants.TEXTURETYPE_UNSIGNED_BYTE;\r\n                        } else {\r\n                            const floatAvailable = caps.textureFloat && ((destTypeMustBeFilterable && caps.textureFloatLinearFiltering) || !destTypeMustBeFilterable);\r\n                            const halfFloatAvailable = caps.textureHalfFloat && ((destTypeMustBeFilterable && caps.textureHalfFloatLinearFiltering) || !destTypeMustBeFilterable);\r\n\r\n                            const destType =\r\n                                (bpp === 128 || (bpp === 64 && !halfFloatAvailable)) && floatAvailable\r\n                                    ? Constants.TEXTURETYPE_FLOAT\r\n                                    : (bpp === 64 || (bpp === 128 && !floatAvailable)) && halfFloatAvailable\r\n                                      ? Constants.TEXTURETYPE_HALF_FLOAT\r\n                                      : Constants.TEXTURETYPE_UNSIGNED_BYTE;\r\n\r\n                            let dataGetter: (width: number, height: number, dataOffset: number, dataLength: number, arrayBuffer: ArrayBuffer, lod: number) => ArrayBufferView;\r\n                            let dataGetterPolynomial: Nullable<\r\n                                (width: number, height: number, dataOffset: number, dataLength: number, arrayBuffer: ArrayBuffer, lod: number) => ArrayBufferView\r\n                            > = null;\r\n\r\n                            switch (bpp) {\r\n                                case 128: {\r\n                                    switch (destType) {\r\n                                        case Constants.TEXTURETYPE_FLOAT:\r\n                                            dataGetter = DDSTools._GetFloatRGBAArrayBuffer;\r\n                                            dataGetterPolynomial = null;\r\n                                            break;\r\n                                        case Constants.TEXTURETYPE_HALF_FLOAT:\r\n                                            dataGetter = DDSTools._GetFloatAsHalfFloatRGBAArrayBuffer;\r\n                                            dataGetterPolynomial = DDSTools._GetFloatRGBAArrayBuffer;\r\n                                            break;\r\n                                        case Constants.TEXTURETYPE_UNSIGNED_BYTE:\r\n                                            dataGetter = DDSTools._GetFloatAsUIntRGBAArrayBuffer;\r\n                                            dataGetterPolynomial = DDSTools._GetFloatRGBAArrayBuffer;\r\n                                            break;\r\n                                    }\r\n                                    break;\r\n                                }\r\n                                default: {\r\n                                    // 64 bpp\r\n                                    switch (destType) {\r\n                                        case Constants.TEXTURETYPE_FLOAT:\r\n                                            dataGetter = DDSTools._GetHalfFloatAsFloatRGBAArrayBuffer;\r\n                                            dataGetterPolynomial = null;\r\n                                            break;\r\n                                        case Constants.TEXTURETYPE_HALF_FLOAT:\r\n                                            dataGetter = DDSTools._GetHalfFloatRGBAArrayBuffer;\r\n                                            dataGetterPolynomial = DDSTools._GetHalfFloatAsFloatRGBAArrayBuffer;\r\n                                            break;\r\n                                        case Constants.TEXTURETYPE_UNSIGNED_BYTE:\r\n                                            dataGetter = DDSTools._GetHalfFloatAsUIntRGBAArrayBuffer;\r\n                                            dataGetterPolynomial = DDSTools._GetHalfFloatAsFloatRGBAArrayBuffer;\r\n                                            break;\r\n                                    }\r\n                                    break;\r\n                                }\r\n                            }\r\n\r\n                            texture.type = destType;\r\n\r\n                            floatArray = dataGetter(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, i);\r\n\r\n                            if (sphericalPolynomialFaces && i == 0) {\r\n                                sphericalPolynomialFaces.push(\r\n                                    dataGetterPolynomial ? dataGetterPolynomial(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, i) : floatArray\r\n                                );\r\n                            }\r\n                        }\r\n\r\n                        if (floatArray) {\r\n                            engine._uploadDataToTextureDirectly(texture, floatArray, face, i);\r\n                        }\r\n                    } else if (info.isRGB) {\r\n                        texture.type = Constants.TEXTURETYPE_UNSIGNED_BYTE;\r\n                        if (bpp === 24) {\r\n                            texture.format = Constants.TEXTUREFORMAT_RGB;\r\n                            dataLength = width * height * 3;\r\n                            byteArray = DDSTools._GetRGBArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, rOffset, gOffset, bOffset);\r\n                            engine._uploadDataToTextureDirectly(texture, byteArray, face, i);\r\n                        } else {\r\n                            // 32\r\n                            texture.format = Constants.TEXTUREFORMAT_RGBA;\r\n                            dataLength = width * height * 4;\r\n                            byteArray = DDSTools._GetRGBAArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, rOffset, gOffset, bOffset, aOffset);\r\n                            engine._uploadDataToTextureDirectly(texture, byteArray, face, i);\r\n                        }\r\n                    } else if (info.isLuminance) {\r\n                        const unpackAlignment = engine._getUnpackAlignement();\r\n                        const unpaddedRowSize = width;\r\n                        const paddedRowSize = Math.floor((width + unpackAlignment - 1) / unpackAlignment) * unpackAlignment;\r\n                        dataLength = paddedRowSize * (height - 1) + unpaddedRowSize;\r\n\r\n                        byteArray = DDSTools._GetLuminanceArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer);\r\n                        texture.format = Constants.TEXTUREFORMAT_LUMINANCE;\r\n                        texture.type = Constants.TEXTURETYPE_UNSIGNED_BYTE;\r\n\r\n                        engine._uploadDataToTextureDirectly(texture, byteArray, face, i);\r\n                    } else {\r\n                        dataLength = (((Math.max(4, width) / 4) * Math.max(4, height)) / 4) * blockBytes;\r\n                        byteArray = new Uint8Array(data.buffer, data.byteOffset + dataOffset, dataLength);\r\n\r\n                        texture.type = Constants.TEXTURETYPE_UNSIGNED_BYTE;\r\n                        engine._uploadCompressedDataToTextureDirectly(texture, internalCompressedFormat, width, height, byteArray, face, i);\r\n                    }\r\n                }\r\n                dataOffset += bpp ? width * height * (bpp / 8) : dataLength;\r\n                width *= 0.5;\r\n                height *= 0.5;\r\n\r\n                width = Math.max(1.0, width);\r\n                height = Math.max(1.0, height);\r\n            }\r\n\r\n            if (currentFace !== undefined) {\r\n                // Loading a single face\r\n                break;\r\n            }\r\n        }\r\n        if (sphericalPolynomialFaces && sphericalPolynomialFaces.length > 0) {\r\n            info.sphericalPolynomial = CubeMapToSphericalPolynomialTools.ConvertCubeMapToSphericalPolynomial({\r\n                size: header[off_width],\r\n                right: sphericalPolynomialFaces[0],\r\n                left: sphericalPolynomialFaces[1],\r\n                up: sphericalPolynomialFaces[2],\r\n                down: sphericalPolynomialFaces[3],\r\n                front: sphericalPolynomialFaces[4],\r\n                back: sphericalPolynomialFaces[5],\r\n                format: Constants.TEXTUREFORMAT_RGBA,\r\n                type: Constants.TEXTURETYPE_FLOAT,\r\n                gammaSpace: false,\r\n            });\r\n        } else {\r\n            info.sphericalPolynomial = undefined;\r\n        }\r\n    }\r\n}\r\n","import { Vector3 } from \"../../Maths/math.vector\";\r\nimport { Clamp } from \"../../Maths/math.scalar.functions\";\r\nimport { SphericalPolynomial, SphericalHarmonics } from \"../../Maths/sphericalPolynomial\";\r\nimport type { BaseTexture } from \"../../Materials/Textures/baseTexture\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { Constants } from \"../../Engines/constants\";\r\nimport type { CubeMapInfo } from \"./panoramaToCubemap\";\r\nimport { ToLinearSpace } from \"../../Maths/math.constants\";\r\nimport { Color3 } from \"../../Maths/math.color\";\r\n\r\nclass FileFaceOrientation {\r\n    public name: string;\r\n    public worldAxisForNormal: Vector3; // the world axis corresponding to the normal to the face\r\n    public worldAxisForFileX: Vector3; // the world axis corresponding to texture right x-axis in file\r\n    public worldAxisForFileY: Vector3; // the world axis corresponding to texture down y-axis in file\r\n\r\n    public constructor(name: string, worldAxisForNormal: Vector3, worldAxisForFileX: Vector3, worldAxisForFileY: Vector3) {\r\n        this.name = name;\r\n        this.worldAxisForNormal = worldAxisForNormal;\r\n        this.worldAxisForFileX = worldAxisForFileX;\r\n        this.worldAxisForFileY = worldAxisForFileY;\r\n    }\r\n}\r\n\r\n/**\r\n * Helper class dealing with the extraction of spherical polynomial dataArray\r\n * from a cube map.\r\n */\r\nexport class CubeMapToSphericalPolynomialTools {\r\n    private static _FileFaces: FileFaceOrientation[] = [\r\n        new FileFaceOrientation(\"right\", new Vector3(1, 0, 0), new Vector3(0, 0, -1), new Vector3(0, -1, 0)), // +X east\r\n        new FileFaceOrientation(\"left\", new Vector3(-1, 0, 0), new Vector3(0, 0, 1), new Vector3(0, -1, 0)), // -X west\r\n        new FileFaceOrientation(\"up\", new Vector3(0, 1, 0), new Vector3(1, 0, 0), new Vector3(0, 0, 1)), // +Y north\r\n        new FileFaceOrientation(\"down\", new Vector3(0, -1, 0), new Vector3(1, 0, 0), new Vector3(0, 0, -1)), // -Y south\r\n        new FileFaceOrientation(\"front\", new Vector3(0, 0, 1), new Vector3(1, 0, 0), new Vector3(0, -1, 0)), // +Z top\r\n        new FileFaceOrientation(\"back\", new Vector3(0, 0, -1), new Vector3(-1, 0, 0), new Vector3(0, -1, 0)), // -Z bottom\r\n    ];\r\n\r\n    /** @internal */\r\n    public static MAX_HDRI_VALUE = 4096;\r\n    /** @internal */\r\n    public static PRESERVE_CLAMPED_COLORS = false;\r\n\r\n    /**\r\n     * Converts a texture to the according Spherical Polynomial data.\r\n     * This extracts the first 3 orders only as they are the only one used in the lighting.\r\n     *\r\n     * @param texture The texture to extract the information from.\r\n     * @returns The Spherical Polynomial data.\r\n     */\r\n    public static ConvertCubeMapTextureToSphericalPolynomial(texture: BaseTexture): Nullable<Promise<SphericalPolynomial>> {\r\n        if (!texture.isCube) {\r\n            // Only supports cube Textures currently.\r\n            return null;\r\n        }\r\n\r\n        texture.getScene()?.getEngine().flushFramebuffer();\r\n\r\n        const size = texture.getSize().width;\r\n        const rightPromise = texture.readPixels(0, undefined, undefined, false);\r\n        const leftPromise = texture.readPixels(1, undefined, undefined, false);\r\n\r\n        let upPromise: Nullable<Promise<ArrayBufferView>>;\r\n        let downPromise: Nullable<Promise<ArrayBufferView>>;\r\n        if (texture.isRenderTarget) {\r\n            upPromise = texture.readPixels(3, undefined, undefined, false);\r\n            downPromise = texture.readPixels(2, undefined, undefined, false);\r\n        } else {\r\n            upPromise = texture.readPixels(2, undefined, undefined, false);\r\n            downPromise = texture.readPixels(3, undefined, undefined, false);\r\n        }\r\n\r\n        const frontPromise = texture.readPixels(4, undefined, undefined, false);\r\n        const backPromise = texture.readPixels(5, undefined, undefined, false);\r\n\r\n        const gammaSpace = texture.gammaSpace;\r\n        // Always read as RGBA.\r\n        const format = Constants.TEXTUREFORMAT_RGBA;\r\n        let type = Constants.TEXTURETYPE_UNSIGNED_BYTE;\r\n        if (texture.textureType == Constants.TEXTURETYPE_FLOAT || texture.textureType == Constants.TEXTURETYPE_HALF_FLOAT) {\r\n            type = Constants.TEXTURETYPE_FLOAT;\r\n        }\r\n\r\n        return new Promise((resolve) => {\r\n            Promise.all([leftPromise, rightPromise, upPromise, downPromise, frontPromise, backPromise]).then(([left, right, up, down, front, back]) => {\r\n                const cubeInfo: CubeMapInfo = {\r\n                    size,\r\n                    right,\r\n                    left,\r\n                    up,\r\n                    down,\r\n                    front,\r\n                    back,\r\n                    format,\r\n                    type,\r\n                    gammaSpace,\r\n                };\r\n\r\n                resolve(this.ConvertCubeMapToSphericalPolynomial(cubeInfo));\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Compute the area on the unit sphere of the rectangle defined by (x,y) and the origin\r\n     * See https://www.rorydriscoll.com/2012/01/15/cubemap-texel-solid-angle/\r\n     * @param x\r\n     * @param y\r\n     * @returns the area\r\n     */\r\n    private static _AreaElement(x: number, y: number): number {\r\n        return Math.atan2(x * y, Math.sqrt(x * x + y * y + 1));\r\n    }\r\n\r\n    /**\r\n     * Converts a cubemap to the according Spherical Polynomial data.\r\n     * This extracts the first 3 orders only as they are the only one used in the lighting.\r\n     *\r\n     * @param cubeInfo The Cube map to extract the information from.\r\n     * @returns The Spherical Polynomial data.\r\n     */\r\n    public static ConvertCubeMapToSphericalPolynomial(cubeInfo: CubeMapInfo): SphericalPolynomial {\r\n        const sphericalHarmonics = new SphericalHarmonics();\r\n        let totalSolidAngle = 0.0;\r\n\r\n        // The (u,v) range is [-1,+1], so the distance between each texel is 2/Size.\r\n        const du = 2.0 / cubeInfo.size;\r\n        const dv = du;\r\n\r\n        const halfTexel = 0.5 * du;\r\n\r\n        // The (u,v) of the first texel is half a texel from the corner (-1,-1).\r\n        const minUV = halfTexel - 1.0;\r\n\r\n        for (let faceIndex = 0; faceIndex < 6; faceIndex++) {\r\n            const fileFace = this._FileFaces[faceIndex];\r\n            const dataArray = (<any>cubeInfo)[fileFace.name];\r\n            let v = minUV;\r\n\r\n            // TODO: we could perform the summation directly into a SphericalPolynomial (SP), which is more efficient than SphericalHarmonic (SH).\r\n            // This is possible because during the summation we do not need the SH-specific properties, e.g. orthogonality.\r\n            // Because SP is still linear, so summation is fine in that basis.\r\n            const stride = cubeInfo.format === Constants.TEXTUREFORMAT_RGBA ? 4 : 3;\r\n            for (let y = 0; y < cubeInfo.size; y++) {\r\n                let u = minUV;\r\n\r\n                for (let x = 0; x < cubeInfo.size; x++) {\r\n                    // World direction (not normalised)\r\n                    const worldDirection = fileFace.worldAxisForFileX.scale(u).add(fileFace.worldAxisForFileY.scale(v)).add(fileFace.worldAxisForNormal);\r\n                    worldDirection.normalize();\r\n\r\n                    const deltaSolidAngle =\r\n                        this._AreaElement(u - halfTexel, v - halfTexel) -\r\n                        this._AreaElement(u - halfTexel, v + halfTexel) -\r\n                        this._AreaElement(u + halfTexel, v - halfTexel) +\r\n                        this._AreaElement(u + halfTexel, v + halfTexel);\r\n\r\n                    let r = dataArray[y * cubeInfo.size * stride + x * stride + 0];\r\n                    let g = dataArray[y * cubeInfo.size * stride + x * stride + 1];\r\n                    let b = dataArray[y * cubeInfo.size * stride + x * stride + 2];\r\n\r\n                    // Prevent NaN harmonics with extreme HDRI data.\r\n                    if (isNaN(r)) {\r\n                        r = 0;\r\n                    }\r\n                    if (isNaN(g)) {\r\n                        g = 0;\r\n                    }\r\n                    if (isNaN(b)) {\r\n                        b = 0;\r\n                    }\r\n\r\n                    // Handle Integer types.\r\n                    if (cubeInfo.type === Constants.TEXTURETYPE_UNSIGNED_BYTE) {\r\n                        r /= 255;\r\n                        g /= 255;\r\n                        b /= 255;\r\n                    }\r\n\r\n                    // Handle Gamma space textures.\r\n                    if (cubeInfo.gammaSpace) {\r\n                        r = Math.pow(Clamp(r), ToLinearSpace);\r\n                        g = Math.pow(Clamp(g), ToLinearSpace);\r\n                        b = Math.pow(Clamp(b), ToLinearSpace);\r\n                    }\r\n\r\n                    // Prevent to explode in case of really high dynamic ranges.\r\n                    // sh 3 would not be enough to accurately represent it.\r\n                    const max = this.MAX_HDRI_VALUE;\r\n                    if (this.PRESERVE_CLAMPED_COLORS) {\r\n                        const currentMax = Math.max(r, g, b);\r\n                        if (currentMax > max) {\r\n                            const factor = max / currentMax;\r\n                            r *= factor;\r\n                            g *= factor;\r\n                            b *= factor;\r\n                        }\r\n                    } else {\r\n                        r = Clamp(r, 0, max);\r\n                        g = Clamp(g, 0, max);\r\n                        b = Clamp(b, 0, max);\r\n                    }\r\n\r\n                    const color = new Color3(r, g, b);\r\n\r\n                    sphericalHarmonics.addLight(worldDirection, color, deltaSolidAngle);\r\n\r\n                    totalSolidAngle += deltaSolidAngle;\r\n\r\n                    u += du;\r\n                }\r\n\r\n                v += dv;\r\n            }\r\n        }\r\n\r\n        // Solid angle for entire sphere is 4*pi\r\n        const sphereSolidAngle = 4.0 * Math.PI;\r\n\r\n        // Adjust the solid angle to allow for how many faces we processed.\r\n        const facesProcessed = 6.0;\r\n        const expectedSolidAngle = (sphereSolidAngle * facesProcessed) / 6.0;\r\n\r\n        // Adjust the harmonics so that the accumulated solid angle matches the expected solid angle.\r\n        // This is needed because the numerical integration over the cube uses a\r\n        // small angle approximation of solid angle for each texel (see deltaSolidAngle),\r\n        // and also to compensate for accumulative error due to float precision in the summation.\r\n        const correctionFactor = expectedSolidAngle / totalSolidAngle;\r\n        sphericalHarmonics.scaleInPlace(correctionFactor);\r\n\r\n        sphericalHarmonics.convertIncidentRadianceToIrradiance();\r\n        sphericalHarmonics.convertIrradianceToLambertianRadiance();\r\n\r\n        return SphericalPolynomial.FromHarmonics(sphericalHarmonics);\r\n    }\r\n}\r\n"],"names":["_DDSTextureLoader","supportCascades","loadCubeData","imgs","texture","createPolynomials","onLoad","engine","getEngine","info","loadMipmap","maxLevel","Array","isArray","index","length","data","DDSTools","GetDDSInfo","width","height","isRGB","isLuminance","mipmapCount","generateMipMaps","_unpackFlipY","isCompressed","UploadDDSLevels","isFourCC","generateMipMapsForCubemap","sphericalPolynomial","_setCubeMapTextureParams","isReady","onLoadedObservable","notifyObservers","clear","isDDS","loadData","callback","Math","max","prototype","_partialLoadFile","url","loadedFiles","onfinish","onErrorCallBack","this","_loadFile","_internalCount","undefined","request","exception","status","statusText","_cascadeLoadFiles","scene","files","onError","_cascadeLoadImgs","mimeType","loadedImages","_partialLoadImg","tokenPendingData","img","removePendingData","message","offlineProvider","addPendingData","createCubeTextureBase","rootUrl","noMipmap","format","forcedExtension","lodScale","lodOffset","fallback","beforeLoadCubeDataCallback","imageHandler","useSRGBBuffer","buffer","isCube","_lodGenerationScale","_lodGenerationOffset","_useSRGBBuffer","_caps","supportSRGBBuffers","version","isWebGPU","label","substring","_doNotHandleContextLost","_extension","_files","_buffer","originalRootUrl","_transformTextureUrl","extension","urlWithoutUriParams","split","lastDot","lastIndexOf","toLowerCase","GetExtensionFromUrl","loaderPromise","onInternalError","Warn","then","loader","onloaddata","images","map","image","Uint8Array","Error","_internalTexturesCache","push","DDSD_MIPMAPCOUNT","DDPF_LUMINANCE","FourCCToInt32","value","charCodeAt","FOURCC_DXT1","FOURCC_DXT3","FOURCC_DXT5","FOURCC_DX10","header","Int32Array","byteOffset","extendedHeader","headerLengthInt","fourCC","dxgiFormat","textureType","_GetHalfFloatAsFloatRGBAArrayBuffer","dataOffset","dataLength","arrayBuffer","lod","destArray","Float32Array","srcData","Uint16Array","y","x","srcPos","StoreLODInAlphaChannel","_GetHalfFloatRGBAArrayBuffer","_GetFloatRGBAArrayBuffer","_GetFloatAsHalfFloatRGBAArrayBuffer","_GetFloatAsUIntRGBAArrayBuffer","_GetHalfFloatAsUIntRGBAArrayBuffer","_GetRGBAArrayBuffer","rOffset","gOffset","bOffset","aOffset","byteArray","_ExtractLongWordOrder","_GetRGBArrayBuffer","_GetLuminanceArrayBuffer","loadMipmaps","faces","lodIndex","currentFace","destTypeMustBeFilterable","sphericalPolynomialFaces","ext","getCaps","s3tc","mip","internalCompressedFormat","blockBytes","bpp","computeFormats","supported","String","fromCharCode","_getRGBABufferInternalSizedFormat","startFace","caps","face","i","floatArray","_badOS","_badDesktopOS","textureHalfFloat","textureFloat","type","floatAvailable","textureFloatLinearFiltering","halfFloatAvailable","textureHalfFloatLinearFiltering","destType","dataGetter","dataGetterPolynomial","_uploadDataToTextureDirectly","unpackAlignment","_getUnpackAlignement","unpaddedRowSize","floor","_uploadCompressedDataToTextureDirectly","ConvertCubeMapToSphericalPolynomial","size","right","left","up","down","front","back","gammaSpace","FileFaceOrientation","name","worldAxisForNormal","worldAxisForFileX","worldAxisForFileY","CubeMapToSphericalPolynomialTools","ConvertCubeMapTextureToSphericalPolynomial","getScene","flushFramebuffer","getSize","rightPromise","readPixels","leftPromise","upPromise","downPromise","isRenderTarget","frontPromise","backPromise","Promise","resolve","all","cubeInfo","_AreaElement","atan2","sqrt","sphericalHarmonics","totalSolidAngle","du","dv","halfTexel","minUV","faceIndex","fileFace","_FileFaces","dataArray","v","stride","u","worldDirection","scale","add","normalize","deltaSolidAngle","r","g","b","isNaN","pow","MAX_HDRI_VALUE","PRESERVE_CLAMPED_COLORS","currentMax","factor","color","addLight","correctionFactor","PI","scaleInPlace","convertIncidentRadianceToIrradiance","convertIrradianceToLambertianRadiance","FromHarmonics"],"sourceRoot":""}