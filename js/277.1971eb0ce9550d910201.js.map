{"version":3,"file":"js/277.1971eb0ce9550d910201.js","mappings":"2KAGA,MAAMA,EAAO,oBA8BR,IAAYC,yBAAyBD,KACtC,IAAYC,yBAAyBD,GA9B1B,2pB,+BCDf,MAAMA,EAAO,+BAqBR,IAAYC,yBAAyBD,KACtC,IAAYC,yBAAyBD,GArB1B,uV,sFCDf,MAAM,EAAO,uBAWR,IAAYC,yBAAyB,KACtC,IAAYA,yBAAyB,GAX1B,6bAcR,MCbD,EAAO,oCAkBR,IAAYA,yBAAyB,KACtC,IAAYA,yBAAyB,GAlB1B,ya,gBCHf,MAAM,EAAO,oBA+BR,IAAYA,yBAAyB,KACtC,IAAYA,yBAAyB,GA/B1B,wmCAkCR,MC/BD,EAAO,uBACP,EAAS,upCA4BV,IAAYC,iBAAiB,KAC9B,IAAYA,iBAAiB,GAAQ,GAGlC,MAAMC,EAA2B,CAAEH,KAAI,EAAEI,OAAM,E,+BCrCtD,MAAMJ,EAAO,mBAMR,IAAYC,yBAAyBD,KACtC,IAAYC,yBAAyBD,GAN1B,qY","sources":["webpack://babylonjs-typescript-webpack-template/./dev/core/src/ShadersWGSL/ShadersInclude/clipPlaneFragment.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/ShadersWGSL/ShadersInclude/clipPlaneFragmentDeclaration.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/ShadersWGSL/ShadersInclude/bayerDitherFunctions.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/ShadersWGSL/ShadersInclude/shadowMapFragmentExtraDeclaration.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/ShadersWGSL/ShadersInclude/shadowMapFragment.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/ShadersWGSL/shadowMap.fragment.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/ShadersWGSL/ShadersInclude/packingFunctions.ts"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"clipPlaneFragment\";\nconst shader = `#if defined(CLIPPLANE) || defined(CLIPPLANE2) || defined(CLIPPLANE3) || defined(CLIPPLANE4) || defined(CLIPPLANE5) || defined(CLIPPLANE6)\nif (false) {}\n#endif\n#ifdef CLIPPLANE\nelse if (fragmentInputs.fClipDistance>0.0)\n{discard;}\n#endif\n#ifdef CLIPPLANE2\nelse if (fragmentInputs.fClipDistance2>0.0)\n{discard;}\n#endif\n#ifdef CLIPPLANE3\nelse if (fragmentInputs.fClipDistance3>0.0)\n{discard;}\n#endif\n#ifdef CLIPPLANE4\nelse if (fragmentInputs.fClipDistance4>0.0)\n{discard;}\n#endif\n#ifdef CLIPPLANE5\nelse if (fragmentInputs.fClipDistance5>0.0)\n{discard;}\n#endif\n#ifdef CLIPPLANE6\nelse if (fragmentInputs.fClipDistance6>0.0)\n{discard;}\n#endif\n`;\n// Sideeffect\nif (!ShaderStore.IncludesShadersStoreWGSL[name]) {\n    ShaderStore.IncludesShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const clipPlaneFragmentWGSL = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"clipPlaneFragmentDeclaration\";\nconst shader = `#ifdef CLIPPLANE\nvarying fClipDistance: f32;\n#endif\n#ifdef CLIPPLANE2\nvarying fClipDistance2: f32;\n#endif\n#ifdef CLIPPLANE3\nvarying fClipDistance3: f32;\n#endif\n#ifdef CLIPPLANE4\nvarying fClipDistance4: f32;\n#endif\n#ifdef CLIPPLANE5\nvarying fClipDistance5: f32;\n#endif\n#ifdef CLIPPLANE6\nvarying fClipDistance6: f32;\n#endif\n`;\n// Sideeffect\nif (!ShaderStore.IncludesShadersStoreWGSL[name]) {\n    ShaderStore.IncludesShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const clipPlaneFragmentDeclarationWGSL = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"bayerDitherFunctions\";\nconst shader = `fn bayerDither2(_P: vec2f)->f32 {return ((2.0*_P.y+_P.x+1.0)%(4.0));}\nfn bayerDither4(_P: vec2f)->f32 {var P1: vec2f=((_P)%(2.0)); \nvar P2: vec2f=floor(0.5*((_P)%(4.0))); \nreturn 4.0*bayerDither2(P1)+bayerDither2(P2);}\nfn bayerDither8(_P: vec2f)->f32 {var P1: vec2f=((_P)%(2.0)); \nvar P2: vec2f=floor(0.5 *((_P)%(4.0))); \nvar P4: vec2f=floor(0.25*((_P)%(8.0))); \nreturn 4.0*(4.0*bayerDither2(P1)+bayerDither2(P2))+bayerDither2(P4);}\n`;\n// Sideeffect\nif (!ShaderStore.IncludesShadersStoreWGSL[name]) {\n    ShaderStore.IncludesShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const bayerDitherFunctionsWGSL = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\nimport \"./packingFunctions\";\nimport \"./bayerDitherFunctions\";\n\nconst name = \"shadowMapFragmentExtraDeclaration\";\nconst shader = `#if SM_FLOAT==0\n#include<packingFunctions>\n#endif\n#if SM_SOFTTRANSPARENTSHADOW==1\n#include<bayerDitherFunctions>\nuniform softTransparentShadowSM: vec2f;\n#endif\nvarying vDepthMetricSM: f32;\n#if SM_USEDISTANCE==1\nuniform lightDataSM: vec3f;varying vPositionWSM: vec3f;\n#endif\nuniform biasAndScaleSM: vec3f;uniform depthValuesSM: vec2f;\n#if defined(SM_DEPTHCLAMP) && SM_DEPTHCLAMP==1\nvarying zSM: f32;\n#endif\n`;\n// Sideeffect\nif (!ShaderStore.IncludesShadersStoreWGSL[name]) {\n    ShaderStore.IncludesShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const shadowMapFragmentExtraDeclarationWGSL = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"shadowMapFragment\";\nconst shader = `var depthSM: f32=fragmentInputs.vDepthMetricSM;\n#if defined(SM_DEPTHCLAMP) && SM_DEPTHCLAMP==1\n#if SM_USEDISTANCE==1\ndepthSM=(length(fragmentInputs.vPositionWSM-uniforms.lightDataSM)+uniforms.depthValuesSM.x)/uniforms.depthValuesSM.y+uniforms.biasAndScaleSM.x;\n#else\n#ifdef USE_REVERSE_DEPTHBUFFER\ndepthSM=(-fragmentInputs.zSM+uniforms.depthValuesSM.x)/uniforms.depthValuesSM.y+uniforms.biasAndScaleSM.x;\n#else\ndepthSM=(fragmentInputs.zSM+uniforms.depthValuesSM.x)/uniforms.depthValuesSM.y+uniforms.biasAndScaleSM.x;\n#endif\n#endif\ndepthSM=clamp(depthSM,0.0,1.0);\n#ifdef USE_REVERSE_DEPTHBUFFER\nfragmentOutputs.fragDepth=clamp(1.0-depthSM,0.0,1.0);\n#else\nfragmentOutputs.fragDepth=clamp(depthSM,0.0,1.0); \n#endif\n#elif SM_USEDISTANCE==1\ndepthSM=(length(fragmentInputs.vPositionWSM-uniforms.lightDataSM)+uniforms.depthValuesSM.x)/uniforms.depthValuesSM.y+uniforms.biasAndScaleSM.x;\n#endif\n#if SM_ESM==1\ndepthSM=clamp(exp(-min(87.,uniforms.biasAndScaleSM.z*depthSM)),0.,1.);\n#endif\n#if SM_FLOAT==1\nfragmentOutputs.color= vec4f(depthSM,1.0,1.0,1.0);\n#else\nfragmentOutputs.color=pack(depthSM);\n#endif\n`;\n// Sideeffect\nif (!ShaderStore.IncludesShadersStoreWGSL[name]) {\n    ShaderStore.IncludesShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const shadowMapFragmentWGSL = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/shadowMapFragmentExtraDeclaration\";\nimport \"./ShadersInclude/clipPlaneFragmentDeclaration\";\nimport \"./ShadersInclude/clipPlaneFragment\";\nimport \"./ShadersInclude/shadowMapFragment\";\n\nconst name = \"shadowMapPixelShader\";\nconst shader = `#include<shadowMapFragmentExtraDeclaration>\n#ifdef ALPHATEXTURE\nvarying vUV: vec2f;var diffuseSamplerSampler: sampler;var diffuseSampler: texture_2d<f32>;\n#endif\n#include<clipPlaneFragmentDeclaration>\n#define CUSTOM_FRAGMENT_DEFINITIONS\n@fragment\nfn main(input: FragmentInputs)->FragmentOutputs {\n#include<clipPlaneFragment>\n#ifdef ALPHATEXTURE\nvar opacityMap: vec4f=textureSample(diffuseSampler,diffuseSamplerSampler,fragmentInputs.vUV);var alphaFromAlphaTexture: f32=opacityMap.a;\n#if SM_SOFTTRANSPARENTSHADOW==1\nif (uniforms.softTransparentShadowSM.y==1.0) {opacityMap=vec4f(opacityMap.rgb* vec3f(0.3,0.59,0.11),opacityMap.a);alphaFromAlphaTexture=opacityMap.x+opacityMap.y+opacityMap.z;}\n#endif\n#ifdef ALPHATESTVALUE\nif (alphaFromAlphaTexture<ALPHATESTVALUE) {discard;}\n#endif\n#endif\n#if SM_SOFTTRANSPARENTSHADOW==1\n#ifdef ALPHATEXTURE\nif ((bayerDither8(floor(((fragmentInputs.position.xy)%(8.0)))))/64.0>=uniforms.softTransparentShadowSM.x*alphaFromAlphaTexture) {discard;}\n#else\nif ((bayerDither8(floor(((fragmentInputs.position.xy)%(8.0)))))/64.0>=uniforms.softTransparentShadowSM.x) {discard;} \n#endif\n#endif\n#include<shadowMapFragment>\n}`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const shadowMapPixelShaderWGSL = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"packingFunctions\";\nconst shader = `fn pack(depth: f32)->vec4f\n{const bit_shift: vec4f= vec4f(255.0*255.0*255.0,255.0*255.0,255.0,1.0);const bit_mask: vec4f= vec4f(0.0,1.0/255.0,1.0/255.0,1.0/255.0);var res: vec4f=fract(depth*bit_shift);res-=res.xxyz*bit_mask;return res;}\nfn unpack(color: vec4f)->f32\n{const bit_shift: vec4f= vec4f(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);return dot(color,bit_shift);}`;\n// Sideeffect\nif (!ShaderStore.IncludesShadersStoreWGSL[name]) {\n    ShaderStore.IncludesShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const packingFunctionsWGSL = { name, shader };\n"],"names":["name","IncludesShadersStoreWGSL","ShadersStoreWGSL","shadowMapPixelShaderWGSL","shader"],"sourceRoot":""}