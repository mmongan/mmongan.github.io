{"version":3,"file":"js/186.54207b4ac2e045a0f9ac.js","mappings":"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","sources":["webpack://babylonjs-typescript-webpack-template/./dev/core/src/Misc/basis.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Misc/basisWorker.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Materials/Textures/Loaders/basisTextureLoader.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { Nullable } from \"../types\";\r\nimport { Tools } from \"./tools\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport { InternalTexture, InternalTextureSource } from \"../Materials/Textures/internalTexture\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { initializeWebWorker, workerFunction } from \"./basisWorker\";\r\nimport type { AbstractEngine } from \"core/Engines/abstractEngine\";\r\nimport type { Engine } from \"core/Engines/engine\";\r\n\r\n/**\r\n * Info about the .basis files\r\n */\r\nexport class BasisFileInfo {\r\n    /**\r\n     * If the file has alpha\r\n     */\r\n    public hasAlpha: boolean;\r\n    /**\r\n     * Info about each image of the basis file\r\n     */\r\n    public images: Array<{ levels: Array<{ width: number; height: number; transcodedPixels: ArrayBufferView }> }>;\r\n}\r\n\r\n/**\r\n * Result of transcoding a basis file\r\n */\r\nclass TranscodeResult {\r\n    /**\r\n     * Info about the .basis file\r\n     */\r\n    public fileInfo: BasisFileInfo;\r\n    /**\r\n     * Format to use when loading the file\r\n     */\r\n    public format: number;\r\n}\r\n\r\n/**\r\n * Configuration options for the Basis transcoder\r\n */\r\nexport class BasisTranscodeConfiguration {\r\n    /**\r\n     * Supported compression formats used to determine the supported output format of the transcoder\r\n     */\r\n    supportedCompressionFormats?: {\r\n        /**\r\n         * etc1 compression format\r\n         */\r\n        etc1?: boolean;\r\n        /**\r\n         * s3tc compression format\r\n         */\r\n        s3tc?: boolean;\r\n        /**\r\n         * pvrtc compression format\r\n         */\r\n        pvrtc?: boolean;\r\n        /**\r\n         * etc2 compression format\r\n         */\r\n        etc2?: boolean;\r\n        /**\r\n         * astc compression format\r\n         */\r\n        astc?: boolean;\r\n        /**\r\n         * bc7 compression format\r\n         */\r\n        bc7?: boolean;\r\n    };\r\n    /**\r\n     * If mipmap levels should be loaded for transcoded images (Default: true)\r\n     */\r\n    loadMipmapLevels?: boolean;\r\n    /**\r\n     * Index of a single image to load (Default: all images)\r\n     */\r\n    loadSingleImage?: number;\r\n}\r\n\r\n/**\r\n * @internal\r\n * Enum of basis transcoder formats\r\n */\r\nenum BASIS_FORMATS {\r\n    cTFETC1 = 0,\r\n    cTFETC2 = 1,\r\n    cTFBC1 = 2,\r\n    cTFBC3 = 3,\r\n    cTFBC4 = 4,\r\n    cTFBC5 = 5,\r\n    cTFBC7 = 6,\r\n    cTFPVRTC1_4_RGB = 8,\r\n    cTFPVRTC1_4_RGBA = 9,\r\n    cTFASTC_4x4 = 10,\r\n    cTFATC_RGB = 11,\r\n    cTFATC_RGBA_INTERPOLATED_ALPHA = 12,\r\n    cTFRGBA32 = 13,\r\n    cTFRGB565 = 14,\r\n    cTFBGR565 = 15,\r\n    cTFRGBA4444 = 16,\r\n    cTFFXT1_RGB = 17,\r\n    cTFPVRTC2_4_RGB = 18,\r\n    cTFPVRTC2_4_RGBA = 19,\r\n    cTFETC2_EAC_R11 = 20,\r\n    cTFETC2_EAC_RG11 = 21,\r\n}\r\n\r\n/**\r\n * Used to load .Basis files\r\n * See https://github.com/BinomialLLC/basis_universal/tree/master/webgl\r\n */\r\nexport const BasisToolsOptions = {\r\n    /**\r\n     * URL to use when loading the basis transcoder\r\n     */\r\n    JSModuleURL: `${Tools._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.js`,\r\n    /**\r\n     * URL to use when loading the wasm module for the transcoder\r\n     */\r\n    WasmModuleURL: `${Tools._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.wasm`,\r\n};\r\n\r\n/**\r\n * Get the internal format to be passed to texImage2D corresponding to the .basis format value\r\n * @param basisFormat format chosen from GetSupportedTranscodeFormat\r\n * @param engine\r\n * @returns internal format corresponding to the Basis format\r\n */\r\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\r\nexport const GetInternalFormatFromBasisFormat = (basisFormat: number, engine: AbstractEngine) => {\r\n    let format;\r\n    switch (basisFormat) {\r\n        case BASIS_FORMATS.cTFETC1:\r\n            format = Constants.TEXTUREFORMAT_COMPRESSED_RGB_ETC1_WEBGL;\r\n            break;\r\n        case BASIS_FORMATS.cTFBC1:\r\n            format = Constants.TEXTUREFORMAT_COMPRESSED_RGB_S3TC_DXT1;\r\n            break;\r\n        case BASIS_FORMATS.cTFBC4:\r\n            format = Constants.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT5;\r\n            break;\r\n        case BASIS_FORMATS.cTFASTC_4x4:\r\n            format = Constants.TEXTUREFORMAT_COMPRESSED_RGBA_ASTC_4x4;\r\n            break;\r\n        case BASIS_FORMATS.cTFETC2:\r\n            format = Constants.TEXTUREFORMAT_COMPRESSED_RGBA8_ETC2_EAC;\r\n            break;\r\n        case BASIS_FORMATS.cTFBC7:\r\n            format = Constants.TEXTUREFORMAT_COMPRESSED_RGBA_BPTC_UNORM;\r\n            break;\r\n    }\r\n\r\n    if (format === undefined) {\r\n        // eslint-disable-next-line no-throw-literal\r\n        throw \"The chosen Basis transcoder format is not currently supported\";\r\n    }\r\n\r\n    return format;\r\n};\r\n\r\nlet _WorkerPromise: Nullable<Promise<Worker>> = null;\r\nlet _Worker: Nullable<Worker> = null;\r\nlet _actionId = 0;\r\nconst _IgnoreSupportedFormats = false;\r\nconst _CreateWorkerAsync = () => {\r\n    if (!_WorkerPromise) {\r\n        _WorkerPromise = new Promise((res, reject) => {\r\n            if (_Worker) {\r\n                res(_Worker);\r\n            } else {\r\n                Tools.LoadFileAsync(Tools.GetBabylonScriptURL(BasisToolsOptions.WasmModuleURL))\r\n                    .then((wasmBinary) => {\r\n                        if (typeof URL !== \"function\") {\r\n                            return reject(\"Basis transcoder requires an environment with a URL constructor\");\r\n                        }\r\n                        const workerBlobUrl = URL.createObjectURL(new Blob([`(${workerFunction})()`], { type: \"application/javascript\" }));\r\n                        _Worker = new Worker(workerBlobUrl);\r\n                        initializeWebWorker(_Worker, wasmBinary, BasisToolsOptions.JSModuleURL).then(res, reject);\r\n                    })\r\n                    .catch(reject);\r\n            }\r\n        });\r\n    }\r\n    return _WorkerPromise;\r\n};\r\n\r\n/**\r\n * Set the worker to use for transcoding\r\n * @param worker The worker that will be used for transcoding\r\n */\r\nexport const SetBasisTranscoderWorker = (worker: Worker) => {\r\n    _Worker = worker;\r\n};\r\n\r\n/**\r\n * Transcodes a loaded image file to compressed pixel data\r\n * @param data image data to transcode\r\n * @param config configuration options for the transcoding\r\n * @returns a promise resulting in the transcoded image\r\n */\r\nexport const TranscodeAsync = (data: ArrayBuffer | ArrayBufferView, config: BasisTranscodeConfiguration): Promise<TranscodeResult> => {\r\n    const dataView = data instanceof ArrayBuffer ? new Uint8Array(data) : data;\r\n\r\n    return new Promise((res, rej) => {\r\n        _CreateWorkerAsync().then(\r\n            () => {\r\n                const actionId = _actionId++;\r\n                const messageHandler = (msg: any) => {\r\n                    if (msg.data.action === \"transcode\" && msg.data.id === actionId) {\r\n                        _Worker!.removeEventListener(\"message\", messageHandler);\r\n                        if (!msg.data.success) {\r\n                            rej(\"Transcode is not supported on this device\");\r\n                        } else {\r\n                            res(msg.data);\r\n                        }\r\n                    }\r\n                };\r\n                _Worker!.addEventListener(\"message\", messageHandler);\r\n\r\n                const dataViewCopy = new Uint8Array(dataView.byteLength);\r\n                dataViewCopy.set(new Uint8Array(dataView.buffer, dataView.byteOffset, dataView.byteLength));\r\n                _Worker!.postMessage({ action: \"transcode\", id: actionId, imageData: dataViewCopy, config: config, ignoreSupportedFormats: _IgnoreSupportedFormats }, [\r\n                    dataViewCopy.buffer,\r\n                ]);\r\n            },\r\n            (error) => {\r\n                rej(error);\r\n            }\r\n        );\r\n    });\r\n};\r\n\r\n/**\r\n * Binds a texture according to its underlying target.\r\n * @param texture texture to bind\r\n * @param engine the engine to bind the texture in\r\n */\r\nconst BindTexture = (texture: InternalTexture, engine: Engine): void => {\r\n    let target: GLenum = engine._gl?.TEXTURE_2D;\r\n    if (texture.isCube) {\r\n        target = engine._gl?.TEXTURE_CUBE_MAP;\r\n    }\r\n\r\n    engine._bindTextureDirectly(target, texture, true);\r\n};\r\n\r\n/**\r\n * Loads a texture from the transcode result\r\n * @param texture texture load to\r\n * @param transcodeResult the result of transcoding the basis file to load from\r\n */\r\nexport const LoadTextureFromTranscodeResult = (texture: InternalTexture, transcodeResult: TranscodeResult) => {\r\n    const engine = texture.getEngine() as Engine;\r\n    for (let i = 0; i < transcodeResult.fileInfo.images.length; i++) {\r\n        const rootImage = transcodeResult.fileInfo.images[i].levels[0];\r\n        texture._invertVScale = texture.invertY;\r\n        if (transcodeResult.format === -1 || transcodeResult.format === BASIS_FORMATS.cTFRGB565) {\r\n            // No compatable compressed format found, fallback to RGB\r\n            texture.type = Constants.TEXTURETYPE_UNSIGNED_SHORT_5_6_5;\r\n            texture.format = Constants.TEXTUREFORMAT_RGB;\r\n\r\n            if (engine._features.basisNeedsPOT && (Math.log2(rootImage.width) % 1 !== 0 || Math.log2(rootImage.height) % 1 !== 0)) {\r\n                // Create non power of two texture\r\n                const source = new InternalTexture(engine, InternalTextureSource.Temp);\r\n\r\n                texture._invertVScale = texture.invertY;\r\n                source.type = Constants.TEXTURETYPE_UNSIGNED_SHORT_5_6_5;\r\n                source.format = Constants.TEXTUREFORMAT_RGB;\r\n                // Fallback requires aligned width/height\r\n                source.width = (rootImage.width + 3) & ~3;\r\n                source.height = (rootImage.height + 3) & ~3;\r\n                BindTexture(source, engine);\r\n                engine._uploadDataToTextureDirectly(source, new Uint16Array(rootImage.transcodedPixels.buffer), i, 0, Constants.TEXTUREFORMAT_RGB, true);\r\n\r\n                // Resize to power of two\r\n                engine._rescaleTexture(source, texture, engine.scenes[0], engine._getInternalFormat(Constants.TEXTUREFORMAT_RGB), () => {\r\n                    engine._releaseTexture(source);\r\n                    BindTexture(texture, engine);\r\n                });\r\n            } else {\r\n                // Fallback is already inverted\r\n                texture._invertVScale = !texture.invertY;\r\n\r\n                // Upload directly\r\n                texture.width = (rootImage.width + 3) & ~3;\r\n                texture.height = (rootImage.height + 3) & ~3;\r\n                texture.samplingMode = Constants.TEXTURE_LINEAR_LINEAR;\r\n                BindTexture(texture, engine);\r\n                engine._uploadDataToTextureDirectly(texture, new Uint16Array(rootImage.transcodedPixels.buffer), i, 0, Constants.TEXTUREFORMAT_RGB, true);\r\n            }\r\n        } else {\r\n            texture.width = rootImage.width;\r\n            texture.height = rootImage.height;\r\n            texture.generateMipMaps = transcodeResult.fileInfo.images[i].levels.length > 1;\r\n\r\n            const format = BasisTools.GetInternalFormatFromBasisFormat(transcodeResult.format!, engine);\r\n            texture.format = format;\r\n\r\n            BindTexture(texture, engine);\r\n\r\n            // Upload all mip levels in the file\r\n            transcodeResult.fileInfo.images[i].levels.forEach((level: any, index: number) => {\r\n                engine._uploadCompressedDataToTextureDirectly(texture, format, level.width, level.height, level.transcodedPixels, i, index);\r\n            });\r\n\r\n            if (engine._features.basisNeedsPOT && (Math.log2(texture.width) % 1 !== 0 || Math.log2(texture.height) % 1 !== 0)) {\r\n                Tools.Warn(\r\n                    \"Loaded .basis texture width and height are not a power of two. Texture wrapping will be set to Texture.CLAMP_ADDRESSMODE as other modes are not supported with non power of two dimensions in webGL 1.\"\r\n                );\r\n                texture._cachedWrapU = Texture.CLAMP_ADDRESSMODE;\r\n                texture._cachedWrapV = Texture.CLAMP_ADDRESSMODE;\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * Used to load .Basis files\r\n * See https://github.com/BinomialLLC/basis_universal/tree/master/webgl\r\n */\r\nexport const BasisTools = {\r\n    /**\r\n     * URL to use when loading the basis transcoder\r\n     */\r\n    JSModuleURL: BasisToolsOptions.JSModuleURL,\r\n    /**\r\n     * URL to use when loading the wasm module for the transcoder\r\n     */\r\n    WasmModuleURL: BasisToolsOptions.WasmModuleURL,\r\n\r\n    /**\r\n     * Get the internal format to be passed to texImage2D corresponding to the .basis format value\r\n     * @param basisFormat format chosen from GetSupportedTranscodeFormat\r\n     * @returns internal format corresponding to the Basis format\r\n     */\r\n    GetInternalFormatFromBasisFormat,\r\n\r\n    /**\r\n     * Transcodes a loaded image file to compressed pixel data\r\n     * @param data image data to transcode\r\n     * @param config configuration options for the transcoding\r\n     * @returns a promise resulting in the transcoded image\r\n     */\r\n    TranscodeAsync,\r\n\r\n    /**\r\n     * Loads a texture from the transcode result\r\n     * @param texture texture load to\r\n     * @param transcodeResult the result of transcoding the basis file to load from\r\n     */\r\n    LoadTextureFromTranscodeResult,\r\n};\r\n\r\nObject.defineProperty(BasisTools, \"JSModuleURL\", {\r\n    get: function (this: null) {\r\n        return BasisToolsOptions.JSModuleURL;\r\n    },\r\n    set: function (this: null, value: string) {\r\n        BasisToolsOptions.JSModuleURL = value;\r\n    },\r\n});\r\n\r\nObject.defineProperty(BasisTools, \"WasmModuleURL\", {\r\n    get: function (this: null) {\r\n        return BasisToolsOptions.WasmModuleURL;\r\n    },\r\n    set: function (this: null, value: string) {\r\n        BasisToolsOptions.WasmModuleURL = value;\r\n    },\r\n});\r\n","/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { Nullable } from \"core/types\";\r\nimport { Tools } from \"./tools\";\r\nimport type { BasisFileInfo, BasisTranscodeConfiguration } from \"./basis\";\r\n\r\n// WorkerGlobalScope\r\ndeclare function importScripts(...urls: string[]): void;\r\ndeclare function postMessage(message: any, transfer?: any[]): void;\r\ndeclare let BASIS: any;\r\n/**\r\n * The worker function that gets converted to a blob url to pass into a worker.\r\n * To be used if a developer wants to create their own worker instance and inject it instead of using the default worker.\r\n */\r\nexport function workerFunction(): void {\r\n    const _BASIS_FORMAT = {\r\n        cTFETC1: 0,\r\n        cTFETC2: 1,\r\n        cTFBC1: 2,\r\n        cTFBC3: 3,\r\n        cTFBC4: 4,\r\n        cTFBC5: 5,\r\n        cTFBC7: 6,\r\n        cTFPVRTC1_4_RGB: 8,\r\n        cTFPVRTC1_4_RGBA: 9,\r\n        cTFASTC_4x4: 10,\r\n        cTFATC_RGB: 11,\r\n        cTFATC_RGBA_INTERPOLATED_ALPHA: 12,\r\n        cTFRGBA32: 13,\r\n        cTFRGB565: 14,\r\n        cTFBGR565: 15,\r\n        cTFRGBA4444: 16,\r\n        cTFFXT1_RGB: 17,\r\n        cTFPVRTC2_4_RGB: 18,\r\n        cTFPVRTC2_4_RGBA: 19,\r\n        cTFETC2_EAC_R11: 20,\r\n        cTFETC2_EAC_RG11: 21,\r\n    };\r\n    let transcoderModulePromise: Nullable<PromiseLike<any>> = null;\r\n    onmessage = (event) => {\r\n        if (event.data.action === \"init\") {\r\n            // Load the transcoder if it hasn't been yet\r\n            if (event.data.url) {\r\n                // make sure we loaded the script correctly\r\n                try {\r\n                    importScripts(event.data.url);\r\n                } catch (e) {\r\n                    postMessage({ action: \"error\", error: e });\r\n                }\r\n            }\r\n            if (!transcoderModulePromise) {\r\n                transcoderModulePromise = BASIS({\r\n                    // Override wasm binary\r\n                    wasmBinary: event.data.wasmBinary,\r\n                });\r\n            }\r\n            if (transcoderModulePromise !== null) {\r\n                transcoderModulePromise.then((m) => {\r\n                    BASIS = m;\r\n                    m.initializeBasis();\r\n                    postMessage({ action: \"init\" });\r\n                });\r\n            }\r\n        } else if (event.data.action === \"transcode\") {\r\n            // Transcode the basis image and return the resulting pixels\r\n            const config: BasisTranscodeConfiguration = event.data.config;\r\n            const imgData = event.data.imageData;\r\n            const loadedFile = new BASIS.BasisFile(imgData);\r\n            const fileInfo = GetFileInfo(loadedFile);\r\n            let format = event.data.ignoreSupportedFormats ? null : GetSupportedTranscodeFormat(event.data.config, fileInfo);\r\n\r\n            let needsConversion = false;\r\n            if (format === null) {\r\n                needsConversion = true;\r\n                format = fileInfo.hasAlpha ? _BASIS_FORMAT.cTFBC3 : _BASIS_FORMAT.cTFBC1;\r\n            }\r\n\r\n            // Begin transcode\r\n            let success = true;\r\n            if (!loadedFile.startTranscoding()) {\r\n                success = false;\r\n            }\r\n\r\n            const buffers: Array<any> = [];\r\n            for (let imageIndex = 0; imageIndex < fileInfo.images.length; imageIndex++) {\r\n                if (!success) {\r\n                    break;\r\n                }\r\n                const image = fileInfo.images[imageIndex];\r\n                if (config.loadSingleImage === undefined || config.loadSingleImage === imageIndex) {\r\n                    let mipCount = image.levels.length;\r\n                    if (config.loadMipmapLevels === false) {\r\n                        mipCount = 1;\r\n                    }\r\n                    for (let levelIndex = 0; levelIndex < mipCount; levelIndex++) {\r\n                        const levelInfo = image.levels[levelIndex];\r\n\r\n                        const pixels = TranscodeLevel(loadedFile, imageIndex, levelIndex, format!, needsConversion);\r\n                        if (!pixels) {\r\n                            success = false;\r\n                            break;\r\n                        }\r\n                        levelInfo.transcodedPixels = pixels;\r\n                        buffers.push(levelInfo.transcodedPixels.buffer);\r\n                    }\r\n                }\r\n            }\r\n            // Close file\r\n            loadedFile.close();\r\n            loadedFile.delete();\r\n\r\n            if (needsConversion) {\r\n                format = -1;\r\n            }\r\n            if (!success) {\r\n                postMessage({ action: \"transcode\", success: success, id: event.data.id });\r\n            } else {\r\n                postMessage({ action: \"transcode\", success: success, id: event.data.id, fileInfo: fileInfo, format: format }, buffers);\r\n            }\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Detects the supported transcode format for the file\r\n     * @param config transcode config\r\n     * @param fileInfo info about the file\r\n     * @returns the chosed format or null if none are supported\r\n     */\r\n    function GetSupportedTranscodeFormat(config: BasisTranscodeConfiguration, fileInfo: BasisFileInfo): Nullable<number> {\r\n        let format = null;\r\n        if (config.supportedCompressionFormats) {\r\n            if (config.supportedCompressionFormats.astc) {\r\n                format = _BASIS_FORMAT.cTFASTC_4x4;\r\n            } else if (config.supportedCompressionFormats.bc7) {\r\n                format = _BASIS_FORMAT.cTFBC7;\r\n            } else if (config.supportedCompressionFormats.s3tc) {\r\n                format = fileInfo.hasAlpha ? _BASIS_FORMAT.cTFBC3 : _BASIS_FORMAT.cTFBC1;\r\n            } else if (config.supportedCompressionFormats.pvrtc) {\r\n                format = fileInfo.hasAlpha ? _BASIS_FORMAT.cTFPVRTC1_4_RGBA : _BASIS_FORMAT.cTFPVRTC1_4_RGB;\r\n            } else if (config.supportedCompressionFormats.etc2) {\r\n                format = _BASIS_FORMAT.cTFETC2;\r\n            } else if (config.supportedCompressionFormats.etc1) {\r\n                format = _BASIS_FORMAT.cTFETC1;\r\n            } else {\r\n                format = _BASIS_FORMAT.cTFRGB565;\r\n            }\r\n        }\r\n        return format;\r\n    }\r\n\r\n    /**\r\n     * Retrieves information about the basis file eg. dimensions\r\n     * @param basisFile the basis file to get the info from\r\n     * @returns information about the basis file\r\n     */\r\n    function GetFileInfo(basisFile: any): BasisFileInfo {\r\n        const hasAlpha = basisFile.getHasAlpha();\r\n        const imageCount = basisFile.getNumImages();\r\n        const images = [];\r\n        for (let i = 0; i < imageCount; i++) {\r\n            const imageInfo = {\r\n                levels: [] as Array<any>,\r\n            };\r\n            const levelCount = basisFile.getNumLevels(i);\r\n            for (let level = 0; level < levelCount; level++) {\r\n                const levelInfo = {\r\n                    width: basisFile.getImageWidth(i, level),\r\n                    height: basisFile.getImageHeight(i, level),\r\n                };\r\n                imageInfo.levels.push(levelInfo);\r\n            }\r\n            images.push(imageInfo);\r\n        }\r\n        const info = { hasAlpha, images };\r\n        return info;\r\n    }\r\n\r\n    function TranscodeLevel(loadedFile: any, imageIndex: number, levelIndex: number, format: number, convertToRgb565: boolean): Nullable<Uint8Array | Uint16Array> {\r\n        const dstSize = loadedFile.getImageTranscodedSizeInBytes(imageIndex, levelIndex, format);\r\n        let dst: Uint8Array | Uint16Array = new Uint8Array(dstSize);\r\n        if (!loadedFile.transcodeImage(dst, imageIndex, levelIndex, format, 1, 0)) {\r\n            return null;\r\n        }\r\n        // If no supported format is found, load as dxt and convert to rgb565\r\n        if (convertToRgb565) {\r\n            const alignedWidth = (loadedFile.getImageWidth(imageIndex, levelIndex) + 3) & ~3;\r\n            const alignedHeight = (loadedFile.getImageHeight(imageIndex, levelIndex) + 3) & ~3;\r\n            dst = ConvertDxtToRgb565(dst, 0, alignedWidth, alignedHeight);\r\n        }\r\n        return dst;\r\n    }\r\n\r\n    /**\r\n     * From https://github.com/BinomialLLC/basis_universal/blob/master/webgl/texture/dxt-to-rgb565.js\r\n     * An unoptimized version of dxtToRgb565.  Also, the floating\r\n     * point math used to compute the colors actually results in\r\n     * slightly different colors compared to hardware DXT decoders.\r\n     * @param src dxt src pixels\r\n     * @param srcByteOffset offset for the start of src\r\n     * @param  width aligned width of the image\r\n     * @param  height aligned height of the image\r\n     * @returns the converted pixels\r\n     */\r\n    function ConvertDxtToRgb565(src: Uint8Array, srcByteOffset: number, width: number, height: number): Uint16Array {\r\n        const c = new Uint16Array(4);\r\n        const dst = new Uint16Array(width * height);\r\n\r\n        const blockWidth = width / 4;\r\n        const blockHeight = height / 4;\r\n        for (let blockY = 0; blockY < blockHeight; blockY++) {\r\n            for (let blockX = 0; blockX < blockWidth; blockX++) {\r\n                const i = srcByteOffset + 8 * (blockY * blockWidth + blockX);\r\n                c[0] = src[i] | (src[i + 1] << 8);\r\n                c[1] = src[i + 2] | (src[i + 3] << 8);\r\n                c[2] =\r\n                    ((2 * (c[0] & 0x1f) + 1 * (c[1] & 0x1f)) / 3) |\r\n                    (((2 * (c[0] & 0x7e0) + 1 * (c[1] & 0x7e0)) / 3) & 0x7e0) |\r\n                    (((2 * (c[0] & 0xf800) + 1 * (c[1] & 0xf800)) / 3) & 0xf800);\r\n                c[3] =\r\n                    ((2 * (c[1] & 0x1f) + 1 * (c[0] & 0x1f)) / 3) |\r\n                    (((2 * (c[1] & 0x7e0) + 1 * (c[0] & 0x7e0)) / 3) & 0x7e0) |\r\n                    (((2 * (c[1] & 0xf800) + 1 * (c[0] & 0xf800)) / 3) & 0xf800);\r\n                for (let row = 0; row < 4; row++) {\r\n                    const m = src[i + 4 + row];\r\n                    let dstI = (blockY * 4 + row) * width + blockX * 4;\r\n                    dst[dstI++] = c[m & 0x3];\r\n                    dst[dstI++] = c[(m >> 2) & 0x3];\r\n                    dst[dstI++] = c[(m >> 4) & 0x3];\r\n                    dst[dstI++] = c[(m >> 6) & 0x3];\r\n                }\r\n            }\r\n        }\r\n        return dst;\r\n    }\r\n}\r\n\r\n/**\r\n * Initialize a web worker with the basis transcoder\r\n * @param worker the worker to initialize\r\n * @param wasmBinary the wasm binary to load into the worker\r\n * @param moduleUrl the url to the basis transcoder module\r\n * @returns a promise that resolves when the worker is initialized\r\n */\r\nexport function initializeWebWorker(worker: Worker, wasmBinary: ArrayBuffer, moduleUrl?: string) {\r\n    return new Promise<Worker>((res, reject) => {\r\n        const initHandler = (msg: any) => {\r\n            if (msg.data.action === \"init\") {\r\n                worker!.removeEventListener(\"message\", initHandler);\r\n                res(worker!);\r\n            } else if (msg.data.action === \"error\") {\r\n                reject(msg.data.error || \"error initializing worker\");\r\n            }\r\n        };\r\n        worker.addEventListener(\"message\", initHandler);\r\n        // we can use transferable objects here because the worker will own the ArrayBuffer\r\n        worker.postMessage({ action: \"init\", url: moduleUrl ? Tools.GetBabylonScriptURL(moduleUrl) : undefined, wasmBinary }, [wasmBinary]);\r\n    });\r\n}\r\n","import type { Nullable } from \"../../../types\";\r\nimport type { InternalTexture } from \"../../../Materials/Textures/internalTexture\";\r\nimport type { IInternalTextureLoader } from \"./internalTextureLoader\";\r\nimport { LoadTextureFromTranscodeResult, TranscodeAsync } from \"../../../Misc/basis\";\r\nimport { Tools } from \"../../../Misc/tools\";\r\n\r\n/**\r\n * Loader for .basis file format\r\n * @internal\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class _BasisTextureLoader implements IInternalTextureLoader {\r\n    /**\r\n     * Defines whether the loader supports cascade loading the different faces.\r\n     */\r\n    public readonly supportCascades = false;\r\n\r\n    /**\r\n     * Uploads the cube texture data to the WebGL texture. It has already been bound.\r\n     * @param data contains the texture data\r\n     * @param texture defines the BabylonJS internal texture\r\n     * @param createPolynomials will be true if polynomials have been requested\r\n     * @param onLoad defines the callback to trigger once the texture is ready\r\n     * @param onError defines the callback to trigger in case of error\r\n     */\r\n    public loadCubeData(\r\n        data: ArrayBufferView | ArrayBufferView[],\r\n        texture: InternalTexture,\r\n        createPolynomials: boolean,\r\n        onLoad: Nullable<(data?: any) => void>,\r\n        onError: Nullable<(message?: string, exception?: any) => void>\r\n    ): void {\r\n        if (Array.isArray(data)) {\r\n            return;\r\n        }\r\n        const caps = texture.getEngine().getCaps();\r\n        const transcodeConfig = {\r\n            supportedCompressionFormats: {\r\n                etc1: caps.etc1 ? true : false,\r\n                s3tc: caps.s3tc ? true : false,\r\n                pvrtc: caps.pvrtc ? true : false,\r\n                etc2: caps.etc2 ? true : false,\r\n                astc: caps.astc ? true : false,\r\n                bc7: caps.bptc ? true : false,\r\n            },\r\n        };\r\n        TranscodeAsync(data, transcodeConfig)\r\n            .then((result) => {\r\n                const hasMipmap = result.fileInfo.images[0].levels.length > 1 && texture.generateMipMaps;\r\n                LoadTextureFromTranscodeResult(texture, result);\r\n                texture.getEngine()._setCubeMapTextureParams(texture, hasMipmap);\r\n                texture.isReady = true;\r\n                texture.onLoadedObservable.notifyObservers(texture);\r\n                texture.onLoadedObservable.clear();\r\n                if (onLoad) {\r\n                    onLoad();\r\n                }\r\n            })\r\n            .catch((err) => {\r\n                const errorMessage = \"Failed to transcode Basis file, transcoding may not be supported on this device\";\r\n                Tools.Warn(errorMessage);\r\n                texture.isReady = true;\r\n                if (onError) {\r\n                    onError(err);\r\n                }\r\n            });\r\n    }\r\n\r\n    /**\r\n     * Uploads the 2D texture data to the WebGL texture. It has already been bound once in the callback.\r\n     * @param data contains the texture data\r\n     * @param texture defines the BabylonJS internal texture\r\n     * @param callback defines the method to call once ready to upload\r\n     */\r\n    public loadData(\r\n        data: ArrayBufferView,\r\n        texture: InternalTexture,\r\n        callback: (width: number, height: number, loadMipmap: boolean, isCompressed: boolean, done: () => void, failedLoading?: boolean) => void\r\n    ): void {\r\n        const caps = texture.getEngine().getCaps();\r\n        const transcodeConfig = {\r\n            supportedCompressionFormats: {\r\n                etc1: caps.etc1 ? true : false,\r\n                s3tc: caps.s3tc ? true : false,\r\n                pvrtc: caps.pvrtc ? true : false,\r\n                etc2: caps.etc2 ? true : false,\r\n                astc: caps.astc ? true : false,\r\n                bc7: caps.bptc ? true : false,\r\n            },\r\n        };\r\n        TranscodeAsync(data, transcodeConfig)\r\n            .then((result) => {\r\n                const rootImage = result.fileInfo.images[0].levels[0];\r\n                const hasMipmap = result.fileInfo.images[0].levels.length > 1 && texture.generateMipMaps;\r\n                callback(rootImage.width, rootImage.height, hasMipmap, result.format !== -1, () => {\r\n                    LoadTextureFromTranscodeResult(texture, result);\r\n                });\r\n            })\r\n            .catch((err) => {\r\n                Tools.Warn(\"Failed to transcode Basis file, transcoding may not be supported on this device\");\r\n                Tools.Warn(`Failed to transcode Basis file: ${err}`);\r\n                callback(0, 0, false, false, () => {}, true);\r\n            });\r\n    }\r\n}\r\n"],"names":["BASIS_FORMATS","workerFunction","transcoderModulePromise","TranscodeLevel","loadedFile","imageIndex","levelIndex","format","convertToRgb565","dstSize","getImageTranscodedSizeInBytes","dst","Uint8Array","transcodeImage","src","srcByteOffset","width","height","c","Uint16Array","blockWidth","blockHeight","blockY","blockX","i","row","m","dstI","ConvertDxtToRgb565","getImageWidth","getImageHeight","onmessage","event","data","action","url","importScripts","e","postMessage","error","BASIS","wasmBinary","then","initializeBasis","config","imgData","imageData","BasisFile","fileInfo","basisFile","hasAlpha","getHasAlpha","imageCount","getNumImages","images","imageInfo","levels","levelCount","getNumLevels","level","levelInfo","push","GetFileInfo","ignoreSupportedFormats","supportedCompressionFormats","astc","bc7","s3tc","pvrtc","etc2","etc1","GetSupportedTranscodeFormat","needsConversion","success","startTranscoding","buffers","length","image","undefined","loadSingleImage","mipCount","loadMipmapLevels","pixels","transcodedPixels","buffer","close","delete","id","BasisToolsOptions","JSModuleURL","_DefaultCdnUrl","WasmModuleURL","_WorkerPromise","_Worker","_actionId","TranscodeAsync","dataView","ArrayBuffer","Promise","res","rej","reject","LoadFileAsync","GetBabylonScriptURL","URL","workerBlobUrl","createObjectURL","Blob","type","Worker","worker","moduleUrl","initHandler","msg","removeEventListener","addEventListener","initializeWebWorker","catch","actionId","messageHandler","dataViewCopy","byteLength","set","byteOffset","BindTexture","texture","engine","target","_gl","TEXTURE_2D","isCube","TEXTURE_CUBE_MAP","_bindTextureDirectly","LoadTextureFromTranscodeResult","transcodeResult","getEngine","rootImage","_invertVScale","invertY","cTFRGB565","_features","basisNeedsPOT","Math","log2","samplingMode","_uploadDataToTextureDirectly","source","_rescaleTexture","scenes","_getInternalFormat","_releaseTexture","generateMipMaps","BasisTools","GetInternalFormatFromBasisFormat","forEach","index","_uploadCompressedDataToTextureDirectly","Warn","_cachedWrapU","CLAMP_ADDRESSMODE","_cachedWrapV","basisFormat","cTFETC1","cTFBC1","cTFBC4","cTFASTC_4x4","cTFETC2","cTFBC7","Object","defineProperty","get","value","_BasisTextureLoader","supportCascades","loadCubeData","createPolynomials","onLoad","onError","Array","isArray","caps","getCaps","transcodeConfig","bptc","result","hasMipmap","_setCubeMapTextureParams","isReady","onLoadedObservable","notifyObservers","clear","err","loadData","callback"],"sourceRoot":""}