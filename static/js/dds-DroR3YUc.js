import{A as D,R as At,b as yt,I as pt,_ as Ft,c as T,F as w,T as H,C as L}from"./index-BqJGTxyM.js";import{C as Ct}from"./cubemapToSphericalPolynomial-oOmOPK3D.js";function dt(C){const n=C.split("?")[0],e=n.lastIndexOf(".");return e>-1?n.substring(e).toLowerCase():""}D.prototype._partialLoadFile=function(C,n,e,r,o=null){const c=t=>{e[n]=t,e._internalCount++,e._internalCount===6&&r(e)},A=(t,i)=>{o&&t&&o(t.status+" "+t.statusText,i)};this._loadFile(C,c,void 0,void 0,!0,A)};D.prototype._cascadeLoadFiles=function(C,n,e,r=null){const o=[];o._internalCount=0;for(let c=0;c<6;c++)this._partialLoadFile(e[c],c,o,n,r)};D.prototype._cascadeLoadImgs=function(C,n,e,r,o=null,c){const A=[];A._internalCount=0;for(let t=0;t<6;t++)this._partialLoadImg(r[t],t,A,C,n,e,o,c)};D.prototype._partialLoadImg=function(C,n,e,r,o,c,A=null,t){const i=At();yt(C,l=>{e[n]=l,e._internalCount++,r&&r.removePendingData(i),e._internalCount===6&&c&&c(o,e)},(l,f)=>{r&&r.removePendingData(i),A&&A(l,f)},r?r.offlineProvider:null,t),r&&r.addPendingData(i)};D.prototype.createCubeTextureBase=function(C,n,e,r,o=null,c=null,A,t=null,i=!1,a=0,s=0,l=null,f=null,h=null,y=!1,p=null){const u=l||new pt(this,7);u.isCube=!0,u.url=C,u.generateMipMaps=!r,u._lodGenerationScale=a,u._lodGenerationOffset=s,u._useSRGBBuffer=!!y&&this._caps.supportSRGBBuffers&&(this.version>1||this.isWebGPU||!!r),u!==l&&(u.label=C.substring(0,60)),this._doNotHandleContextLost||(u._extension=t,u._files=e,u._buffer=p);const _=C;this._transformTextureUrl&&!l&&(C=this._transformTextureUrl(C));const R=t??dt(C),P=Ft(R),b=(G,d)=>{u.dispose(),c?c(G,d):G&&T.Warn(G)},I=(G,d)=>{C===_?G&&b(G.status+" "+G.statusText,d):(T.Warn(`Failed to load ${C}, falling back to the ${_}`),this.createCubeTextureBase(_,n,e,!!r,o,b,A,t,i,a,s,u,f,h,y,p))};if(P)P.then(G=>{const d=x=>{f&&f(u,x),G.loadCubeData(x,u,i,o,(k,E)=>{b(k,E)})};p?d(p):e&&e.length===6?G.supportCascades?this._cascadeLoadFiles(n,x=>d(x.map(k=>new Uint8Array(k))),e,b):b("Textures type does not support cascades."):this._loadFile(C,x=>d(new Uint8Array(x)),void 0,void 0,!0,I)});else{if(!e||e.length===0)throw new Error("Cannot load cubemap because files were not defined, or the correct loader was not found.");this._cascadeLoadImgs(n,u,(G,d)=>{h&&h(G,d)},e,b)}return this._internalTexturesCache.push(u),u};const _t=542327876,Q=131072,V=512,Y=4,Z=64,S=131072;function W(C){return C.charCodeAt(0)+(C.charCodeAt(1)<<8)+(C.charCodeAt(2)<<16)+(C.charCodeAt(3)<<24)}function Gt(C){return String.fromCharCode(C&255,C>>8&255,C>>16&255,C>>24&255)}const q=W("DXT1"),tt=W("DXT3"),et=W("DXT5"),$=W("DX10"),rt=113,at=116,nt=2,st=10,ht=88,j=31,mt=0,bt=1,ot=2,ft=3,v=4,it=7,J=20,lt=21,xt=22,Bt=23,Rt=24,Ot=25,Ut=26,wt=28,Lt=32;class F{static GetDDSInfo(n){const e=new Int32Array(n.buffer,n.byteOffset,j),r=new Int32Array(n.buffer,n.byteOffset,j+4);let o=1;e[ot]&Q&&(o=Math.max(1,e[it]));const c=e[lt],A=c===$?r[Lt]:0;let t=0;switch(c){case rt:t=2;break;case at:t=1;break;case $:if(A===st){t=2;break}if(A===nt){t=1;break}}return{width:e[v],height:e[ft],mipmapCount:o,isFourCC:(e[J]&Y)===Y,isRGB:(e[J]&Z)===Z,isLuminance:(e[J]&S)===S,isCube:(e[wt]&V)===V,isCompressed:c===q||c===tt||c===et,dxgiFormat:A,textureType:t}}static _GetHalfFloatAsFloatRGBAArrayBuffer(n,e,r,o,c,A){const t=new Float32Array(o),i=new Uint16Array(c,r);let a=0;for(let s=0;s<e;s++)for(let l=0;l<n;l++){const f=(l+s*n)*4;t[a]=w(i[f]),t[a+1]=w(i[f+1]),t[a+2]=w(i[f+2]),F.StoreLODInAlphaChannel?t[a+3]=A:t[a+3]=w(i[f+3]),a+=4}return t}static _GetHalfFloatRGBAArrayBuffer(n,e,r,o,c,A){if(F.StoreLODInAlphaChannel){const t=new Uint16Array(o),i=new Uint16Array(c,r);let a=0;for(let s=0;s<e;s++)for(let l=0;l<n;l++){const f=(l+s*n)*4;t[a]=i[f],t[a+1]=i[f+1],t[a+2]=i[f+2],t[a+3]=H(A),a+=4}return t}return new Uint16Array(c,r,o)}static _GetFloatRGBAArrayBuffer(n,e,r,o,c,A){if(F.StoreLODInAlphaChannel){const t=new Float32Array(o),i=new Float32Array(c,r);let a=0;for(let s=0;s<e;s++)for(let l=0;l<n;l++){const f=(l+s*n)*4;t[a]=i[f],t[a+1]=i[f+1],t[a+2]=i[f+2],t[a+3]=A,a+=4}return t}return new Float32Array(c,r,o)}static _GetFloatAsHalfFloatRGBAArrayBuffer(n,e,r,o,c,A){const t=new Uint16Array(o),i=new Float32Array(c,r);let a=0;for(let s=0;s<e;s++)for(let l=0;l<n;l++)t[a]=H(i[a]),t[a+1]=H(i[a+1]),t[a+2]=H(i[a+2]),F.StoreLODInAlphaChannel?t[a+3]=H(A):t[a+3]=H(i[a+3]),a+=4;return t}static _GetFloatAsUIntRGBAArrayBuffer(n,e,r,o,c,A){const t=new Uint8Array(o),i=new Float32Array(c,r);let a=0;for(let s=0;s<e;s++)for(let l=0;l<n;l++){const f=(l+s*n)*4;t[a]=L(i[f])*255,t[a+1]=L(i[f+1])*255,t[a+2]=L(i[f+2])*255,F.StoreLODInAlphaChannel?t[a+3]=A:t[a+3]=L(i[f+3])*255,a+=4}return t}static _GetHalfFloatAsUIntRGBAArrayBuffer(n,e,r,o,c,A){const t=new Uint8Array(o),i=new Uint16Array(c,r);let a=0;for(let s=0;s<e;s++)for(let l=0;l<n;l++){const f=(l+s*n)*4;t[a]=L(w(i[f]))*255,t[a+1]=L(w(i[f+1]))*255,t[a+2]=L(w(i[f+2]))*255,F.StoreLODInAlphaChannel?t[a+3]=A:t[a+3]=L(w(i[f+3]))*255,a+=4}return t}static _GetRGBAArrayBuffer(n,e,r,o,c,A,t,i,a){const s=new Uint8Array(o),l=new Uint8Array(c,r);let f=0;for(let h=0;h<e;h++)for(let y=0;y<n;y++){const p=(y+h*n)*4;s[f]=l[p+A],s[f+1]=l[p+t],s[f+2]=l[p+i],s[f+3]=l[p+a],f+=4}return s}static _ExtractLongWordOrder(n){return n===0||n===255||n===-16777216?0:1+F._ExtractLongWordOrder(n>>8)}static _GetRGBArrayBuffer(n,e,r,o,c,A,t,i){const a=new Uint8Array(o),s=new Uint8Array(c,r);let l=0;for(let f=0;f<e;f++)for(let h=0;h<n;h++){const y=(h+f*n)*3;a[l]=s[y+A],a[l+1]=s[y+t],a[l+2]=s[y+i],l+=3}return a}static _GetLuminanceArrayBuffer(n,e,r,o,c){const A=new Uint8Array(o),t=new Uint8Array(c,r);let i=0;for(let a=0;a<e;a++)for(let s=0;s<n;s++){const l=s+a*n;A[i]=t[l],i++}return A}static UploadDDSLevels(n,e,r,o,c,A,t=-1,i,a=!0){let s=null;o.sphericalPolynomial&&(s=[]);const l=!!n.getCaps().s3tc;e.generateMipMaps=c;const f=new Int32Array(r.buffer,r.byteOffset,j);let h,y,p,u=0,_,R,P,b,I=0,G=1;if(f[mt]!==_t){T.Error("Invalid magic number in DDS header");return}if(!o.isFourCC&&!o.isRGB&&!o.isLuminance){T.Error("Unsupported format, must contain a FourCC, RGB or LUMINANCE code");return}if(o.isCompressed&&!l){T.Error("Compressed textures are not supported on this platform.");return}let d=f[xt];_=f[bt]+4;let x=!1;if(o.isFourCC)switch(h=f[lt],h){case q:G=8,I=33777;break;case tt:G=16,I=33778;break;case et:G=16,I=33779;break;case rt:x=!0,d=64;break;case at:x=!0,d=128;break;case $:{_+=5*4;let B=!1;switch(o.dxgiFormat){case st:x=!0,d=64,B=!0;break;case nt:x=!0,d=128,B=!0;break;case ht:o.isRGB=!0,o.isFourCC=!1,d=32,B=!0;break}if(B)break}default:T.Error(["Unsupported FourCC code:",Gt(h)]);return}const k=F._ExtractLongWordOrder(f[Bt]),E=F._ExtractLongWordOrder(f[Rt]),K=F._ExtractLongWordOrder(f[Ot]),ct=F._ExtractLongWordOrder(f[Ut]);x&&(I=n._getRGBABufferInternalSizedFormat(o.textureType)),P=1,f[ot]&Q&&c!==!1&&(P=Math.max(1,f[it]));const ut=i||0,M=n.getCaps();for(let B=ut;B<A;B++){for(y=f[v],p=f[ft],b=0;b<P;++b){if(t===-1||t===b){const m=t===-1?b:0;if(!o.isCompressed&&o.isFourCC){e.format=5,u=y*p*4;let O=null;if(n._badOS||n._badDesktopOS||!M.textureHalfFloat&&!M.textureFloat)d===128?(O=F._GetFloatAsUIntRGBAArrayBuffer(y,p,r.byteOffset+_,u,r.buffer,m),s&&m==0&&s.push(F._GetFloatRGBAArrayBuffer(y,p,r.byteOffset+_,u,r.buffer,m))):d===64&&(O=F._GetHalfFloatAsUIntRGBAArrayBuffer(y,p,r.byteOffset+_,u,r.buffer,m),s&&m==0&&s.push(F._GetHalfFloatAsFloatRGBAArrayBuffer(y,p,r.byteOffset+_,u,r.buffer,m))),e.type=0;else{const X=M.textureFloat&&(a&&M.textureFloatLinearFiltering||!a),N=M.textureHalfFloat&&(a&&M.textureHalfFloatLinearFiltering||!a),z=(d===128||d===64&&!N)&&X?1:(d===64||d===128&&!X)&&N?2:0;let g,U=null;switch(d){case 128:{switch(z){case 1:g=F._GetFloatRGBAArrayBuffer,U=null;break;case 2:g=F._GetFloatAsHalfFloatRGBAArrayBuffer,U=F._GetFloatRGBAArrayBuffer;break;case 0:g=F._GetFloatAsUIntRGBAArrayBuffer,U=F._GetFloatRGBAArrayBuffer;break}break}default:{switch(z){case 1:g=F._GetHalfFloatAsFloatRGBAArrayBuffer,U=null;break;case 2:g=F._GetHalfFloatRGBAArrayBuffer,U=F._GetHalfFloatAsFloatRGBAArrayBuffer;break;case 0:g=F._GetHalfFloatAsUIntRGBAArrayBuffer,U=F._GetHalfFloatAsFloatRGBAArrayBuffer;break}break}}e.type=z,O=g(y,p,r.byteOffset+_,u,r.buffer,m),s&&m==0&&s.push(U?U(y,p,r.byteOffset+_,u,r.buffer,m):O)}O&&n._uploadDataToTextureDirectly(e,O,B,m)}else if(o.isRGB)e.type=0,d===24?(e.format=4,u=y*p*3,R=F._GetRGBArrayBuffer(y,p,r.byteOffset+_,u,r.buffer,k,E,K),n._uploadDataToTextureDirectly(e,R,B,m)):(e.format=5,u=y*p*4,R=F._GetRGBAArrayBuffer(y,p,r.byteOffset+_,u,r.buffer,k,E,K,ct),n._uploadDataToTextureDirectly(e,R,B,m));else if(o.isLuminance){const O=n._getUnpackAlignement(),X=y;u=Math.floor((y+O-1)/O)*O*(p-1)+X,R=F._GetLuminanceArrayBuffer(y,p,r.byteOffset+_,u,r.buffer),e.format=1,e.type=0,n._uploadDataToTextureDirectly(e,R,B,m)}else u=Math.max(4,y)/4*Math.max(4,p)/4*G,R=new Uint8Array(r.buffer,r.byteOffset+_,u),e.type=0,n._uploadCompressedDataToTextureDirectly(e,I,y,p,R,B,m)}_+=d?y*p*(d/8):u,y*=.5,p*=.5,y=Math.max(1,y),p=Math.max(1,p)}if(i!==void 0)break}s&&s.length>0?o.sphericalPolynomial=Ct.ConvertCubeMapToSphericalPolynomial({size:f[v],right:s[0],left:s[1],up:s[2],down:s[3],front:s[4],back:s[5],format:5,type:1,gammaSpace:!1}):o.sphericalPolynomial=void 0}}F.StoreLODInAlphaChannel=!1;export{F as DDSTools};
